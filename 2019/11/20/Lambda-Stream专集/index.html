<!-- build time:Wed Apr 21 2021 21:07:17 GMT+0800 (China Standard Time) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="baidu-site-verification" content="jAIdNzdxMV"><meta name="author" content="Dong Yuanxin"><title>Lambda&amp;Stream专集 | salmon</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="java,java,Lambda,Stream,"><meta name="description" content=" Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 Stream APIStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！"><script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script src="//unpkg.com/valine/dist/Valine.min.js" async></script><script>window.AD_CONFIG={leancloud:{appid:"ocgtDtRN3Xyzytc5vbtpJJUM-gzGzoHsz",appkey:"lDrQAIWd40HOkpAStQbuLTaC",comment:!0,count:!0},welcome:{enable:!1,interval:30},start_time:"2019-3-29",passwords:["eb4d6a57c88d1e0b941646cdc244c926be77f88fd66748238d9c5819b6d99160"],is_post:!0,lock:!1,author:"卢国峥",share:{twitter:!1,facebook:!1,weibo:!1,qq:!1,wechat:!1},mathjax:!0,page_type:"",root:"/"}</script><script src="/js/jquery-2.0.3.min.js"></script><script src="/vendor/sha256.min.js"></script><script src="/js/auth.js"></script><script src="/js/index.js"></script><script src="/vendor/qrcode.min.js"></script><script src="/js/search.js"></script><script src="/js/header.js"></script><script src="/js/fancybox/jquery.fancybox.js"></script><script src="/js/fancyBox.js"></script><script src="/js/clipboard.min.js"></script><script src="/js/cpbutt.js"></script><script src="/js/baidusitemap.js"></script><script src="/js/diaspora/diaspora.js"></script><script src="/js/diaspora/plugin.js"></script><link rel="icon" href="/images/favicon.ico"><link rel="apple-touch-icon" href="/images/touch-icon.png"><link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"><link href="/js/fancybox/jquery.fancybox.css" rel="stylesheet" type="text/css"><link href="/css/diaspora/diaspora.css" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/styles/components/highlight/highlight.css"><link rel="stylesheet" href="/css/style.css"></head><body><header class="site-header"><div class="site-header-brand"><span class="site-header-brand-title"><a href="/">LGZ</a> </span><span class="site-header-brand-motto">| 年少无为,卖码为生 !</span></div><div class="site-header-right"><nav class="site-header-navigation"><a href="/" target="_self">首页</a> <a href="/archives/" target="_self">归档</a> <a href="/tags/" target="_self">标签</a> <a href="/categories/" target="_self">分类</a> <a target="_blank" href="http://file.lgzblog.com">在线网盘</a> <a href="#" class="nav-item-link nav-item-search" title="搜索"><i class="fe fe-search"></i> 搜索</a></nav><nav class="navbar"><a title="获取二维码" class="share iconfont icon-scan" href="javascript:;"></a><div id="qr"></div></nav><div class="site-header-btn"><a href="https://github.com/lgz8370?tab=repositories" target="_blank" id="site-github"><i class="fa fa-github-alt"></i></a></div></div><div class="search-form-wrap"><div class="local-search local-search-plugin"><input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."><div id="local-search-result" class="local-search-result"></div></div></div></header><nav class="table-content" id="site-nav"><div class="table-content-title"><span>导航</span></div><div class="table-content-main"><ol class="toc"><li class="toc-item"><a href="/" target="_self">首页</a></li><li class="toc-item"><a href="/archives/" target="_self">归档</a></li><li class="toc-item"><a href="/tags/" target="_self">标签</a></li><li class="toc-item"><a href="/categories/" target="_self">分类</a></li></ol></div></nav><div id="site-process"></div><main><div class="passage"><div class="passage-meta"><span><i class="fa fa-calendar"></i>2019-11-20 </span><span>| <a href="/categories/java/"><i class="fa fa-bookmark"></i>java</a> </span><span>| <i class="fa fa-unlock-alt"></i>UNLOCK</span></div><h1 class="passage-title">Lambda&Stream专集</h1><article class="passage-article"><h5 id="Java8新特性简介"><a href="#Java8新特性简介" class="headerlink" title="Java8新特性简介:"></a>Java8新特性简介:</h5><p><code>Java 8</code>可谓是自<code>Java 5</code>以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性:<br>（其中最为核心的为<code>Lambda</code> 表达式与<code>Stream API</code>）</p><ul><li><code>Lambda</code>表达式<br><code>Lambda</code>表达式可以说是Java 8最大的卖点，她将函数式编程引入了<code>Java</code>。<code>Lambda</code>允许把函数作为一个方法的参数，或者把代码看成数据。</li><li><p><code>Stream API</code><br><code>Stream API</code>是把真正的函数式编程风格引入到<code>Java</code>中。其实简单来说可以把<code>Stream</code>理解为<code>MapReduce</code>。从语法上看，也很像<code>linux</code>的管道、或者链式编程，代码写起来简洁明了，非常酷帅！</p></li><li><p>接口的默认方法与静态方法<br>我们可以在接口中定义默认方法，使用<code>default</code>关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。</p></li><li><p>方法引用<br>通常与<code>Lambda</code>表达式联合使用，可以直接引用已有<code>Java</code>类或对象的方法。</p></li><li><p>重复注解<br><code>Java 8</code>引入重复注解，相同的注解在同一地方也可以声明多次。</p></li><li><p>扩展注解的支持<br><code>Java 8</code>扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</p></li><li><p>Optional<br><code>Java 8引入Optional</code>类来防止空指针异常，使用<code>Optional</code>类我们就不用显式进行空指针检查了。</p></li><li><p>Date/Time API (JSR 310)<br>Java 8新的Date-Time API (JSR 310)受<code>Joda-Time</code>的影响，提供了新的<code>java.time</code>包，可以用来替代 <code>java.util.Date</code>和<code>java.util.Calendar</code>。</p></li><li><p>JavaScript引擎Nashorn<br><code>Nashorn</code>允许在<code>JVM</code>上开发运行<code>JavaScript</code>应用，允许Java与JavaScript相互调用。</p></li><li><p>Base64<br>在Java 8中，<code>Base64</code>编码成为了Java类库的标准。<code>Base64</code>类同时还提供了对<code>URL、MIME</code>友好的编码器与解码器。</p></li><li><p>更好的类型推测机制<br>Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。</p></li><li><p>编译器优化<br>Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-<code>parameters</code>参数。</p></li><li><p>并行（parallel）数组<br>支持对数组进行并行处理，主要是<code>parallelSort()</code>方法，它可以在多核机器上极大提高数组排序的速度。</p></li><li><p>并发（Concurrency）<br>在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。</p></li><li><p>Nashorn引擎jjs<br>基于<code>Nashorn</code>引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p></li><li><p>类依赖分析器jdeps<br>可以显示Java类的包级别或类级别的依赖。</p></li><li><p>JVM的PermGen空间被移除<br>取代它的是<code>Metaspace</code>（JEP 122）。</p><h5 id="Stream理解"><a href="#Stream理解" class="headerlink" title="Stream理解"></a>Stream理解</h5></li><li><p>元素序列<br>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如<code>ArrayList</code> 与 <code>LinkedList</code>）。但流的目的在于表达计算，比如<code>filter、sorted</code>和<code>map</code>。集合讲的是数据(存储)，流讲的是计算(处理)。</p></li><li><p>源<br>流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。</p></li><li><p>数据处理操作<br>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如<code>filter、map、reduce、find、match、sort</code>等。流操作可以顺序执行，也可并行执行。</p></li></ul><p>此外，流操作有两个重要的特点。</p><ul><li><p>流水线<br>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看作对数据源进行数据库式查询。</p></li><li><p>内部迭代<br>与使用迭代器外部迭代的集合不同，流的迭代操作是在背后进行的。</p></li></ul><p>–摘自《Java 8 In Action》</p><ul><li>总结:整体来看，流式思想类似于车间的“生产流水线”。<h5 id="一-创建流的方式"><a href="#一-创建流的方式" class="headerlink" title="一. 创建流的方式"></a>一. 创建流的方式</h5></li><li>Collection的默认方法stream()和parallelStream()</li><li>Arrays.stream()</li><li>Stream.of()</li><li>Stream.iterate()//迭代无限流(1, n-&gt;n +1)</li><li>Stream.generate()//生成无限流(Math::random)<h5 id="二-筛选和切片"><a href="#二-筛选和切片" class="headerlink" title="二. 筛选和切片"></a>二. 筛选和切片</h5><h6 id="①-过滤："><a href="#①-过滤：" class="headerlink" title="① 过滤："></a>① 过滤：</h6>filter(Predicate<t>p):(根据传入的Lambda返回的<code>ture/false</code> 从流中过滤掉某些数据(筛选出某些数据))</t></li></ul><h5 id="三-去重："><a href="#三-去重：" class="headerlink" title="三. 去重："></a>三. 去重：</h5><p>distinct():(根据流中数据的 <code>hashCode</code>和 <code>equals</code>去除重复元素)</p><h6 id="①-limit-long-n-："><a href="#①-limit-long-n-：" class="headerlink" title="① limit(long n)："></a>① limit(long n)：</h6><p>限定保留n个数据</p><h6 id="②-跳过n个数据："><a href="#②-跳过n个数据：" class="headerlink" title="② 跳过n个数据："></a>② 跳过n个数据：</h6><p>skip(long n)</p><h5 id="四-映射"><a href="#四-映射" class="headerlink" title="四. 映射"></a>四. 映射</h5><h6 id="①-map-Function-lt-T-R-gt-f-："><a href="#①-map-Function-lt-T-R-gt-f-：" class="headerlink" title="① map(Function&lt;T, R&gt; f)："></a>① map(Function&lt;T, R&gt; f)：</h6><p>接收一个函数作为参数，该函数会被应用到流中的每个元素上，并将其映射成一个新的元素。</p><h6 id="②-flatMap-Function-lt-T-Stream-gt-mapper-："><a href="#②-flatMap-Function-lt-T-Stream-gt-mapper-：" class="headerlink" title="② flatMap(Function&lt;T, Stream&gt; mapper)："></a>② flatMap(Function&lt;T, Stream<r>&gt; mapper)：</r></h6><p>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><h5 id="五-排序"><a href="#五-排序" class="headerlink" title="五. 排序"></a>五. 排序</h5><h6 id="①-sorted-："><a href="#①-sorted-：" class="headerlink" title="① sorted()："></a>① sorted()：</h6><p>自然排序使用Comparable<t>的int compareTo(T o)方法</t></p><h6 id="②-sorted-Comparator-com-："><a href="#②-sorted-Comparator-com-：" class="headerlink" title="② sorted(Comparator com)："></a>② sorted(Comparator<t>com)：</t></h6><p>定制排序使用Comparator的int compare(T o1, T o2)方法</p><h5 id="六-查找匹配"><a href="#六-查找匹配" class="headerlink" title="六. 查找匹配"></a>六. 查找匹配</h5><h6 id="①-检查是否匹配所有元素"><a href="#①-检查是否匹配所有元素" class="headerlink" title="① 检查是否匹配所有元素:"></a>① 检查是否匹配所有元素:</h6><p>allMatch</p><h6 id="②-检查是否至少匹配一个元素"><a href="#②-检查是否至少匹配一个元素" class="headerlink" title="② 检查是否至少匹配一个元素:"></a>② 检查是否至少匹配一个元素:</h6><p>anyMatch</p><h6 id="③-检查是否没有匹配的元素"><a href="#③-检查是否没有匹配的元素" class="headerlink" title="③ 检查是否没有匹配的元素:"></a>③ 检查是否没有匹配的元素:</h6><p>noneMatch</p><h6 id="④-findFirst"><a href="#④-findFirst" class="headerlink" title="④ findFirst:"></a>④ findFirst:</h6><p>返回第一个元素(返回值为Optional<t>)</t></p><h6 id="⑤-findAny"><a href="#⑤-findAny" class="headerlink" title="⑤ findAny:"></a>⑤ findAny:</h6><p>返回当前流中的任意元素(一般用于并行流)</p><p>●备注<br>Optional<t>是Java8新加入的一个容器，这个容器只存1个或0个元素，它用于防止出现NullpointException，它提供如下方法：</t></p><ul><li>isPresent()<br>判断容器中是否有值。</li><li>ifPresent(Consume lambda)<br>容器若不为空则执行括号中的Lambda表达式。</li><li>T get()<br>获取容器中的元素，若容器为空则抛出NoSuchElement异常。</li><li>T 获取容器中的元素，若容器为空则返回括号中的默认值 。<br>orElse(T other)</li></ul><h5 id="七-统计"><a href="#七-统计" class="headerlink" title="七. 统计"></a>七. 统计</h5><h6 id="①-返回流中元素的总个数"><a href="#①-返回流中元素的总个数" class="headerlink" title="① 返回流中元素的总个数:"></a>① 返回流中元素的总个数:</h6><p>count()</p><h6 id="②-max-Comparator"><a href="#②-max-Comparator" class="headerlink" title="② max(Comparator):"></a>② max(Comparator<t>):</t></h6><p>返回流中最大值</p><h6 id="③-min-Comparator"><a href="#③-min-Comparator" class="headerlink" title="③ min(Comparator):"></a>③ min(Comparator<t>):</t></h6><p>返回流中最小值</p><h5 id="八-归约"><a href="#八-归约" class="headerlink" title="八. 归约"></a>八. 归约</h5><h6 id="reduce-T-identity-BinaryOperator-reduce-BinaryOperator"><a href="#reduce-T-identity-BinaryOperator-reduce-BinaryOperator" class="headerlink" title="reduce(T identity, BinaryOperator) / reduce(BinaryOperator) :"></a>reduce(T identity, BinaryOperator) / reduce(BinaryOperator) :</h6><p>将流中元素挨个结合起来，得到一个值。</p><h5 id="九-分组和分区"><a href="#九-分组和分区" class="headerlink" title="九. 分组和分区"></a>九. 分组和分区</h5><h6 id="①-Collectors-groupingBy"><a href="#①-Collectors-groupingBy" class="headerlink" title="① Collectors.groupingBy()"></a>① Collectors.groupingBy()</h6><p>对元素做<code>group</code>操作。分组–根据条件分成多个组</p><h6 id="②-Collectors-partitioningBy"><a href="#②-Collectors-partitioningBy" class="headerlink" title="② Collectors.partitioningBy()"></a>② Collectors.partitioningBy()</h6><p>对元素进行二分区操作。分区–根据<code>boolean</code>条件分成两个区</p><h5 id="Stream总结-Stream-vs-Collection"><a href="#Stream总结-Stream-vs-Collection" class="headerlink" title="Stream总结(Stream vs Collection)"></a>Stream总结(Stream vs Collection)</h5><h6 id="Stream-vs-Collection"><a href="#Stream-vs-Collection" class="headerlink" title="Stream vs Collection"></a>Stream vs Collection</h6><p>虽然大部分情况下<code>Stream</code>是容器调用<code>Collection.stream()</code>方法得到的，但<code>Stream</code>和<code>Collection</code>有以下不同：</p><ul><li>无存储。<br>Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，集合等。</li><li>不修改。<br>对<code>Stream</code>的任何修改都不会修改背后的数据源，比如过滤操作并不会删除被过滤的元素，而是产生一个新Stream。</li><li>惰式执行。<br><code>Stream</code>上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。<br><code>Stream</code>只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。<h6 id="Stream分类"><a href="#Stream分类" class="headerlink" title="Stream分类"></a>Stream分类</h6>中间操作(intermediate operations)<br>返回值为<code>Stream</code>的大都是中间操作，中间操作支持链式调用，并且会惰式执行<br>终端操作(结束操作)(terminal operations)<br>返回值不为<code>Stream</code> 的为终端操作(立即求值)，终端操作不支持链式调用，会触发实际计算</li></ul></article><aside class="table-content" id="site-toc"><div class="table-content-title"><i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i> <span>目录</span></div><div class="table-content-main"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#Java8新特性简介"><span class="toc-text">Java8新特性简介:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream理解"><span class="toc-text">Stream理解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#一-创建流的方式"><span class="toc-text">一. 创建流的方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二-筛选和切片"><span class="toc-text">二. 筛选和切片</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-过滤："><span class="toc-text">① 过滤：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#三-去重："><span class="toc-text">三. 去重：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-limit-long-n-："><span class="toc-text">① limit(long n)：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-跳过n个数据："><span class="toc-text">② 跳过n个数据：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#四-映射"><span class="toc-text">四. 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-map-Function-lt-T-R-gt-f-："><span class="toc-text">① map(Function&lt;T, R&gt; f)：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-flatMap-Function-lt-T-Stream-gt-mapper-："><span class="toc-text">② flatMap(Function&lt;T, Stream&gt; mapper)：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#五-排序"><span class="toc-text">五. 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-sorted-："><span class="toc-text">① sorted()：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-sorted-Comparator-com-："><span class="toc-text">② sorted(Comparatorcom)：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#六-查找匹配"><span class="toc-text">六. 查找匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-检查是否匹配所有元素"><span class="toc-text">① 检查是否匹配所有元素:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-检查是否至少匹配一个元素"><span class="toc-text">② 检查是否至少匹配一个元素:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#③-检查是否没有匹配的元素"><span class="toc-text">③ 检查是否没有匹配的元素:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#④-findFirst"><span class="toc-text">④ findFirst:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#⑤-findAny"><span class="toc-text">⑤ findAny:</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#七-统计"><span class="toc-text">七. 统计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-返回流中元素的总个数"><span class="toc-text">① 返回流中元素的总个数:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-max-Comparator"><span class="toc-text">② max(Comparator):</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#③-min-Comparator"><span class="toc-text">③ min(Comparator):</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#八-归约"><span class="toc-text">八. 归约</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#reduce-T-identity-BinaryOperator-reduce-BinaryOperator"><span class="toc-text">reduce(T identity, BinaryOperator) / reduce(BinaryOperator) :</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#九-分组和分区"><span class="toc-text">九. 分组和分区</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#①-Collectors-groupingBy"><span class="toc-text">① Collectors.groupingBy()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#②-Collectors-partitioningBy"><span class="toc-text">② Collectors.partitioningBy()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Stream总结-Stream-vs-Collection"><span class="toc-text">Stream总结(Stream vs Collection)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Stream-vs-Collection"><span class="toc-text">Stream vs Collection</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Stream分类"><span class="toc-text">Stream分类</span></a></li></ol></li></ol></div></aside><aside class="passage-copyright"><div>本文作者: salmon</div><div>原文链接: <a href target="_blank">https://www.lgzblog.com/2019/11/20/Lambda-Stream专集/</a></div><div>版权声明: 本博客所有文章除特别声明外, 均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!</div></aside><div class="passage-tags"><a href="/tags/java/"><i class="fa fa-tags"></i>java</a> <a href="/tags/Lambda/"><i class="fa fa-tags"></i>Lambda</a> <a href="/tags/Stream/"><i class="fa fa-tags"></i>Stream</a></div></div></main><div class="site-comment-contanier" data-plateform="leancloud"><p id="site-comment-info"><i class="fa fa-spinner fa-spin"></i> 评论加载中</p><div id="site-comment"></div></div><div class="site-footer-wrapper"><footer class="site-footer"><div class="site-footer-col"><h5 class="site-footer-title">博客推荐</h5><span class="site-footer-item"><a href="https://www.cnblogs.com/mjios/" target="_blank">M了个J</a> </span><span class="site-footer-item"><a href="http://www.zhaojun.im/" target="_blank">赵俊的博客</a> </span><span class="site-footer-item"><a href="https://www.cnblogs.com/cjh-notes/" target="_blank">cjh</a></span></div><div class="site-footer-info"><i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span></div><div class="site-footer-info"><i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客 | <a href="https://beian.miit.gov.cn" target="_blank">粤ICP备19036088号</a></div><div class="site-footer-info"><i class="fa fa-at"></i> Email: lgz_silent@163.com</div><div class="site-footer-info"><i class="fa fa-copyright"></i> 2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>. Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>. All rights reserved.</div></footer></div><div id="site-layer" style="display:none"><div class="site-layer-content"><div class="site-layer-header"><span class="site-layer-header-title" id="site-layer-title"></span> <i class="fa fa-close" id="site-layer-close"></i></div><div class="site-layer-body" id="site-layer-container"><div class="site-layer-input" id="site-layer-search" style="display:none"><input type="text"> <i class="fa fa-search"></i></div><div class="site-layer-reward" id="site-layer-reward" style="display:none"><div><img src="/x" alt="WeChat"><p>WeChat</p></div><div><img src="/x" alt="AliPay"><p>AliPay</p></div></div><div id="site-layer-welcome" style="display:none"></div></div></div></div><div class="bottom-bar"><div class="bottom-bar-left"><a href="/2020/03/19/ElasticSearch常见面试题/" data-enable="true"><i class="fa fa-arrow-left"></i> </a><a href="/2019/11/13/2018-08-06-RabbitMQ-Four-models/" data-enable="true"><i class="fa fa-arrow-right"></i></a></div><div class="bottom-bar-right"><a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn"><i class="fa fa-bars"></i> </a><a href="#site-comment" data-enable="true"><i class="fa fa-commenting"></i> </a><a href="javascript:void(0);" id="site-toggle-share-btn"><i class="fa fa-share-alt"></i> </a><a href="javascript:void(0);" id="site-reward"><i class="fa fa-thumbs-up"></i> </a><a href="javascript:void(0);" id="back-top-btn"><i class="fa fa-chevron-up"></i></a></div></div><div id="share-btn"></div><div class="eevee"><div class="message">嗨，你好啊~~</div><div class="body"><div class="head"><div class="ears"><div class="ear"><div class="lobe"></div></div><div class="ear"><div class="lobe"></div></div></div><div class="face"><div class="eyes"><div class="eye"><div class="eyelid"></div></div><div class="eye"><div class="eyelid"></div></div></div><div class="nose"></div><div class="mouth"></div></div></div><div class="chest"><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div><div class="fur"><div class="patch"></div></div></div><div class="legs"><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div><div class="leg"><div class="inner-leg"></div></div></div><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail"><div class="tail -end"></div></div></div></div></div></div></div></div></body></html><!-- rebuild by neat -->