{"meta":{"title":"Luguozheng","subtitle":"哈哈哈","description":null,"author":"卢国峥","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-28T07:41:43.000Z","updated":"2019-03-29T03:52:49.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-25T16:30:47.191Z","updated":"2019-03-25T07:52:46.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"LocalDate操作时间","slug":"LocalDate操作时间","date":"2019-08-10T03:21:00.000Z","updated":"2019-08-10T04:55:10.183Z","comments":true,"path":"2019/08/10/LocalDate操作时间/","link":"","permalink":"http://yoursite.com/2019/08/10/LocalDate操作时间/","excerpt":"记录工具类API👇: 字符串转LocalDate 获取连续时间集合 获取连续时间集合12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";","text":"记录工具类API👇: 字符串转LocalDate 获取连续时间集合 获取连续时间集合12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";1. 字符串转LocalDate123456789/** * * @param time 时间yyyy-MM-dd * @return */ public static LocalDateTime stringToLocalDate(String time) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); return LocalDateTime.parse(time, df); &#125;2. 两个时间相差多少天123456789101112131415/** * 获取两个时间相差多少天 * * @param dates * @return */ public static long getDiffDays(String[] dates) &#123; if (dates.length &lt; 2) &#123; return 1; &#125; DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate begin = LocalDate.parse(dates[0], fmt); LocalDate end = LocalDate.parse(dates[1], fmt); return end.toEpochDay() - begin.toEpochDay() + 1; &#125;3. 获取连续时间集合1234567891011121314151617/** * 数据填充 * 可操作: 天/周/月/年 * @param time 间隔天数 * @param begin 开始时间 * @return */ public static List&lt;String&gt; getRangeIncres2(long time, String begin) &#123; List&lt;String&gt; list = Lists.newArrayList(); DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate localDate = LocalDate.parse(begin, fmt); for (int i = 0; i &lt; time; i++) &#123; list.add(localDate.plusDays(i).toString()); &#125; return list; &#125;","categories":[{"name":"工具类收藏","slug":"工具类收藏","permalink":"http://yoursite.com/categories/工具类收藏/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"卢国峥"},{"title":"ElasticSearch 中boolQueryBuilder的使用","slug":"ElasticSearch-中boolQueryBuilder的使用","date":"2019-08-08T01:29:00.000Z","updated":"2019-08-21T03:27:46.812Z","comments":true,"path":"2019/08/08/ElasticSearch-中boolQueryBuilder的使用/","link":"","permalink":"http://yoursite.com/2019/08/08/ElasticSearch-中boolQueryBuilder的使用/","excerpt":"Bool查询现在包括四种子句，must，filter,should,must_not.","text":"Bool查询现在包括四种子句，must，filter,should,must_not.转载自:https://blog.csdn.net/metheir/article/details/850803341. 为什么filter会快？看上面的流程图就能很明显的看到，filter与query还是有很大的区别的。比如，query的时候，会先比较查询条件，然后计算分值，最后返回文档结果；而filter则是先判断是否满足查询条件，如果不满足，会缓存查询过程（记录该文档不满足结果）；满足的话，就直接缓存结果。综上所述，filter快在两个方面：1 对结果进行缓存2 避免计算分值2. bool查询的使用Bool查询对应Lucene中的BooleanQuery,它由一个或者多个子句组成,每个子句都有特定的类型must返回的文档必须满足must子句的条件,并且参与计算分值filter返回的文档必须满足filter子句的条件,但是不会像must一样,参与计算分值should返回的文档可能满足should子句的条件.在一个bool查询中,如果没有must或者filter,有一个或者多个should子句,那么只要满足一个就可以返回.minimum_should_match参数定义了至少满足几个子句.must_not返回的文档必须不满足定义的条件如果一个查询既有filter又有should,那么至少包含一个should子句.bool查询也支持禁用协同计分选项disable_coord.一般计算分值的因素取决于所有的查询条件.bool查询也是采用more_matches_is_better的机制,因此满足must和should子句的文档将会合并起来计算分值.3.JavaAPI使用1234567891011121314151617@Testpublic void searchApi2() throws IOException &#123; SearchRequest searchRequest = new SearchRequest(\"item\"); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); // 必须匹配条件 boolQueryBuilder.must(QueryBuilders.matchQuery(\"scompCode\", \"G0000001\")); // 模糊查询 boolQueryBuilder.filter(QueryBuilders.wildcardQuery(\"itemDesc\", \"*手机*\")); // 范围查询 from:相当于闭区间; gt:相当于开区间(&gt;) gte:相当于闭区间 (&gt;=) lt:开区间(&lt;) lte:闭区间 (&lt;=) boolQueryBuilder.filter(QueryBuilders.rangeQuery(\"itemPrice\").from(4500).to(8899)); sourceBuilder.query(boolQueryBuilder); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); logger.info(\"查询数据:&#123;&#125;\", Arrays.toString(searchResponse.getHits().getHits()));&#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"http://yoursite.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/转载/"}],"author":"卢国峥"},{"title":"ElasticSearch API","slug":"ElasticSearch-API","date":"2019-08-07T07:58:00.000Z","updated":"2019-08-21T03:25:51.864Z","comments":true,"path":"2019/08/07/ElasticSearch-API/","link":"","permalink":"http://yoursite.com/2019/08/07/ElasticSearch-API/","excerpt":"ElasticSearch java API应用https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.0/java-rest-high-document-index.html","text":"ElasticSearch java API应用https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.0/java-rest-high-document-index.html1. 创建索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ElasticsearchRestClient &#123; private static final Logger logger = LogManager.getLogger(ElasticsearchRestClient.class); @Before public void beforGet() &#123; client = new RestHighLevelClient( RestClient.builder(new HttpHost(\"106.14.116.156\", 9200, \"http\"))); logger.info(\"ES客户端初始化\"); &#125; @After public void afterGet() throws IOException &#123; client.close(); logger.info(\"关闭ES连接\"); &#125; /** * 创建索引 * * @throws IOException */ @Test public void createIndex() throws IOException &#123; GetIndexRequest getIndexRequest = new GetIndexRequest(\"item\"); // 索引是否存在 boolean exists = client.indices().exists(getIndexRequest, RequestOptions.DEFAULT); if (!exists) &#123; CreateIndexRequest request = new CreateIndexRequest(\"item\"); XContentBuilder builder = XContentFactory.jsonBuilder(); builder.startObject(); &#123; // 固定格式 builder.startObject(\"properties\"); &#123; // itemCode字段 builder.startObject(\"itemCode\"); &#123; // 字段属性 builder.field(\"type\", \"keyword\"); &#125; builder.endObject(); // itemDesc字段 builder.startObject(\"itemDesc\"); &#123; // 字段属性 builder.field(\"type\", \"keyword\"); &#125; builder.endObject(); &#125; builder.endObject(); &#125; builder.endObject(); request.mapping(\"doc\", builder); CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); logger.info(\"创建索引结果:&#123;&#125;\", createIndexResponse.isAcknowledged()); &#125; else &#123; logger.info(\"[employee]索引已经存在\"); &#125; &#125;&#125;2.新增数据12345678910111213141516171819202122/** * 新增数据 * * @param client * @param index 索引 * @param id 文档id * @param jsonMap 需要建立索引的数据 key:字段,value:值 */ public static void index(RestHighLevelClient client, String index,String id, Map&lt;String, Object&gt; jsonMap) &#123; IndexRequest indexRequest = new IndexRequest(index); // id为空则自动生成id if (StringUtil.isNotEmpty(id)) &#123; indexRequest.id(id); &#125; indexRequest.source(jsonMap); try &#123; IndexResponse response = client.index(indexRequest, RequestOptions.DEFAULT); logger.info(\"索引结果:&#123;&#125;\", response.status().getStatus()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;3.删除数据12345678910111213141516171819/** * 删除数据 * * @param client * @param index 索引名称 * @param id 文档id */ @Test public static void delete(RestHighLevelClient client, String index,String id) &#123; DeleteRequest request = new DeleteRequest(index, id); DeleteResponse deleteResponse = null; try &#123; deleteResponse = client.delete(request, RequestOptions.DEFAULT); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.warn(\"ES删除异常信息:&#123;&#125;\",e.getMessage()); &#125; logger.warn(\"删除结果:&#123;&#125;\",deleteResponse.status().getStatus()); &#125;4.更新数据12345678910111213141516171819/** * * @param client * @param index 索引名称 * @param id 文档id */ @Test public static void update(RestHighLevelClient client, String index,String id,Map&lt;String,Object&gt; map) &#123; UpdateRequest request = new UpdateRequest(index,id); request.doc(map); UpdateResponse updateResponse = null; try &#123; updateResponse = client.update( request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; logger.warn(\"ES更新结果:&#123;&#125;\",updateResponse.getResult()); &#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"http://yoursite.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"远程调试springboot项目","slug":"远程调试springboot项目","date":"2019-07-27T03:27:00.000Z","updated":"2019-07-27T05:41:09.423Z","comments":true,"path":"2019/07/27/远程调试springboot项目/","link":"","permalink":"http://yoursite.com/2019/07/27/远程调试springboot项目/","excerpt":"IDEA远程调试项目~!","text":"IDEA远程调试项目~!1. 配置远程①②③2. 启动项目1nohup java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8888 &lt;jar包名称&gt;3. 远程debug开始4. 连接成功在本地打断点,访问服务器接口时,在本地即可实时调试了","categories":[{"name":"工具配置相关","slug":"工具配置相关","permalink":"http://yoursite.com/categories/工具配置相关/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"卢国峥"},{"title":"阿里CodeGIT账号密码获取方法","slug":"阿里CodeGIT账号密码获取方法","date":"2019-07-22T02:44:00.000Z","updated":"2019-08-21T03:31:05.250Z","comments":true,"path":"2019/07/22/阿里CodeGIT账号密码获取方法/","link":"","permalink":"http://yoursite.com/2019/07/22/阿里CodeGIT账号密码获取方法/","excerpt":"输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）","text":"输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"author":"卢国峥"},{"title":"Alibaba Cloud Toolkit插件使用","slug":"Alibaba-Cloud-Toolkit插件使用","date":"2019-07-22T02:22:00.000Z","updated":"2019-07-22T02:43:15.575Z","comments":true,"path":"2019/07/22/Alibaba-Cloud-Toolkit插件使用/","link":"","permalink":"http://yoursite.com/2019/07/22/Alibaba-Cloud-Toolkit插件使用/","excerpt":"Alibaba Cloud Toolkit 工具一键部署本地jar包","text":"Alibaba Cloud Toolkit 工具一键部署本地jar包1.安装 Alibaba Cloud Toolkit直接在IDEA插件中搜索安装即可2.添加远程服务器3. 配置打包部署项目","categories":[{"name":"插件使用系列","slug":"插件使用系列","permalink":"http://yoursite.com/categories/插件使用系列/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://yoursite.com/tags/插件/"}],"author":"卢国峥"},{"title":"时间转cron表达式","slug":"时间转cron表达式","date":"2019-07-15T01:50:00.000Z","updated":"2019-07-15T01:53:13.016Z","comments":true,"path":"2019/07/15/时间转cron表达式/","link":"","permalink":"http://yoursite.com/2019/07/15/时间转cron表达式/","excerpt":"记录一个时间转cron表达式的工具类","text":"记录一个时间转cron表达式的工具类DateToCronUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * @author LuGuoZheng * @date 2019/7/12 13:45 * @Version 3.0 * @description */public class DateToCronUtil &#123; private static final Logger logger = LoggerFactory.getLogger(DateToCronUtil.class); public static final String DEFUALT_LONG_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\"; private final static String H = \"H\"; private final static String D = \"D\"; private final static String W = \"W\"; private final static String M = \"M\"; private final static String Q = \"Q\"; private final static String Y = \"Y\"; /** * 每小时 */ private final static String DEFAULT_H_CRON = \"0 H * * * ? *\"; /** * 每天 */ private final static String DEFAULT_D_CRON = \"0 H D * * ? *\"; /** * 每周 */ private final static String DEFAULT_W_CRON = \"0 H D ? * W\"; /** * 每月 */ private final static String DEFAULT_M_CRON = \"0 H D M * ? *\"; /** * 每季度 */ private final static String DEFAULT_Q_CRON = \"0 H D M 1/3 ? *\"; /** * 每年 */ private final static String DEFAULT_Y_CRON = \"0 H D M Y ? *\"; public static LocalDateTime stringToLocalDate(String time) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(DEFUALT_LONG_TIME_FORMAT); return LocalDateTime.parse(time, df); &#125; /** * @param time 时间 yyyy-MM-dd HH:mm * @param timeType 类型:H-&gt;小时,D-&gt;天,W-&gt;周,M-&gt;月,Q-&gt;季度,Y-&gt;每年 * @return */ public static String getCron(String time, String timeType) &#123; LocalDateTime localDateTime = stringToLocalDate(time); logger.info(\"localDateTime:&#123;&#125;\", localDateTime); if (DateToCronUtil.H.equals(timeType)) &#123; return DEFAULT_H_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\"); &#125; else if (DateToCronUtil.D.equals(timeType)) &#123; return DEFAULT_D_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\"); &#125; else if (DateToCronUtil.W.equals(timeType)) &#123; return DEFAULT_W_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.W, (localDateTime.get(ChronoField.DAY_OF_WEEK) == 7 ? 1 : localDateTime.get(ChronoField.DAY_OF_WEEK) + 1) + \"\"); &#125; else if (DateToCronUtil.M.equals(timeType)) &#123; return DEFAULT_M_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.M, localDateTime.get(ChronoField.MONTH_OF_YEAR) + \"\"); &#125; else if (DateToCronUtil.Q.equals(timeType)) &#123; return DEFAULT_Q_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.DAY_OF_MONTH) + \"\"); &#125; else if (DateToCronUtil.Y.equals(timeType)) &#123; return DEFAULT_Y_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.DAY_OF_MONTH) + \"\") .replace(DateToCronUtil.Y, localDateTime.get(ChronoField.MONTH_OF_YEAR) + \"\"); &#125; return DEFAULT_D_CRON; &#125; @Test public void get() &#123;// DateTimeFormatter df = DateTimeFormatter.ofPattern(DEFUALT_LONG_TIME_FORMAT);// LocalDateTime now = LocalDateTime.parse(\"2019-07-11 14:22\",df);// System.out.println(now);// System.out.println(now.get(ChronoField.MINUTE_OF_HOUR)); String d = getCron(\"2019-07-16 14:25:12\", \"W\"); System.out.println(d); &#125;&#125;","categories":[{"name":"工具类收藏","slug":"工具类收藏","permalink":"http://yoursite.com/categories/工具类收藏/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"卢国峥"},{"title":"ElasticSearch 9200端口与9300端口的区别","slug":"ElasticSearch-JAVA客户端-端口","date":"2019-07-05T16:24:00.000Z","updated":"2019-07-05T16:33:16.051Z","comments":true,"path":"2019/07/06/ElasticSearch-JAVA客户端-端口/","link":"","permalink":"http://yoursite.com/2019/07/06/ElasticSearch-JAVA客户端-端口/","excerpt":"ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.","text":"ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"http://yoursite.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"Docker 简单部署 ElasticSearch","slug":"Docker-简单部署-ElasticSearch","date":"2019-07-02T03:56:00.000Z","updated":"2019-07-05T16:37:17.086Z","comments":true,"path":"2019/07/02/Docker-简单部署-ElasticSearch/","link":"","permalink":"http://yoursite.com/2019/07/02/Docker-简单部署-ElasticSearch/","excerpt":"ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据","text":"ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据二、Docker 部署 ElasticSearch2.1 拉取镜像1docker pull docker.elastic.co/elasticsearch/elasticsearch:7.0.02.2 运行容器ElasticSearch的默认端口是9200，我们把宿主环境9200端口映射到Docker容器中的9200端口，就可以访问到Docker容器中的ElasticSearch服务了，同时我们把这个容器命名为es。1docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; &lt;容器ID&gt;2.3 配置跨域2.3.1 进入容器由于要进行配置，因此需要进入容器当中修改相应的配置信息。1docker exec -it es /bin/bash2.3.2 进行配置123456789101112131415161718192021# 显示文件ls结果如下：LICENSE.txt README.textile config lib modulesNOTICE.txt bin data logs plugins# 进入配置文件夹cd config# 显示文件ls结果如下：elasticsearch.keystore ingest-geoip log4j2.properties roles.yml users_roleselasticsearch.yml jvm.options role_mapping.yml users# 修改配置文件vi elasticsearch.yml# 加入跨域配置http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;2.3 重启容器由于修改了配置，因此需要重启ElasticSearch容器。1docker restart es展示如下：三、Docker 部署 ElasticSearch-Head为什么要安装ElasticSearch-Head呢，原因是需要有一个管理界面进行查看ElasticSearch相关信息3.1 拉取镜像1docker pull mobz/elasticsearch-head:53.2 运行容器1docker run -d --name es_admin -p 9100:9100 mobz/elasticsearch-head:5展示如下：这样，我们就完成了用Docker提供Elasticsearch服务，而不污染宿主机环境了，这样还有一个好处，如果想同时启动多个不同版本的Elastcsearch或者其他服务，Docker也是一个理想的解决方案。原文出处:https://www.cnblogs.com/jianxuanbing/p/9410800.html","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"http://yoursite.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"},{"name":"转载","slug":"转载","permalink":"http://yoursite.com/tags/转载/"}],"author":"卢国峥"},{"title":"dubbo隐式参数丢失问题","slug":"dubbo隐式参数丢失问题","date":"2019-06-29T06:18:00.000Z","updated":"2019-06-29T07:48:38.907Z","comments":true,"path":"2019/06/29/dubbo隐式参数丢失问题/","link":"","permalink":"http://yoursite.com/2019/06/29/dubbo隐式参数丢失问题/","excerpt":"记录在消费端连续调用两次远程服务导致隐式参数丢失问题~!","text":"记录在消费端连续调用两次远程服务导致隐式参数丢失问题~!演示代码controller层12345678910111213141516@Controller@RequestMapping(\"/test\")public class TestController &#123; @Reference private ICarService iCarService; @RequestMapping(\"/test\") @ResponseBody public String test()&#123; // 传递参数 RpcContext.getContext().setAttachment(\"TOKEN\",\"测试隐士参数传递\"); iCarService.test(); return \"参数\"; &#125;&#125;服务层123456789101112131415161718192021@Service(retries = -1)public class CeshiServiceImpl implements ICeshiService &#123; private static final Logger logger = LoggerFactory.getLogger(CeshiServiceImpl.class); @Reference private ICarService iCarService; @Reference private IUserInfoService iUserInfoService; @Override public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"token信息:&#123;&#125;\", token); // 第一次调用rpc服务 iCarService.test(); logger.info(\"token信息:&#123;&#125;\", RpcContext.getContext().getAttachment(\"TOKEN\")); // 第二次调用rpc服务 iUserInfoService.test(); &#125;&#125;ICarServiceImpl12345678910@Service(retries = -1)public class CarServiceImpl implements ICarService &#123; private static final Logger logger = LoggerFactory.getLogger(CarServiceImpl.class); public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"carService:&#123;&#125;\",token); &#125;&#125;userInfoServiceImpl1234567891011@Service(retries = -1)@Transactionalpublic class UserInfoServiceImpl implements IUserInfoService &#123; private static final Logger logger = LoggerFactory.getLogger(UserInfoServiceImpl.class); public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"userInfoService:&#123;&#125;\",token); &#125; &#125;打印结果ceshiService结果ICarServiceImpl结果userInfoServiceImpl结果源码12345678910111213141516171819202122@Activate(group = Constants.CONSUMER, order = -10000)public class ConsumerContextFilter implements Filter &#123; public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; RpcContext.getContext() .setInvoker(invoker) .setInvocation(invocation) .setLocalAddress(NetUtils.getLocalHost(), 0) .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation) invocation).setInvoker(invoker); &#125; try &#123; return invoker.invoke(invocation); &#125; finally &#123; // 清空隐式参数 RpcContext.getContext().clearAttachments(); &#125; &#125;&#125;消费端在执行Rpc调用之前，经过Filter处理, 会将信息写入RpcContex,而且在每次调用rpc后都会把隐式参数清空,所以在第二次调用rpc就无法拿到之前的隐式参数了拓展Filter何时进行url过滤filter（过滤器）作用于在intreceptor(拦截器)之前，不像intreceptor一样依赖于springmvc框架，只需要依赖于serverlet。","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"http://yoursite.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://yoursite.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"docker基本命令使用","slug":"docker基本命令使用","date":"2019-06-24T03:22:43.000Z","updated":"2019-06-24T04:30:29.437Z","comments":true,"path":"2019/06/24/docker基本命令使用/","link":"","permalink":"http://yoursite.com/2019/06/24/docker基本命令使用/","excerpt":"记录docker常用命令","text":"记录docker常用命令查看本地镜像列表1docker images查看运行中的容器1docker ps查看所有容器(包括未运行的)1docker ps -a删除镜像1docker rmi &lt;镜像ID&gt;run命令docker run [参数] [镜像id] | [镜像名]:[镜像标签] [命令]-i 表示容器的输入终端保持打开,不直接关闭-t 表示开启一个虚拟终端, 绑定到标准输入上-d 表示让该容器在后台运行–name 给该容器起一个容器名，如果没有此参数，则有一个默认的容器名–rm 停止该容器时，把容器删除掉使用镜像运行容器1docker run -it --name &lt;容器名称&gt; -d -p &lt;port:port&gt; &lt;镜像ID&gt;启动容器1docker start &lt;容器ID&gt;停止容器1docker stop &lt;容器ID&gt;删除容器1docker rm &lt;容器ID&gt;查看docker的所有容器运行状态1docker stats进入容器里面1docker exec -it &lt;容器ID&gt; /bin/bash查看容器运行日志(类似 tail -f 命令)1docker logs","categories":[],"tags":[],"author":"卢国峥"},{"title":"使用 JConsole 监控 springboot 项目","slug":"使用-JConsole-监控-springboot-项目","date":"2019-06-24T03:07:00.000Z","updated":"2019-06-24T03:16:22.665Z","comments":true,"path":"2019/06/24/使用-JConsole-监控-springboot-项目/","link":"","permalink":"http://yoursite.com/2019/06/24/使用-JConsole-监控-springboot-项目/","excerpt":"JConsole 使用记录~!","text":"JConsole 使用记录~!添加启动参数1234567nohup java -jar -Djava.rmi.server.hostname=x.x.x.x # 服务ip-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 # 端口(不能与服务端口冲突)-Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Xms200m -Xmx200m ylcloud-item-service-0.0.1-SNAPSHOT.jar &gt; /pro/test/home/yanfa/nohup_item.out &amp; 2&gt;&amp;1 &amp;启动JConsole直接在windows命令窗口输入JConsole选择远程进程输入对应的ip:port即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}],"author":"卢国峥"},{"title":"dubbo重试机制","slug":"Dubbo重试机制","date":"2019-06-15T06:21:00.000Z","updated":"2019-06-24T03:21:54.255Z","comments":true,"path":"2019/06/15/Dubbo重试机制/","link":"","permalink":"http://yoursite.com/2019/06/15/Dubbo重试机制/","excerpt":"DUBBO中文官方文档记录Dubbo重试机制配置~!","text":"DUBBO中文官方文档记录Dubbo重试机制配置~!DUBBO中文官方文档默认重试次数: 2在官方文档中有介绍到dubbo的重试次数默认是2属性对应URL参数类型是否必填缺省值作用描述兼容性retriesretriesint可选2性能调优远程服务调用重试次数，不包括第一次调用，不需要重试请设为02.0.0以上版本修改重试次数duboo-provider.xml配置方式: 在dubbo:service配置retries参数123&lt;!--常用菜单推荐--&gt;&lt;dubbo:service ref=\"userMenuClickFacade\" interface=\"com.ylcloud.user.facade.UserMenuClickFacade\" retries=\"1\"/&gt;&lt;bean id=\"userMenuClickFacade\" class=\"com.ylcloud.user.facade.impl.UserMenuClickFacadeImpl\"/&gt;使用注解如果使用的@Service配置重试次数,不设置retries参数,那么该参数默认值是0,但是不管显示配置retries为0,还是不显示设置,0都是使用dubbo默认的重试次数如果要配置重试次数为0,只有把retries小于0才会起作用如果使用@Reference引用服务时配置了retries,重试次数以改次数为准只有显示设置retries大于或等于1才会起作用dubbo相关代码(dubbo版本:2.6.1)package com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker;1234567891011public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123; List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers; checkInvokers(copyinvokers, invocation); // len:最多调用次数--&gt; 重试次数 + 1 int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1; // 控制至少调用一次:即重试次数为 0 if (len &lt;= 0) &#123; len = 1; &#125; /** 部分源码省略**/&#125;dubbo注册服务相关代码package com.alibaba.dubbo.config.AbstractConfig;123456789101112131415protected void appendAnnotation(Class&lt;?&gt; annotationClass, Object annotation) &#123; /** 省略部分代码 **/ // 获取直接配置的数据 Object value = method.invoke(annotation, new Object[0]); // 如果不为空并且不等于默认值,则注册url中 if (value != null &amp;&amp; !value.equals(method.getDefaultValue())) &#123; /** 省略部分代码 **/ &#125; /** 省略部分代码 **/ &#125;所以如果使用注解配置重试次数,如果配置的是默认值,则不会注册到url中,会使用dubbo默认的值","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"http://yoursite.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://yoursite.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"Nginx+ffmpeg搭建推流服务器","slug":"Nginx-ffmpeg搭建推流服务器","date":"2019-06-14T07:23:00.000Z","updated":"2019-06-14T08:19:25.829Z","comments":true,"path":"2019/06/14/Nginx-ffmpeg搭建推流服务器/","link":"","permalink":"http://yoursite.com/2019/06/14/Nginx-ffmpeg搭建推流服务器/","excerpt":"环境👇:CentOS7搭建推流服务器~!","text":"环境👇:CentOS7搭建推流服务器~!安装Nginx(忽略)略直接进入到Nginx的解压目录// 参考:这是我目录1cd /usr/local/softs/nginx-1.10.1目录下面的内容:下载nginx-rtmp-module,并解压123wget https://github.com/arut/nginx-rtmp-module/archive/master.zipunzip master.zip先备份Nginx(稳点来)1cp objs/nginx /usr/local/nginx/sbin/nginx重新配置Nginx123./configure --with-http_ssl_module --add-module=/usr/local/softs/nginx-1.10.1/nginx-rtmp-module-mastermakePS: 用make,不要使用make install,不然会覆盖已经添加的模块(网上是这么说的,但是好像没有效果,我之前装了ssl模块的,直接就给我覆盖掉了)因为我之前就加了个ssl模块,所有我直接在配置上加上了,不过之前也有备份将新的nginx覆盖旧安装目录1cp objs/nginx /usr/local/nginx/sbin/nginx修改Nginx配置文件(nginx.conf)123456789101112rtmp &#123; #RTMP服务 server &#123; listen 1935; #//服务端口 chunk_size 4096; #//数据传输块的大小 application vod &#123; play /opt/video; #//视频文件存放位置。 &#125; application live&#123; #直播 live on; &#125; &#125;&#125;PS: rtmp是一个单独的模块,不要放在http里面重启Nginx123cd /usr/local/nginx/sbin./nginx -s reload安装EPEL Release，因为安装需要使用其他的repo源，所以需要EPEL支持1yum install -y epel-release安装完成之后，可以查看是否安装成功1yum repolist安装nux-dextop 源1rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm安装ffmpeg1yum install -y ffmpeg安装完成后检查ffmpeg 版本1ffmpeg -version测试1ffmpeg -re -i lgz.mp4 -c copy -f flv rtmp://localhost:1935/live/film使用VLC1rtmp://&#123;你的服务IP&#125;:1935/live/film","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"http://yoursite.com/categories/服务器系列/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"推流服务器","slug":"推流服务器","permalink":"http://yoursite.com/tags/推流服务器/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"http://yoursite.com/tags/ffmpeg/"}],"author":"卢国峥"},{"title":"结束Windows占用端口进程","slug":"结束Windows占用端口进程","date":"2019-06-12T06:46:00.000Z","updated":"2019-06-12T06:46:40.125Z","comments":true,"path":"2019/06/12/结束Windows占用端口进程/","link":"","permalink":"http://yoursite.com/2019/06/12/结束Windows占用端口进程/","excerpt":"netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80tasklist | findstr 9268taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程","text":"netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80tasklist | findstr 9268taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://yoursite.com/tags/Windows/"}],"author":"卢国峥"},{"title":"SQL函数使用记录","slug":"QL函数使用记录","date":"2019-06-06T06:19:00.000Z","updated":"2019-06-15T06:47:12.170Z","comments":true,"path":"2019/06/06/QL函数使用记录/","link":"","permalink":"http://yoursite.com/2019/06/06/QL函数使用记录/","excerpt":"sql函数使用记录~!","text":"sql函数使用记录~!SUM函数中使用case统计t1.groupNumber大于2的数量12345678SELECT IF(SUM(case when t1.groupNumber &gt; 2 then 1 else 0 end) / COUNT(t1.groupNumber),SUM(case when t1.groupNumber &gt; 2 then 1 else 0 end) / COUNT(t1.groupNumber),0) AS fgl FROM (SELECT COUNT(visitor_code) groupNumber FROM sales_order WHERE scomp_code = 'G0000001' GROUP BY visitor_code) t1;格式化日期分组查询函数描述DATE_FORMAT(creater_time,’%Y-%m’)订货日期(日)DATE_FORMAT(creater_time,’%Y-%m-%d’)订货日期(月)1SELECT COUNT(1),DATE_FORMAT(creater_time,'%Y-%m-%d') FROM patrolshop_plan GROUP BY DATE_FORMAT(creater_time,'%Y-%m-%d')日效果:月效果:","categories":[{"name":"MySQL数据库系列","slug":"MySQL数据库系列","permalink":"http://yoursite.com/categories/MySQL数据库系列/"}],"tags":[{"name":"SQL函数","slug":"SQL函数","permalink":"http://yoursite.com/tags/SQL函数/"}],"author":"卢国峥"},{"title":"xml文件注释注意事项","slug":"xml文件注释注意事项","date":"2019-06-06T05:43:00.000Z","updated":"2019-06-06T05:50:58.307Z","comments":true,"path":"2019/06/06/xml文件注释注意事项/","link":"","permalink":"http://yoursite.com/2019/06/06/xml文件注释注意事项/","excerpt":"记录一个调试中偶然碰到的问题~!在mapper.xml文件中注释语句必须使用&lt;!-- --&gt;","text":"记录一个调试中偶然碰到的问题~!在mapper.xml文件中注释语句必须使用&lt;!-- --&gt;在一次调试中直接在mapper.xml顺手使用CTRL + /了快捷键注释:#符号然而那一行代码也是变灰了也就没留意在访问的时候直接报错了之后换成&lt;!-- --&gt;即可","categories":[{"name":"BUG系列","slug":"BUG系列","permalink":"http://yoursite.com/categories/BUG系列/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}],"author":"卢国峥"},{"title":"Sourcetree 更新git账号密码","slug":"sourectree使用","date":"2019-05-31T15:02:00.000Z","updated":"2019-05-31T15:25:27.546Z","comments":true,"path":"2019/05/31/sourectree使用/","link":"","permalink":"http://yoursite.com/2019/05/31/sourectree使用/","excerpt":"Sourcetree记录~!","text":"Sourcetree记录~!更新git密码使用sourcetree时登录git账号,git账号修改了密码后sourcetree在提交/拉取代码时只会报错,并不会弹出git登录窗口让用户重新登录.解决方法: windows进入以下目录,删除passwd文件1C:\\Users\\USERNAME\\AppData\\Local\\Atlassian\\SourceTree删除文件后,再次拉取/提交代码就会弹出git登录窗口修改git登录名称sourcetree重新登录git时无法修改用户名称解决方法: windows进入上面目录,修改userhosts文件对应的登录名称即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"http://yoursite.com/categories/工具使用/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"author":"卢国峥"},{"title":"ZK分布式锁","slug":"ZK分布式锁","date":"2019-05-17T02:13:00.000Z","updated":"2019-05-17T02:37:05.068Z","comments":true,"path":"2019/05/17/ZK分布式锁/","link":"","permalink":"http://yoursite.com/2019/05/17/ZK分布式锁/","excerpt":"只做记录","text":"只做记录介绍使用curator客户端操作zookeeper引入依赖123456789&lt;!-- 版本号 --&gt;&lt;curator.version&gt;4.0.0&lt;/curator.version&gt;&lt;!-- ZK客户端:curator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;&lt;/dependency&gt;zookeeper相关依赖1234567891011121314&lt;!-- 版本号 --&gt;&lt;zookeeper.version&gt;3.4.10&lt;/zookeeper.version&gt;&lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt;&lt;/dependency&gt;代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @author LuGuoZheng * @date 2019/5/15 13:33 * @Version 3.0 * @description */public class ZKLock &#123; /** * zk客户端 */ public static CuratorFramework client = null; public InterProcessMutex mutex = null; /** * 初始化zk客户端 */ static &#123; System.out.println(\"开始初始化zk客户端\"); // 重试策略:重试3次,每次重试间隔1s RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); client = CuratorFrameworkFactory.builder() .connectString(\"139.159.253.188:2181\")// zk地址 .sessionTimeoutMs(15000) // 会话超时时间 .connectionTimeoutMs(30000) // 连接超时时间 .retryPolicy(retryPolicy) // 重试策略 .namespace(\"YL_LGZ\") // 名称 .build(); // 启动zk客户端连接zk client.start(); &#125; /** * * @param code 节点名称 */ public void init(String code) &#123; System.out.println(\"创建节点对象\"); mutex = new InterProcessMutex(client, code); &#125; /** * 加锁:互斥锁 */ public void lock()&#123; try &#123; mutex.acquire(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"枷锁失败\"); &#125; &#125; /** * 释放锁 */ public void unLock() &#123; try &#123; mutex.release(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"释放锁失败\"); &#125; &#125;&#125;测试123456789101112131415161718192021222324/** * @author LuGuoZheng * @date 2019/5/15 15:06 * @Version 3.0 * @description */public class TestLock extends ZKLock &#123; public TestLock()&#123; super.init(\"/LGZ_TEST_CODE\"); &#125; @Test public void test() throws InterruptedException &#123; TestLock testLock = new TestLock(); try &#123; testLock.lock(); System.out.println(\"\"); Thread.sleep(5000); &#125; finally &#123; testLock.unLock(); System.out.println(\"释放成功\"); &#125; &#125;&#125;","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"},{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"}],"author":"卢国峥"},{"title":"zk命令","slug":"zk命令","date":"2019-05-15T08:02:00.000Z","updated":"2019-06-18T08:15:11.745Z","comments":true,"path":"2019/05/15/zk命令/","link":"","permalink":"http://yoursite.com/2019/05/15/zk命令/","excerpt":"zk操作命令","text":"zk操作命令启动zk1./zkServer.sh start连接客户端1[root@ecs-e339-0002 bin]# ./zkCli.shls查看命令1[zk: localhost:2181(CONNECTED) 2] ls /","categories":[{"name":"中间件","slug":"中间件","permalink":"http://yoursite.com/categories/中间件/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"}],"author":"卢国峥"},{"title":"Shell脚本","slug":"Shell脚本","date":"2019-05-13T08:40:00.000Z","updated":"2019-05-13T08:47:44.037Z","comments":true,"path":"2019/05/13/Shell脚本/","link":"","permalink":"http://yoursite.com/2019/05/13/Shell脚本/","excerpt":"收藏常用的shell脚本","text":"收藏常用的shell脚本重启java项目test.sh (结束进程)12345678910#!/bin/bashecho \"Stopping SpringBoot Application for CMP\"pid=`ps -ef | grep $1* | grep -v grep | awk '&#123;print $2&#125;'`if [ -n \"$pid\" ]then kill -9 $pidecho 'kill process'else echo \"no pid\"fitt.sh(检查项目是否启动完毕)12345678910111213141516171819#!/bin/bashecho \"start script ................\"file=$1while [ -f $file ]do echo \"find log .........\" result=`grep \"启动成功\" $file` if [[ \"$result\" != \"\" ]] then echo \"springboot start .........\" break else echo \"running .......\" sleep 1s fidoneecho \"springboot Started...........\"run.sh(主shell脚本)1234567891011121314151617181920212223#!/bin/bashsource /etc/profile#版本信息jarversion='-0.0.1-SNAPSHOT.jar'#日志路径logpath='/pro/test/home/yanfa/'runjar()&#123; sh test.sh $1 nohup java -jar $4 $1$jarversion &gt; $logpath$2 &amp; 2&gt;&amp;1 &amp; sh tt.sh $logpath$2 echo $3&#125;runjar 'ylcloud-item-service' 'nohup_item.out' '商品模块启动完成' '-Xms10m -Xmx200m'echo '项目启动成功'","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}],"author":"卢国峥"},{"title":"git命令","slug":"git命令-1","date":"2019-05-13T08:33:00.000Z","updated":"2019-05-22T05:05:22.291Z","comments":true,"path":"2019/05/13/git命令-1/","link":"","permalink":"http://yoursite.com/2019/05/13/git命令-1/","excerpt":"记录常用的git命令","text":"记录常用的git命令删除已关联的远程仓库1git remote rm origin推送到远程仓库1234git pull origin master// 强行推送git pull origin master -f","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"author":"卢国峥"},{"title":"设计模式之动态代理模式","slug":"设计模式之动态代理模式","date":"2019-05-13T07:29:00.000Z","updated":"2019-05-13T08:26:17.198Z","comments":true,"path":"2019/05/13/设计模式之动态代理模式/","link":"","permalink":"http://yoursite.com/2019/05/13/设计模式之动态代理模式/","excerpt":"动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。","text":"动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。如何动态的创建一份字节码：由于 JVM 通过字节码的二进制信息加载类的，如果我们在运行期系统中，遵循 Java 编译系统组织 .class 文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。如此，就完成了在代码中动态创建一个类的能力了。相关资料InvocationHandler 类InvocationHandler是由代理实例的调用处理程序实现的接口 。每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。1234567主要方法：public Object invoke(Object proxy, Method method, Object[] args) 方法职责：负责集中处理动态代理类上的所有方法调用 参数： proxy ：生成的代理对象 method：当前调用的真实方法对象 args ：当前调用方法的实参 返回：真实方法的返回结果Proxy 类Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。1234567主要方法：public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler hanlder) 方法职责：为指定类加载器、一组接口及调用处理器生成动态代理类实例 参数: loader ：类加载器，一般传递真实对象的类加载器 interfaces：代理类需要实现的接口 hanlder：代理对象如何做增强: 返回：创建的代理对象静态方法static ObjectnewProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) 返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。实现动态代理方式 针对有接口：使用 JDK 动态代理； 针对无接口：使用 CGLIB 或 Javassist 组件。若使用 JDK 动态代理生成代理类,真实类必须实现一个接口代码实现(JDK动态代理)代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println(\"我是真实对象,与\" + name + \"签订了\" + contract); &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println(\"开启事务\"); &#125; public void rollback()&#123; System.out.println(\"回滚事务\"); &#125; public void commit()&#123; System.out.println(\"提交事务\"); &#125;&#125;处理器123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author LuGuoZheng * @date 2019/5/11 16:45 * @Version 3.0 * @description */public class TransactionManagerHandler implements InvocationHandler &#123; // 真实对象 private Object target; // 事务对象 private MyTransactionManger tx; public void setTarget(Object target) &#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger tx) &#123; this.tx = tx; &#125; // 获取代理对象 public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; tx.begin(); try &#123; result = method.invoke(target,args); tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); tx.rollback(); &#125; return result; &#125;&#125;测试12345678910111213141516171819202122232425/** * @author LuGuoZheng * @date 2019/5/11 16:58 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; MyTransactionManger tx = new MyTransactionManger(); EmployeeService employeeService = new EmployeeServiceImpl(); TransactionManagerHandler handler = new TransactionManagerHandler(); handler.setMyTransactionManger(tx); handler.setTarget(employeeService); System.out.println(\"真实类:\" + employeeService); EmployeeService proxy = handler.getProxy(); System.out.println(\"代理类:\" + proxy); proxy.save(\"张三\",\"10年长期合同\"); &#125;&#125;结果123开启事务我是真实对象,与张三签订了10年长期合同提交事务调用流程JDK动态代理总结Java 动态代理是使用 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口这两个来完成的。要使用 JDK 动态代理，委托类必须实现接口。JDK 动态代理将会拦截所有 pubic 的方法（因为只能调用接口中定义的方法），这样即使在接口中增加了新的方法，不用修改代码也会被拦截。动态代理的最小单位是类（类中某些方法都会被处理），如果只想拦截一部分方法，可以在 invoke 方法中对要执行的方法名进行判断。对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统，也更符合面向接口编程规范。若委托类实现了接口，优先选用 JDK 动态代理。若委托类没有实现任何接口，使用 Javassit 和 CGLIB 动态代理。","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之静态代理模式","slug":"设计模式之静态代理模式","date":"2019-05-09T03:40:00.000Z","updated":"2019-05-09T05:56:43.356Z","comments":true,"path":"2019/05/09/设计模式之静态代理模式/","link":"","permalink":"http://yoursite.com/2019/05/09/设计模式之静态代理模式/","excerpt":"客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。","text":"客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。代理模式客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。1. 静态代理在程序运行前就已经存在代理类的字节码文件,代理对象和真实对象的关系在运行前就确定了.2. 代码实现代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println(\"我是真实对象,与\" + name + \"签订了\" + contract); &#125;&#125;代理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author LuGuoZheng * @date 2019/5/9 10:34 * @Version 3.0 * @description 代理对象 */public class EmployeeProxyImpl implements EmployeeService &#123; /** * 真实对象 */ private EmployeeService target; private MyTransactionManger myTransactionManger; public void setTarget(EmployeeService target)&#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger myTransactionManger)&#123; this.myTransactionManger = myTransactionManger; &#125; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; myTransactionManger.begin(); try &#123; // 真实对象只负责签订合同 target.save(name,contract); // TODO 签订合同后处理一系列其他问题 myTransactionManger.commit(); &#125; catch (Exception e) &#123; myTransactionManger.rollback(); e.printStackTrace(); &#125; &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println(\"开启事务\"); &#125; public void rollback()&#123; System.out.println(\"回滚事务\"); &#125; public void commit()&#123; System.out.println(\"提交事务\"); &#125;&#125;测试123456789101112131415161718192021/** * @author LuGuoZheng * @date 2019/5/9 11:01 * @Version 3.0 * @description 测试 * * */public class Test &#123; public static void main(String[] args) &#123; EmployeeServiceImpl employeeService = new EmployeeServiceImpl(); EmployeeProxyImpl employeeProxy = new EmployeeProxyImpl(); MyTransactionManger myTransactionManger = new MyTransactionManger(); employeeProxy.setMyTransactionManger(myTransactionManger); employeeProxy.setTarget(employeeService); employeeProxy.save(\" 张三 \",\"10长期合同~!\"); &#125;&#125;测试结果123开启事务我是真实对象,与 张三 签订了10长期合同~!提交事务3. 静态代理优缺点优点业务只需要关注业务逻辑本身,保证了业务类的重要性.把真实对象隐藏起来,保护真实对象缺点代理对象的某个接口只服务于某一种类型的对象,也就是为每个真实类创建一个代理类.若需要代理的方法很多,那么就要为每一种方法都进行代理处理.若接口增加一个方法,除了所有实现类需要实现这个方法,代理类也需要实现此方法.","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之观察者模式","slug":"设计模式之观察者模式","date":"2019-05-08T07:21:00.000Z","updated":"2019-05-08T07:51:53.819Z","comments":true,"path":"2019/05/08/设计模式之观察者模式/","link":"","permalink":"http://yoursite.com/2019/05/08/设计模式之观察者模式/","excerpt":"在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。","text":"在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。观察者模式的定义在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。MQ的发布订阅模式其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。模式涵盖的角色抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。代码实现被观察者接口12345678910111213141516171819202122232425262728/** * @author LuGuoZheng * @date 2019/5/8 13:42 * @Version 3.0 * @description 被观察者接口 */public interface Observerable &#123; /** * 注册观察者 * * @param observer 观察者 */ void registerObServer(Observer observer); /** * 移除观察 * * @param observer 观察者 */ void removeObServer(Observer observer); /** * 通知观察者 * @param message 消息 */ void notifyObServer(String message);&#125;观察者接口12345678910111213141516/** * @author LuGuoZheng * @date 2019/5/8 13:44 * @Version 3.0 * @description */public interface Observer &#123; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ void update(String message);&#125;被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author LuGuoZheng * @date 2019/5/8 13:51 * @Version 3.0 * @description 公众号 */public class WechatServer implements Observerable &#123; /** * 寄存订阅了该公众号的用户(观察者) */ private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 注册观察者 * * @param observer 观察者 */ @Override public void registerObServer(Observer observer) &#123; observerList.add(observer); System.out.println(\"[\" + ((User) observer).getName() + \"]\" + \"关注了公众号~!\"); &#125; /** * 取消观察 * * @param observer 观察者 */ @Override public void removeObServer(Observer observer) &#123; if (observer == null) &#123; return; &#125; boolean remove = observerList.remove(observer); if (remove) &#123; System.out.println(\"[\" + ((User) observer).getName() + \"]\" + \"取消了关注~! (╯‵□′)╯︵┻━┻\"); &#125; &#125; /** * 通知观察者 * * @param message 消息 */ @Override public void notifyObServer(String message) &#123; for (Observer observer : observerList) &#123; observer.update(message); &#125; &#125;&#125;观察者123456789101112131415161718192021222324/** * @author LuGuoZheng * @date 2019/5/8 13:56 * @Version 3.0 * @description 观察者 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Observer &#123; private String name; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ @Override public void update(String message) &#123; System.out.println(\"我是:\" + name + \",\" + message); &#125;&#125;测试1234567891011121314151617181920212223242526272829303132/** * @author LuGuoZheng * @date 2019/5/8 14:24 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; Observer u1 = new User(\"张三\"); Observer u2 = new User(\"李四\"); Observer u3 = new User(\"王五\"); Observerable wecahtService = new WechatServer(); // 观察(订阅)公众号 wecahtService.registerObServer(u1); wecahtService.registerObServer(u2); wecahtService.registerObServer(u3); System.out.println(\"--------------------------------\"); // 发布消息 wecahtService.notifyObServer(\"第一波福利\"); System.out.println(\"--------------------------------\"); // 取消关注 wecahtService.removeObServer(u1); System.out.println(\"--------------------------------\"); // 发布消息 wecahtService.notifyObServer(\"这是第二波福利\"); &#125;&#125;测试结果123456789101112[张三]关注了公众号~![李四]关注了公众号~![王五]关注了公众号~!--------------------------------我是:张三,第一波福利我是:李四,第一波福利我是:王五,第一波福利--------------------------------[张三]取消了关注~! (╯‵□′)╯︵┻━┻--------------------------------我是:李四,这是第二波福利我是:王五,这是第二波福利参考:JAVA设计模式之观察者模式","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"Linux相关命令","slug":"Linux相关命令","date":"2019-04-26T13:53:00.000Z","updated":"2019-06-12T07:20:15.851Z","comments":true,"path":"2019/04/26/Linux相关命令/","link":"","permalink":"http://yoursite.com/2019/04/26/Linux相关命令/","excerpt":"如题记录不常用的Linux命令","text":"如题记录不常用的Linux命令运行java项目1nohup java -jar -Xms10m -Xmx200m ylcloud-item-service-0.0.1-SNAPSHOT.jar &gt; /pro/test/home/yanfa/nohup_item.out &amp; 2&gt;&amp;1 &amp;nohup: 后台启动项目-Xms10m -Xmx200m: jvm虚拟机参数查看某端口占用的线程的pid1netstat -nlp |grep :4000查看pid占用的端口号1netstat -nap | grep 32716二. 防火墙2.1 查看所有打开的端口1firewall-cmd --zone=public --list-ports2.2 开启端口（–permanent参数为永久生效，不加则重启后失效）1firewall-cmd --zone=public --add-port=端口号/tcp --permanent2.3 更新防火墙规则：1firewall-cmd --reload查看安装目录1which git查看文件大小1du -sh *重启nginx在sbin目录下执行命令1./nginx -s reloadVI操作VI操作:用的是键盘的左边的数字键逐字符移动:行内跳转:右边的数字键0:跳转到行首(编辑模式)$(Shift+4): 跳转到行尾(编辑模式)^(Shift+6): 跳转到行首的第一个字母位置(编辑模式)行间跳转:(末行模式)gg: 跳转到文件第一行(编辑模式)G(Shift+g): 跳到文件的最后一行(编辑模式)直接输入行号就可以跳转到对应行注意:可以先把行号显示出来:set number在编辑模式下:ctrl+f 向下翻一页 forwardctrl+b 向上翻一页 backwarddd: 删除光标所在行 (编辑模式)3dd:从光标行开始删除3行(编辑模式)——1,4d 删除第一行到第四行(末行模式)u 撤销上一个操作(编辑模式)yy 复制光标所在行 (编辑模式)2yy 从光标行开始复制2行(编辑模式)p: 粘贴命令末行模式:文件的查找/parttern 从前往后查找?parttern 从后往前查找n: 下一个匹配的字符串N: 上一个匹配的字符串g:全局替换i:忽略大小写%s/f/F/gi创建文件vi 文件名touch 文件名创建目录mkdir 目录名mkdir -p 目录名1/目录名2 创建层级目录 可以是相对目录,也可以是绝对目录rm 文件名rm -f 文件名rm -fr 目录 删除目录必须使用 -r 递归删除拷贝: cp拷贝目录的话要带上参数-r移动: mv","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"http://yoursite.com/categories/服务器系列/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"卢国峥"},{"title":"设计模式之策略模式","slug":"设计模式之策略模式","date":"2019-04-26T07:45:00.000Z","updated":"2019-04-26T08:03:13.451Z","comments":true,"path":"2019/04/26/设计模式之策略模式/","link":"","permalink":"http://yoursite.com/2019/04/26/设计模式之策略模式/","excerpt":"策略模式思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。","text":"策略模式思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。1. 简介思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。2. 代码实现接口123456789101112131415/** * @author LuGuoZheng * @date 2019/4/26 14:37 * @Version 3.0 * @description */public interface Condition &#123; /** * 条件 * @param num 数据 * @return */ boolean check(int num);&#125;类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author LuGuoZheng * @date 2019/4/26 14:36 * @Version 3.0 * @description 策略模式 */public class Strategy &#123; /** * 过滤数据方法 * @param nums 数据源 * @param condition 策略 * @return */ public List&lt;Integer&gt; filteNum(List&lt;Integer&gt; nums,Condition condition)&#123; List&lt;Integer&gt; newNums = new ArrayList&lt;&gt;(); for (Integer num : nums) &#123; if (condition.check(num))&#123; newNums.add(num); &#125; &#125; return newNums; &#125; @Test public void test() &#123; List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 6, 7); // 使用匿名内部类测试 list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num % 2 == 0; &#125; &#125;); System.out.println(list); // [2, 4, 6] list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num &lt; 5; &#125; &#125;); System.out.println(list); // [2, 4] &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之模板模式","slug":"设计模式之模板模式","date":"2019-04-25T02:50:00.000Z","updated":"2019-04-26T07:57:15.268Z","comments":true,"path":"2019/04/25/设计模式之模板模式/","link":"","permalink":"http://yoursite.com/2019/04/25/设计模式之模板模式/","excerpt":"模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.","text":"模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.1. 简介模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.2. 代码实现抽象类1234567891011121314151617181920public abstract class Times &#123; private static final SimpleDateFormat fmt = new SimpleDateFormat(\"HH:mm:ss.SSS\"); abstract void doWord(); public void test(String title) &#123; title = (title == null) ? \"\" : (\"【\" + title + \"】\"); System.out.println(title); System.out.println(\"开始：\" + fmt.format(new Date())); long begin = System.currentTimeMillis(); doWord(); long end = System.currentTimeMillis(); System.out.println(\"结束：\" + fmt.format(new Date())); double delta = (end - begin) / 1000.0; System.out.println(\"耗时：\" + delta + \"秒\"); System.out.println(\"-------------------------------------\"); &#125;&#125;子类1234567891011121314151617public class MyTemplate extends Times&#123; @Override public void doWord()&#123; int sum = 0; for (int i = 0; i &lt; 1000; i++) &#123; for (int j = 0; j &lt; 1000; j++) &#123; sum += j; &#125; &#125; System.out.println(sum); &#125; public static void main(String[] args) &#123; new MyTemplate().test(\"doWord\"); &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2019-04-24T01:51:00.000Z","updated":"2019-04-24T07:42:20.429Z","comments":true,"path":"2019/04/24/设计模式之单例模式/","link":"","permalink":"http://yoursite.com/2019/04/24/设计模式之单例模式/","excerpt":"单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例","text":"单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例1. 简介单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例2. 使用场景spring框架就是单例模式的3. 代码实现3.1 懒汉式(双检查保证线程安全)12345678910111213141516171819202122232425public class Singleton &#123; private Integer id; private String namge; private Integer age; private volatile static Singleton INSTANCE; // 私有化构造器 private Singleton ()&#123;&#125; // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; if (INSTANCE == null)&#123; synchronized (Singleton.class)&#123; if (INSTANCE == null)&#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125;3.2 饥饿式123456789101112131415161718192021222324/** * * 优点: 直接在类加载时就初始化一个实例,可以避免线程安全问题 * 缺点: 由于是类加载时就初始化了一个实例,如果一直没有使用该实例,会造成内存浪费,而且没能起到懒加载效果 */public class Singleton &#123; private Integer id; private String name; private Integer age; // 私有化构造器 private Singleton()&#123;&#125; // 初始化一个实例 private static final Singleton INSTANCE = new Singleton(); // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125;3.3 枚举1234567891011121314public enum Singleton &#123; INSTANCE; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;3.4 枚举反编译(使用XJad反编译)通过反编译可以看出就是一个饥饿式单例模式,所有实现单例模式直接写一个枚举即可.123456789101112131415161718192021222324252627282930313233343536373839404142// 使用final修饰类,并继承了Enum类public final class Singleton extends Enum&#123; public static final Singleton INSTANCE; private String name; private static final Singleton $VALUES[]; public static Singleton[] values() &#123; return (Singleton[])$VALUES.clone(); &#125; public static Singleton valueOf(String name) &#123; return (Singleton)Enum.valueOf(53554F8B6A215F0F/Singleton, name); &#125; private Singleton(String s, int i) &#123; super(s, i); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; // 在静态代码块中直接创建了一个实例 static &#123; INSTANCE = new Singleton(\"INSTANCE\", 0); $VALUES = (new Singleton[] &#123; INSTANCE &#125;); &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"http://yoursite.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"四→六月份学习计划(二季度)","slug":"四——六月份学习目标","date":"2019-04-23T15:12:00.000Z","updated":"2019-07-05T08:42:20.814Z","comments":true,"path":"2019/04/23/四——六月份学习目标/","link":"","permalink":"http://yoursite.com/2019/04/23/四——六月份学习目标/","excerpt":"如题spring使用到的设计模式:简单工厂工厂方法（Factory Method）单例（Singleton）适配器（Adapter）包装器（Decorator）代理（Proxy）观察者（Observer）策略（Strategy）模板方法（Template Method）","text":"如题spring使用到的设计模式:简单工厂工厂方法（Factory Method）单例（Singleton）适配器（Adapter）包装器（Decorator）代理（Proxy）观察者（Observer）策略（Strategy）模板方法（Template Method）计划安排 四 → 五月份学习数据结构与算法课程 在LeetCode练习算法题 巩固学习一种设计模式并实现进行中计划 数据结构与算法课程 算法练习 设计模式计划进度 (代码) 算法练习 设计模式 单例模式 模板模式 策略模式 观察者模式 静态代理模式 动态代理模式","categories":[],"tags":[],"author":"卢国峥"},{"title":"算法复杂度","slug":"复杂度","date":"2019-04-19T01:37:00.000Z","updated":"2019-04-20T04:50:54.591Z","comments":true,"path":"2019/04/19/复杂度/","link":"","permalink":"http://yoursite.com/2019/04/19/复杂度/","excerpt":"时间复杂度:估算程序指令的执行次数(执行时间)空间复杂度:估算所需占用的存储空间算法网站👇:https://leetcode-cn.com/","text":"时间复杂度:估算程序指令的执行次数(执行时间)空间复杂度:估算所需占用的存储空间算法网站👇:https://leetcode-cn.com/时间复杂度 百度百科:时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 个人理解:估算程序指令的执行次数(执行时间)空间复杂度 百度百科:空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 个人理解:估算所需占用的存储空间大O表示法一般用大O表示法来描述复杂度,表示的是数据规模n对应的复杂度123456789忽略常数、系数、低阶9 &gt;&gt;&gt; O(1)2n + 3 &gt;&gt;&gt; O(n)$n^2$ + 2n + 6 &gt;&gt;&gt; O($n^2$)$4n^3$ + $3n^2$ + 22n + 100 &gt;&gt;&gt; O($n^3$)注意:大O表示法仅仅只是一种粗略的分析模型,是一种估算,能帮助我们短时间内了解一个算法的执行效率常见的复杂度对数阶细节对数阶一般省略底数1$log_2 n = log_2 9 * log_9 n$$所以log_2 n、log_9 n统称为log_n$","categories":[{"name":"数据结构与算法系列","slug":"数据结构与算法系列","permalink":"http://yoursite.com/categories/数据结构与算法系列/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"http://yoursite.com/tags/复杂度/"}],"author":"卢国峥"},{"title":"dubbo隐式参数传递","slug":"Dobbu隐式参数传递","date":"2019-04-17T03:13:00.000Z","updated":"2019-06-29T06:18:22.290Z","comments":true,"path":"2019/04/17/Dobbu隐式参数传递/","link":"","permalink":"http://yoursite.com/2019/04/17/Dobbu隐式参数传递/","excerpt":"记录一个dobbu传递隐式参数demo,调用RPC服务时用于服务消费者向服务提供者传递隐式参数,比如向服务提供者传递token信息.","text":"记录一个dobbu传递隐式参数demo,调用RPC服务时用于服务消费者向服务提供者传递隐式参数,比如向服务提供者传递token信息.上下文信息RpcContext是一个ThreadLocal的临时状态记录器，当接收到RPC请求，或发起RPC请求时，RpcContext的状态都会变化。比如A调用B，B再调用C，则B机器上，在B调用C之前，RpcContext记录的是A调用B的信息，在B调用C之后，RpcContext记录的是B调用C。服务消费者:controller层12345678910111213141516@Controller@RequestMapping(\"/test\")public class TestController &#123; @Reference private ICarService iCarService; @RequestMapping(\"/test\") @ResponseBody public String test()&#123; // 传递参数 RpcContext.getContext().setAttachment(\"TOKEN\",\"测试隐士参数传递\"); iCarService.test(); return \"参数\"; &#125;&#125;服务提供者:service层接口123public interface ICarService &#123; void test();&#125;实现类123456789@Service@Transactionalpublic class CarServiceImpl implements ICarService &#123; public void test() &#123; // 获取参数 String token = RpcContext.getContext().getAttachment(\"TOKEN\"); System.out.println(token); &#125;&#125;项目使用场景在项目中使用的是登录后,会生成一个token返回给用户,用户每次登录都要把改token带过来进行登录验证,验证通过后则去调用RPC服务,可以通过隐士参数传递把token传递到服务提供者,这样就可以获取到当前登录用户的token,然后去获取当前登录用户信息.注意如果使用setAttachments会把原来的参数清空,后再保存现在的参数.源码123456789public RpcContext setAttachments(Map&lt;String, String&gt; attachment) &#123; // 清空参数 this.attachments.clear(); if (attachment != null &amp;&amp; attachment.size() &gt; 0) &#123; this.attachments.putAll(attachment); &#125; return this;&#125;","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"http://yoursite.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"http://yoursite.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"配置maven打包方式","slug":"配置maven打包方式","date":"2019-04-15T03:33:00.000Z","updated":"2019-05-13T03:15:12.627Z","comments":true,"path":"2019/04/15/配置maven打包方式/","link":"","permalink":"http://yoursite.com/2019/04/15/配置maven打包方式/","excerpt":"使用maven-jar-plugin和maven-dependency-plugin插件打包","text":"使用maven-jar-plugin和maven-dependency-plugin插件打包使用maven-jar-plugin和maven-dependency-plugin打包的原因及好处现在项目使用的springboot框架搭建的maven项目,由于使用jenkins自动部署项目,而且并没有配置单个模块部署,导致每次部署都要10来分钟,严重浪费时间,现在使用该插件打包后不用每次都使用jenkins部署,直接本地打包好之后替换掉服务器的jar就行,而且打包完可以看到jar是很小的,上传也很快1. 配置pom文件12345678910111213141516171819202122232425262728293031323334&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- springboot启动类 --&gt; &lt;mainClass&gt;cn.lgz.shop.GoodsApp&lt;/mainClass&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;2. 打包效果打包后会把项目代码和依赖分离开来:依赖会打包到lib目录项目代码会打包成一个jar包","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"工具配置相关","slug":"java/工具配置相关","permalink":"http://yoursite.com/categories/java/工具配置相关/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}],"author":"卢国峥"},{"title":"SSL数字证书Nginx配置部署","slug":"SSL数字证书Nginx配置部署","date":"2019-04-13T08:55:00.000Z","updated":"2019-04-17T07:27:13.003Z","comments":true,"path":"2019/04/13/SSL数字证书Nginx配置部署/","link":"","permalink":"http://yoursite.com/2019/04/13/SSL数字证书Nginx配置部署/","excerpt":"记录Nginx配置SSL数字证书的步骤以及遇到一些的问题 实践成果：为本网站部署SSL证书，实现https访问👇环境以及证书👇:阿里云服务器: CentOS7SSL数字证书: Symantec DV SSL证书（免费版）","text":"记录Nginx配置SSL数字证书的步骤以及遇到一些的问题 实践成果：为本网站部署SSL证书，实现https访问👇环境以及证书👇:阿里云服务器: CentOS7SSL数字证书: Symantec DV SSL证书（免费版）一. 添加SSL模块1.0 进入nginx解压目录使用执行以下命令添加SSL模块1./configure --with-http_ssl_module如果报错./configure: error: SSL modules require the OpenSSL library.则执行123yum -y install openssl openssl-devel./configure执行make（切记不能make install会覆盖安装目录）将原来nginx备份(可选）:如果自己nginx有什么重要配置可以先备份以防丢失1cp objs/nginx /usr/local/nginx/sbin/nginx将新的nginx覆盖旧安装目录1cp objs/nginx /usr/local/nginx/sbin/nginx二. 配置SSL证书1.0 进入Nginx安装目录conf目录(PS:安装目录和解压目录不是同一个目录）1cd /usr/local/nginx/conf/创建cert目录,并把准备好的SSL数字证书放在该目录下1mkdir cert返回conf文件，编辑nginx.conf配置文件，找到以下内容12345678910111213141516 # HTTPS server #server &#123; #listen 443; #server_name localhost; #ssl_certificate cert.pem; #ssl_certificate_key cert.key; #ssl_session_timeout 5m; #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; #ssl_prefer_server_ciphers on; #location / &#123; #root html; #index index.html index.htm; #proxy_pass http://localhost:4000; #&#125;#&#125;把以上内容替换为以下内容，或者注释以上内容重新添加也可以：123456789101112131415161718# 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。 server &#123; listen 443; server_name localhost; # localhost修改为您证书绑定的域名。 ssl on; #设置为on启用SSL功能。 root html; index index.html index.htm; ssl_certificate cert/domain name.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录。 index index.html index.htm; #添加属性。 &#125; &#125;三. 配置阿里云服务器安全组规则⭐ 如果你以上步骤都没有问题，但是还是访问不了，那就要查看下是否有配置443端口的安全组，如果没有加上即可。四. 参考资料https://help.aliyun.com/document_detail/98728.htmlhttps://help.aliyun.com/video_detail/54216.html?spm=5176.2000002.0.0.19057747sUlwcdhttps://blog.csdn.net/weiyangdong/article/details/80008543","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"http://yoursite.com/categories/服务器系列/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"http://yoursite.com/tags/Nginx/"},{"name":"SSL","slug":"SSL","permalink":"http://yoursite.com/tags/SSL/"}],"author":"卢国峥"},{"title":"Excel导入导出","slug":"Excel导入导出","date":"2019-04-10T07:00:00.000Z","updated":"2019-04-17T07:27:29.091Z","comments":true,"path":"2019/04/10/Excel导入导出/","link":"","permalink":"http://yoursite.com/2019/04/10/Excel导入导出/","excerpt":"记录一个java基于jxl实现的Excel导入导出功能","text":"记录一个java基于jxl实现的Excel导入导出功能一. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jexcelapi&lt;/groupId&gt; &lt;artifactId&gt;jxl&lt;/artifactId&gt; &lt;version&gt;2.6.12&lt;/version&gt;&lt;/dependency&gt;二. 导出2.0 接口编写1234567891011121314151617181920@RequestMapping(value = \"/export\")public void test(HttpServletResponse response) throws Exception &#123; WritableWorkbook workbook = Workbook.createWorkbook(response.getOutputStream()); // 响应格式 response.setContentType(\"application/vnd.ms-excel\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + URLEncoder.encode(\"文件名称.xls\", \"UTF-8\")); // 创建一个工作簿: WritableSheet sheet1 = workbook.createSheet(\"工作簿名称\", 0); Label label1 = new Label(0, 0, \"商品id\"); sheet1.addCell(label1); Label label2 = new Label(1, 0, \"公司编号\"); sheet1.addCell(label2); //查询数据写到workbook中 workbook.write(); System.out.println(\"查询数据写到workbook中\"); //关闭资源 workbook.close();&#125;2.1 导出效果如下三. 导入3.0 读取Excel接口12345678910111213141516171819202122232425262728293031@PostMapping(value = \"/excel\")public void importExcel(MultipartFile file) &#123; Workbook workbook = null; List&lt;ItemDto&gt; items = new ArrayList&lt;&gt;(); HashMap&lt;String, ItemDto&gt; map = new HashMap&lt;&gt;(); try &#123; //获取xls文件Excel workbook = Workbook.getWorkbook(file.getInputStream()); //获取商品工作簿:可通过索引获取不同工作簿 Sheet itemSheet = workbook.getSheet(0); //获取总行数 int rows = itemSheet.getRows(); //格式化导入的日期格式 for (int i = 1; i &lt; rows; i++) &#123; Cell[] row = itemSheet.getRow(i); if (row.length == 0) &#123; continue; &#125; String itemId = itemSheet.getCell(0, i).getContents(); System.out.println(itemId); String scompCode = itemSheet.getCell(1, i).getContents(); System.out.println(scompCode); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 workbook.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Excel","slug":"Excel","permalink":"http://yoursite.com/tags/Excel/"}],"author":"卢国峥"},{"title":"Hexo之瞎折腾系列","slug":"Hexo瞎折腾系列","date":"2019-03-30T12:11:00.000Z","updated":"2019-05-13T03:13:50.531Z","comments":true,"path":"2019/03/30/Hexo瞎折腾系列/","link":"","permalink":"http://yoursite.com/2019/03/30/Hexo瞎折腾系列/","excerpt":"该文档记录Theme-AD主题个人博客部署到云服务器以及记录新增的一些小功能~！Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/Let’s Go~!","text":"该文档记录Theme-AD主题个人博客部署到云服务器以及记录新增的一些小功能~！Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/Let’s Go~!Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/一.云服务器部署Hexo参考文档：https://www.jianshu.com/p/b2e47ec9359d1.1 后台运行Hexo部署到云服务器后如果还是在hexo根目录下使用命令启动，会有个问题就是：当你断开服务器连接之后hexo服务就会停止，无法访问。那么可以用pm2启动hexo，这样hexo就在后台运行了，就算断开服务器连接也不会停止1.2 安装pm21npm install -g pm2ps：如果感兴趣也可以了解下Linux的nohup命令1.2 在hexo创建run.js文件12345678910//run.jsconst &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(`exec error: $&#123;error&#125;`) return &#125; console.log(`stdout: $&#123;stdout&#125;`); console.log(`stderr: $&#123;stderr&#125;`);&#125;)1.3 运行脚本1pm2 start run.js二.为自己的博客添加萌宠参考博客：https://blog.csdn.net/u010820857/article/details/822707362.1 安装模块1npm install --save hexo-helper-live2d2.2 选择想要的萌宠12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z162.3 选择好之后还需要安装例如我选择的是：live2d-widget-model-z161npm install live2d-widget-model-z162.4 最后一步配置Hexo的主配置文件_config.yml1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 // 这里改为自己选择的萌宠 其他参数可以根据自己喜好看着修改 display: position: right width: 150 height: 300 mobile: show: true三. hexo部署到GitHub后绑定域名(未备案域名也可以)3.1 GitHub相关配置在根目录下添加CNAME文件(名称大写),在文件中输入域名CNAME 文件:文件内容就是你的域名:在设置中配置域名:3.2 修改域名解析记录按照下面添加域名解析记录:ps:截图中记录值的ip是通过ping`自己的xxx.github.io得到四. 新增站内搜索功能原本Theme-AD主题是没有站内搜索的,本站点移植的是Ocean主题的站内搜索功能.4.1 修改header.ejs文件把原本主题的搜索框移除,在相对应位置加入搜索按钮和搜索框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;header class=\"site-header\"&gt; &lt;div class=\"site-header-brand\"&gt; &lt;% if(theme.nav_name) &#123; %&gt; &lt;span class=\"site-header-brand-title\"&gt; &lt;a href=\"&lt;%- url_for('/') %&gt;\"&gt;&lt;%- theme.nav_name %&gt;&lt;/a&gt; &lt;/span&gt; &lt;% &#125; %&gt; &lt;% if(theme.motto) &#123; %&gt; &lt;span class=\"site-header-brand-motto\"&gt; | &lt;%- theme.motto %&gt;&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=\"site-header-right\"&gt; &lt;nav class=\"site-header-navigation\"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;a href=\"&lt;%- url_for(link.path) %&gt;\" target=\"&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;\"&gt;&lt;%= link.name%&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;/nav&gt; &lt;!-- 搜索按钮 --&gt; &lt;nav class=\"navbar\"&gt; &lt;a href=\"#\" class=\"nav-item-link nav-item-search\" title=\"&lt;%= __('搜索') %&gt;\"&gt; &lt;i class=\"fe fe-search\"&gt;&lt;/i&gt; &lt;%- theme.search_text %&gt; &lt;/a&gt; &lt;/nav&gt; &lt;div class=\"site-header-btn\"&gt; &lt;% if(theme.github) &#123; %&gt; &lt;a href=\"&lt;%- theme.github %&gt;\" target=\"_blank\" id=\"site-github\"&gt; &lt;i class=\"fa fa-github-alt\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;/dev&gt;&lt;/div&gt;&lt;!-- 搜索框 --&gt;&lt;div class=\"search-form-wrap\"&gt; &lt;div class=\"local-search local-search-plugin\"&gt; &lt;input type=\"search\" id=\"local-search-input\" class=\"local-search-input\" placeholder=\"Search...\"&gt; &lt;div id=\"local-search-result\" class=\"local-search-result\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/header&gt;&lt;nav class=\"table-content\" id=\"site-nav\"&gt; &lt;div class=\"table-content-title\"&gt; &lt;span&gt;导航&lt;/span&gt; &lt;/div&gt; &lt;div class=\"table-content-main\"&gt; &lt;ol class=\"toc\"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;li class=\"toc-item\"&gt; &lt;a href=\"&lt;%- url_for(link.path) %&gt;\" target=\"&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;\"&gt; &lt;%= link.name %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div id=\"site-process\"&gt;&lt;/div&gt;4.2 把Ocean主题中source中css的feathericon移到自己主题的css目录下4.3 在css目录下创建_feathericon.styl文件12345678910111213141516171819202122232425262728293031323334353637@charset \"utf-8\"//---------------------------------------------------------------------------// feathericon//---------------------------------------------------------------------------//// variablesfeathericon-font-path = 'feathericon/' !default;//// font path@font-face font-family feathericon font-weight normal font-style normal src: url(feathericon-font-path + 'feathericon.eot') src: url(feathericon-font-path + 'feathericon.eot?#iefix') format('embedded-opentype'), url(feathericon-font-path + 'feathericon.woff') format('woff'), url(feathericon-font-path + 'feathericon.ttf') format('truetype'), url(feathericon-font-path + 'feathericon.svg') format('svg');//// feathericon//.fe display inline-block font normal normal normal 16px feathericon font-size inherit text-rendering auto -webkit-font-smoothing antialiased -moz-osx-font-smoothing grayscale.fe-search:before &#123; content: \"\\f14e\"; &#125;.fe-search-minus:before &#123; content: \"\\f16a\"; &#125;.fe-search-plus:before &#123; content: \"\\f16b\"; &#125;4.4 在css目录下创建_mixins.styl文件123456border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n// Media queries4.5 在css目录下创建_variables.styl文件123456789101112131415161718192021// Configsupport-for-ie = falsevendor-prefixes = webkit moz ms official// Fontsfont-size-browser = 62.5%font-size-base = 1.4remfont-family-base = \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"微软雅黑\", Arial, sans-seriffont-line-height = 1.7// Colorssea = #1e3e3ffroth-light = #f4f4f4white = #ffffffsand-light = #9c8079sand = #9e6a4d// Borderborder-radius = 0.4remborder-width = 0.1remborder-color = froth4.6 在css目录下创建style.styl文件123456789101112131415161718192021222324252627@import &quot;_variables&quot;@import &quot;_feathericon&quot;//@import &quot;_normalize&quot;@import &quot;_mixins&quot;@import &quot;search&quot;*,*::before*::after box-sizing border-boxhtml font-size font-size-browserbody background-color body-background font-family font-family-base font-size font-size-base line-height font-line-height color body-color padding 0 margin 0 overflow-x hidden text-size-adjust: 100% ::selection background sea-lighter color froth4.7 修改header.js文件(替换掉所有内容)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162(function ($) &#123; // Search ------------ var $searchWrap = $('.search-form-wrap'), isSearchAnim = false, searchAnimDuration = 200; var startSearchAnim = function () &#123; isSearchAnim = true; &#125;; var stopSearchAnim = function (callback) &#123; setTimeout(function () &#123; isSearchAnim = false; callback &amp;&amp; callback(); &#125;, searchAnimDuration); &#125;; $('.nav-item-search').on('click', function () &#123; if (isSearchAnim) return; startSearchAnim(); $searchWrap.addClass('on'); stopSearchAnim(function () &#123; $('.local-search-input').focus(); &#125;); &#125;); $(document).mouseup(function (e) &#123; var _con = $('.local-search'); if (!_con.is(e.target) &amp;&amp; _con.has(e.target).length === 0) &#123; $searchWrap.removeClass('on'); &#125; &#125;); // 移动设备侦测 var isMobile = &#123; Android: function () &#123; return navigator.userAgent.match(/Android/i); &#125;, BlackBerry: function () &#123; return navigator.userAgent.match(/BlackBerry/i); &#125;, iOS: function () &#123; return navigator.userAgent.match(/iPhone|iPad|iPod/i); &#125;, Opera: function () &#123; return navigator.userAgent.match(/Opera Mini/i); &#125;, Windows: function () &#123; return navigator.userAgent.match(/IEMobile/i); &#125;, any: function () &#123; return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); &#125; &#125;; // 建议在移动端不初始化，其实 /search.xml 文件还挺大的， if ($('.local-search').size() &amp;&amp; !isMobile.any()) &#123; $.getScript('/js/search.js', function () &#123; searchFunc(\"/search.xml\", 'local-search-input', 'local-search-result'); &#125;); &#125; // Share ------------ $('body').on('click', function () &#123; $('.article-share-box.on').removeClass('on'); &#125;).on('click', '.article-share-link', function (e) &#123; e.stopPropagation(); var $this = $(this), url = $this.attr('data-url'), encodedUrl = encodeURIComponent(url), id = 'article-share-box-' + $this.attr('data-id'), offset = $this.offset(); if ($('#' + id).length) &#123; var box = $('#' + id); if (box.hasClass('on')) &#123; box.removeClass('on'); return; &#125; &#125; else &#123; var html = [ '&lt;div id=\"' + id + '\" class=\"article-share-box\"&gt;', '&lt;input class=\"article-share-input\" value=\"' + url + '\"&gt;', '&lt;div class=\"article-share-links\"&gt;', '&lt;a href=\"https://twitter.com/intent/tweet?url=' + encodedUrl + '\" class=\"article-share-twitter\" target=\"_blank\" title=\"Twitter\"&gt;&lt;/a&gt;', '&lt;a href=\"https://www.facebook.com/sharer.php?u=' + encodedUrl + '\" class=\"article-share-facebook\" target=\"_blank\" title=\"Facebook\"&gt;&lt;/a&gt;', '&lt;a href=\"http://pinterest.com/pin/create/button/?url=' + encodedUrl + '\" class=\"article-share-pinterest\" target=\"_blank\" title=\"Pinterest\"&gt;&lt;/a&gt;', '&lt;a href=\"https://plus.google.com/share?url=' + encodedUrl + '\" class=\"article-share-google\" target=\"_blank\" title=\"Google+\"&gt;&lt;/a&gt;', '&lt;/div&gt;', '&lt;/div&gt;' ].join(''); var box = $(html); $('body').append(box); &#125; $('.article-share-box.on').hide(); box.css(&#123; top: offset.top + 25, left: offset.left &#125;).addClass('on'); &#125;).on('click', '.article-share-box', function (e) &#123; e.stopPropagation(); &#125;).on('click', '.article-share-box-input', function () &#123; $(this).select(); &#125;).on('click', '.article-share-box-link', function (e) &#123; e.preventDefault(); e.stopPropagation(); window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450'); &#125;); // fancybox if ($.fancybox) &#123; $('[data-fancybox]').fancybox(&#123; protect: true &#125;); &#125; // lazyload //$(\".lazy\").lazyload(); // $(document).ready(function ($) &#123; $(\".anchor\").click(function (event) &#123; event.preventDefault(); $('html,body').animate(&#123;scrollTop: $(this.hash).offset().top&#125;, 500); &#125;); &#125;); // Mobile nav var $content = $('.content'), $sidebar = $('.sidebar'), isMobileNavAnim = false, mobileNavAnimDuration = 200; var startMobileNavAnim = function () &#123; isMobileNavAnim = true; &#125;; var stopMobileNavAnim = function () &#123; setTimeout(function () &#123; isMobileNavAnim = false; &#125;, mobileNavAnimDuration); &#125;; $('.navbar-toggle').on('click', function () &#123; if (isMobileNavAnim) return; startMobileNavAnim(); $content.toggleClass('on'); $sidebar.toggleClass('on'); stopMobileNavAnim(); &#125;); $($content).on('click', function () &#123; if (isMobileNavAnim || !$content.hasClass('on')) return; $content.removeClass('on'); $sidebar.removeClass('on'); &#125;);&#125;)(jQuery);4.8 引入jquery-2.0.3.min.js4.9 创建search.js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)// Copyright (C) 2015 // Joseph Pan &lt;http://github.com/wzpan&gt;// Shuhao Mao &lt;http://github.com/maoshuhao&gt;// This library is free software; you can redistribute it and/or modify// it under the terms of the GNU Lesser General Public License as// published by the Free Software Foundation; either version 2.1 of the// License, or (at your option) any later version.// // This library is distributed in the hope that it will be useful, but// WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU// Lesser General Public License for more details.// // You should have received a copy of the GNU Lesser General Public// License along with this library; if not, write to the Free Software// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA// 02110-1301 USA// var searchFunc = function (path, search_id, content_id) &#123; 'use strict'; var BTN = \"&lt;button type='button' class='local-search-close' id='local-search-close'&gt;&lt;/button&gt;\"; $.ajax(&#123; url: path, dataType: \"xml\", success: function (xmlResponse) &#123; // get the contents from search data var datas = $(\"entry\", xmlResponse).map(function () &#123; return &#123; title: $(\"title\", this).text(), content: $(\"content\", this).text(), url: $(\"url\", this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function () &#123; var str = '&lt;ul class=\"search-result-list\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\\s]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function (data) &#123; var isMatch = true; // var content_index = []; if (!data.title || data.title.trim() === '') &#123; data.title = \"Untitled\"; &#125; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, \"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') &#123; keywords.forEach(function (keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) &#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; // content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;); &#125; &#125;); &#125; else &#123; isMatch = false; &#125; // show search results if (isMatch) &#123; str += \"&lt;li&gt;&lt;a href='\" + data_url + \"' class='search-result-title'&gt;\" + data_title + \"&lt;/a&gt;\"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, \"\"); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 100; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"&lt;em class=\\\"search-keyword\\\"&gt;\" + keyword + \"&lt;/em&gt;\"); &#125;); str += \"&lt;p class=\\\"search-result\\\"&gt;\" + match_content + \"...&lt;/p&gt;\" &#125; str += \"&lt;/li&gt;\"; &#125; &#125;); str += \"&lt;/ul&gt;\"; if (str.indexOf('&lt;li&gt;') === -1) &#123; return $resultContent.innerHTML = BTN + \"&lt;div class=\\\"search-result-empty\\\"&gt;&lt;p&gt;&lt;i class=\\\"fe fe-tired\\\"&gt;&lt;/i&gt; 没有找到内容，更换下搜索词试试吧~&lt;p&gt;&lt;/div&gt;\"; &#125; $resultContent.innerHTML = BTN + str; &#125;); &#125; &#125;); $(document).on('click', '#local-search-close', function () &#123; $('#local-search-input').val(''); $('#local-search-result').html(''); &#125;);&#125;;4.10 最后修改head.ejs文件,引入js和css五. 添加置顶功能5.1 在hexo目录下执行以下命令123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save5.2 在index.ejs加入以下代码1234&lt;% if(psg.top === true) &#123;%&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; |&lt;% &#125; %&gt;5.3 在需要置顶的博文中添加12top: true---六. 使用hexo-neat压缩页面6.1 安装hexo-neat插件1npm install hexo-neat --save6.2 在站点_config.yml配置文件中添加配置12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css: 这里只是压缩页面的css,如果是在source目录下的css要在exclude移除掉,否则压缩后会直接变成一个空文件 neat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩js:(同css说明)neat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos;","categories":[{"name":"Hexo之瞎折腾系列","slug":"Hexo之瞎折腾系列","permalink":"http://yoursite.com/categories/Hexo之瞎折腾系列/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"}],"author":"卢国峥"},{"title":"docker-安装(CentOS7)","slug":"Untitled","date":"2019-03-27T09:24:00.000Z","updated":"2019-05-17T07:19:45.341Z","comments":true,"path":"2019/03/27/Untitled/","link":"","permalink":"http://yoursite.com/2019/03/27/Untitled/","excerpt":"CentOS7docker安装步骤","text":"CentOS7docker安装步骤1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker //有则删除对应的包yum remove docker ......1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker //有则删除对应的包yum remove docker ......2.设置yum源(阿里源)1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo3.查看yum库中有没有docker-ce1yum list | grep docker-ce4.安装docker1yum install -y docker-ce5.如果需要设置开机自动启动12345//先启动docker服务端systemctl start docker//启动docker服务开机自启systemctl enable docker6.校验docker是否启动成功1docker version常见问题: 普通用户运行docker 命令会报错:由于docker daemon需要绑定到主机的 Unix socket 而不是普通的TCP端口,而 Unix socket 的宿主为 root 用户,如果其他用户使用 docker 命令只有在命令钱添加 sudo 才能执行成功,如果不想每次使用 docker 命令是还要多敲 sudo ,可以按照下面的方法解决:s1.切换到 root 用户2.把普通用户添加到 docker 组3.再切换到&lt;普通用户&gt;4.验证 docker 命令是否成功","categories":[{"name":"docker容器系列","slug":"docker容器系列","permalink":"http://yoursite.com/categories/docker容器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}],"author":"卢国峥"}]}