{"meta":{"title":"salmon","subtitle":"哈哈哈","description":null,"author":"卢国峥","url":"https://www.lgzblog.com","root":"/"},"pages":[{"title":"404","date":"2019-11-13T08:57:17.000Z","updated":"2019-11-13T08:57:17.000Z","comments":true,"path":"404/index.html","permalink":"https://www.lgzblog.com/404/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-28T07:41:43.000Z","updated":"2019-03-29T03:52:49.000Z","comments":true,"path":"categories/index.html","permalink":"https://www.lgzblog.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2020-07-30T02:29:29.000Z","updated":"2020-07-30T02:29:56.185Z","comments":true,"path":"search/index.html","permalink":"https://www.lgzblog.com/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-04-17T07:07:08.408Z","updated":"2019-03-25T07:52:46.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.lgzblog.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Elasticsearch解决只能查询10000条数据方案","slug":"Elasticsearch解决只能查询10000条数据方案","date":"2021-03-03T03:24:00.000Z","updated":"2021-03-03T05:38:36.079Z","comments":true,"path":"2021/03/03/Elasticsearch解决只能查询10000条数据方案/","link":"","permalink":"https://www.lgzblog.com/2021/03/03/Elasticsearch解决只能查询10000条数据方案/","excerpt":"es官方默认限制索引查询最多只能查询10000条数据，查询第10001条数据开始就会报错：Result window is too large, from + size must be less than or equal to但是很多时候10000数据不能满足项目的需求，所以我们就要解除这个限制。","text":"es官方默认限制索引查询最多只能查询10000条数据，查询第10001条数据开始就会报错：Result window is too large, from + size must be less than or equal to但是很多时候10000数据不能满足项目的需求，所以我们就要解除这个限制。es官方默认限制索引查询最多只能查询10000条数据，查询第10001条数据开始就会报错：Result window is too large, from + size must be less than or equal to但是很多时候10000数据不能满足项目的需求，所以我们就要解除这个限制。解决方案：第一种办法.在kibana中执行,解除索引最大查询数的限制1234put _all/_settings &#123; &quot;index.max_result_window&quot;:200000 &#125;_all表示所有索引，针对单个索引的话修改成索引名称即可第二种办法:在创建索引的时候加上123456“settings”:&#123; &quot;index&quot;:&#123; &quot;max_result_window&quot;: 500000 &#125; &#125;但是修改完之后，通过api查询回来的totalhits还是只有10000条，解决如下 :在查询时候把 track_total_hits 设置为 true。track_total_hits 设置为false禁用跟踪匹配查询的总点击次数设置为true就会返回真实的命中条数。java代码在构建条件时候加上:1searchSourceBuilder.trackTotalHits(true);kibana查询1234567GET 索引名/_search &#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;, &quot;track_total_hits&quot;:true &#125;原文链接：https://blog.csdn.net/weixin_39641746/article/details/102514501","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch ","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"maven常用参数及说明","slug":"maven常用参数及说明","date":"2020-11-16T01:57:28.000Z","updated":"2020-11-16T02:19:53.412Z","comments":true,"path":"2020/11/16/maven常用参数及说明/","link":"","permalink":"https://www.lgzblog.com/2020/11/16/maven常用参数及说明/","excerpt":"Maven常用参数及其说明paramdesc示例-D定义一个Properties属性-DpropertyName=propertyValue-P指定Profiles 配置文件的属性-Penv=test-U强制刷新本地仓库不存在release版和所有的snapshots版本。-U","text":"Maven常用参数及其说明paramdesc示例-D定义一个Properties属性-DpropertyName=propertyValue-P指定Profiles 配置文件的属性-Penv=test-U强制刷新本地仓库不存在release版和所有的snapshots版本。-UMaven常用参数及其说明paramdesc示例-D定义一个Properties属性-DpropertyName=propertyValue-P指定Profiles 配置文件的属性-Penv=test-U强制刷新本地仓库不存在release版和所有的snapshots版本。-U关于 -U对于release版本, 本地已经存在, 则不会重复下载对于snapshots版本, 不管本地是否存在, 都会强制刷新, 通过下载几个比较小的文件, 确定本地和远程仓库的版本是否一致, 再决定是否下载.","categories":[],"tags":[],"author":"卢国峥"},{"title":"使用MavenHelper解决jar包冲突问题","slug":"使用MavenHelper解决jar包冲突问题","date":"2020-08-01T02:59:00.000Z","updated":"2020-08-01T06:10:59.609Z","comments":true,"path":"2020/08/01/使用MavenHelper解决jar包冲突问题/","link":"","permalink":"https://www.lgzblog.com/2020/08/01/使用MavenHelper解决jar包冲突问题/","excerpt":"前言大家在项目中肯定有碰到过Maven的Jar包冲突问题，经常出现的场景为：本地运行报NoSuchMethodError，ClassNotFoundException。明明在依赖里有这个Jar包啊。怎么运行不了！？项目中明明定义着某个jar包版本为2.0.2，怎么打包之后变成2.5.0了！？A项目引xxx.jar包运行好好的，B项目同样引入xxx.jar后，运行报错了。。是B项目有问题，还是xxx.jar包有问题！？本地环境和测试环境运行的好好的，到了生产就报一堆NoSuchMethodError，是我人品有问题还是生产环境有问题！？这样的问题如果不熟悉maven依赖机制的同学排查起来，估计挺头痛的。而且maven依赖结构不好的项目，在引入新的Jar包时的风险也是巨大的。小则影响性能，大则引起生产发布和运行时异常。其实以上问题的根源都来自于Maven的Jar包冲突和使用不当的依赖传递。这篇文章我就好好分析下以下3个内容：依赖传递的原则和产生Jar包冲突的原理分析定位冲突以及解决Jar包冲突的几个简单技巧如何写一个干净依赖关系的POM文件","text":"前言大家在项目中肯定有碰到过Maven的Jar包冲突问题，经常出现的场景为：本地运行报NoSuchMethodError，ClassNotFoundException。明明在依赖里有这个Jar包啊。怎么运行不了！？项目中明明定义着某个jar包版本为2.0.2，怎么打包之后变成2.5.0了！？A项目引xxx.jar包运行好好的，B项目同样引入xxx.jar后，运行报错了。。是B项目有问题，还是xxx.jar包有问题！？本地环境和测试环境运行的好好的，到了生产就报一堆NoSuchMethodError，是我人品有问题还是生产环境有问题！？这样的问题如果不熟悉maven依赖机制的同学排查起来，估计挺头痛的。而且maven依赖结构不好的项目，在引入新的Jar包时的风险也是巨大的。小则影响性能，大则引起生产发布和运行时异常。其实以上问题的根源都来自于Maven的Jar包冲突和使用不当的依赖传递。这篇文章我就好好分析下以下3个内容：依赖传递的原则和产生Jar包冲突的原理分析定位冲突以及解决Jar包冲突的几个简单技巧如何写一个干净依赖关系的POM文件原文地址: https://www.cnblogs.com/bryan31/p/13408479.html前言大家在项目中肯定有碰到过Maven的Jar包冲突问题，经常出现的场景为：本地运行报NoSuchMethodError，ClassNotFoundException。明明在依赖里有这个Jar包啊。怎么运行不了！？项目中明明定义着某个jar包版本为2.0.2，怎么打包之后变成2.5.0了！？A项目引xxx.jar包运行好好的，B项目同样引入xxx.jar后，运行报错了。。是B项目有问题，还是xxx.jar包有问题！？本地环境和测试环境运行的好好的，到了生产就报一堆NoSuchMethodError，是我人品有问题还是生产环境有问题！？这样的问题如果不熟悉maven依赖机制的同学排查起来，估计挺头痛的。而且maven依赖结构不好的项目，在引入新的Jar包时的风险也是巨大的。小则影响性能，大则引起生产发布和运行时异常。其实以上问题的根源都来自于Maven的Jar包冲突和使用不当的依赖传递。这篇文章我就好好分析下以下3个内容：依赖传递的原则和产生Jar包冲突的原理分析定位冲突以及解决Jar包冲突的几个简单技巧如何写一个干净依赖关系的POM文件依赖传递原则几乎所有的Jar包冲突都和依赖传递原则有关，所以我们先说Maven中的依赖传递原则：最短路径优先原则假如引入了2个Jar包A和B，都传递依赖了Z这个Jar包：A -&gt; X -&gt; Y -&gt; Z(2.5)B -&gt; X -&gt; Z(2.0)那其实最终生效的是Z(2.0)这个版本。因为他的路径更加短。如果我本地引用了Z(3.0)的包，那生效的就是3.0的版本。一样的道理。最先声明优先原则如果路径长短一样，优先选最先声明的那个。A -&gt; Z(3.0)B -&gt; Z(2.5)这里A最先声明，所以传递过来的Z选择用3.0版本的。Jar包冲突的原理假设我们项目中依赖了A和B两个Jar包。而A和B各自又有以下传递依赖A -&gt; X -&gt; Z(2.0)B -&gt; X -&gt; Y -&gt; Z(2.5)那最终系统中Z包就产生了冲突，2.0和2.5两个版本冲突。但是classpath中只会依赖一个版本的Z包。根据传递依赖的最短路径优先原则，最终依赖的应该是2.0版本。如果Y包中用了Z包2.5版本中新的method时候，当运行到这段逻辑的时候。就会报NoSuchMethodError了。因为本来依赖的是2.5版本，但是因为Jar包冲突Maven选择了2.0版本，2.0版本中又没有这个新的method，导致出错。但要注意的是，不是所有冲突都会引起运行异常。相反，大部分公司的项目都会有一些Jar包冲突，但其实没有造成运行时的问题。这是因为很多传递依赖的Jar包，不管是2.0版本也好，2.5版本也好，都可以运行。只有高版本Jar包不向下兼容，或者新增了某些低版本没有的API才有可能导致这样的问题定位冲突IDEA提供了一个maven依赖分析神器：Maven Helper用这个插件能很好的显示出项目中所有的依赖树和冲突这里面红色高亮的部分，就表明这个Jar包有了冲突。选中这个jar包，可以看到这2个版本的冲突的来源。上图的例子，表明cruator-client这个Jar包，有2个传递依赖，分别为2.5.0版本和4.0.1版本。冲突的描述为：omitted for conflict with 2.5.0. 由于与2.5.0版本冲突而被省略具体的层级在右边也一目了然了，所以maven最终根据最短路径优先原则选择了2.5.0版本，4.0.1版本被忽略。这时候有同学会问：本地环境我可以利用Maven Helper来定位，那么预生产或者生产环境呢。又没有IDEA，如何定位冲突的细节？ 可以利用mvn命令来解决：1mvn dependency:tree -Dverbose此处一定不要省略-Dverbose参数，要不然是不会显示被忽略的包的其实mvn命令行一样好用。非常清晰明确。解决Jar包冲突的几个实用技巧 排除法还是上面的那个例子，现在生效的是2.5.0，如果想生效4.0.1。只需要在2.5.0上面点exclude就行了。 版本锁定法如果很多个依赖都传递了Jar包A，涉及了很多个版本，但是你只想指定一个版本。用排除法一个个去exclude太麻烦，而且exclude在pom文件中也会体现，太多的话，也影响代码整洁和阅读感受。这时候需要用到版本锁定法何谓版本锁定法？公司的项目一般都会有父级pom，你想指定哪个版本只需要在你项目的父POM中(当然在本工程内也可以)定义如下：（还是举上个例子，指定4.0.1版本）1234567&lt;dependencyManagement&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-client&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencyManagement&gt;锁定版本法可以打破2个依赖传递的原则，优先级为最高锁定版本后，依赖树为：都统一变成4.0.1，锁定版本有一个好处：版本锁定并不排除Jar包，而且显示的把所有版本不一致的Jar包变成统一一个版本，这样在阅读代码时比较友好。也不用忍受一大堆的exclude标签。如何写一个干净依赖关系的POM文件我本人是有些轻度代码洁癖的人，所以即便是pom文件的依赖关系也想干净而整洁。如何写好干净的POM呢，作者认为有几点技巧要注意：尽量在父POM中定义&lt;dependencyManagement&gt;，来进行本项目一些依赖版本的管理，这样可以从很大程度上解决一定的冲突,如果是提供给别人依赖的Jar包，尽可能不要传递依赖不必要的Jar包使用mvn dependency:analyze-only命令用于检测那些声明了但是没被使用的依赖，如有有一些是你自己声明的，那尽量去掉使用mvn dependency:analyze-duplicate命令用来分析重复定义的依赖，清理那些重复定义的依赖最后其实庞大的项目依赖传递也一定多。但是不管多复杂的依赖关系，看到不要害怕。就这么几条原则，细心的去分析，所有的依赖都有迹可循。这些传递依赖如果管理的好，能让你的维护成本大大降低。如果管不好，这群野孩子每一个都可能是引发下一个NoSuchMethodError的导火索。","categories":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"转载","slug":"转载","permalink":"https://www.lgzblog.com/tags/转载/"},{"name":"maven","slug":"maven","permalink":"https://www.lgzblog.com/tags/maven/"}],"author":"卢国峥"},{"title":"位状态工具类","slug":"位状态工具类","date":"2020-06-18T12:48:00.000Z","updated":"2020-06-19T02:38:57.903Z","comments":true,"path":"2020/06/18/位状态工具类/","link":"","permalink":"https://www.lgzblog.com/2020/06/18/位状态工具类/","excerpt":"工具记录~!采用二进制记录某条信息多个状态每一位记录一种状态: 0.不存在,1.存在状态","text":"工具记录~!采用二进制记录某条信息多个状态每一位记录一种状态: 0.不存在,1.存在状态工具记录~!1.位运算细节采用二进制记录某条信息多个状态每一位记录一种状态: 0.不存在,1.存在状态2.工具类实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * @Author 此间 * @Date 2020/6/18 16:48 * @Description 证件审核状态类，记录工作室在平台证件审核中所有的状态。 */public class BitStatesUtils &#123; public final static Long OP_BIND_PHONE = 1L &lt;&lt; 0; // 用户绑定手机状态码 1 public final static Long OP_BIND_EMAIL = 1L &lt;&lt; 1; // 用户绑定邮箱状态码 2 public final static Long OP_BASIC_INFO = 1L &lt;&lt; 2; // 用户填写基本资料 4 public final static Long OP_REAL_AUTH = 1L &lt;&lt; 3; // 用户完成实名认证 8 public final static Long OP_VEDIO_AUTH = 1L &lt;&lt; 4; // 用户完成视频认证 16 = 1 * 2 * 2 * 2 * 2 public final static Long HAS_BIDREQUEST_IN_PROCESS = 1L &lt;&lt; 5;// 用户有一个借款在申请流程当中 32 /** * @param states * 所有状态值 * @param value * 需要判断状态值 * @return 是否存在 */ public static boolean hasState(long states, long value) &#123; return (states &amp; value) != 0; &#125; /** * @param states * 已有状态值 * @param value * 需要添加状态值 * @return 新的状态值 */ public static long addState(long states, long value) &#123; if (hasState(states, value)) &#123; return states; &#125; return (states | value); &#125; /** * @param states * 已有状态值 * @param value * 需要删除状态值 * @return 新的状态值 */ public static long removeState(long states, long value) &#123; if (!hasState(states, value)) &#123; return states; &#125; return states ^ value; &#125; public static void main(String[] a)&#123; System.out.println(removeState(63,32)); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"}],"author":"卢国峥"},{"title":"代码提交规范","slug":"代码提交规范","date":"2020-06-09T11:47:00.000Z","updated":"2020-08-01T07:07:44.624Z","comments":true,"path":"2020/06/09/代码提交规范/","link":"","permalink":"https://www.lgzblog.com/2020/06/09/代码提交规范/","excerpt":"工作记录~!codeinfofeat: msg新功能featurefix: msg修复bugmerge: msgmergedocs: msg文档修改style: msg格式，不影响代码运行的变动refactor: msg重构即不是新增功能，也不是修改bug的代码变动test: msg增加测试chore: msg构建过程或辅助工具的变动rm: msg删除文件或代码pod: msgpod install / pod update podName","text":"工作记录~!codeinfofeat: msg新功能featurefix: msg修复bugmerge: msgmergedocs: msg文档修改style: msg格式，不影响代码运行的变动refactor: msg重构即不是新增功能，也不是修改bug的代码变动test: msg增加测试chore: msg构建过程或辅助工具的变动rm: msg删除文件或代码pod: msgpod install / pod update podName工作记录~!代码提交规范codeinfofeat: msg新功能featurefix: msg修复bugmerge: msgmergedocs: msg文档修改style: msg格式，不影响代码运行的变动refactor: msg重构即不是新增功能，也不是修改bug的代码变动test: msg增加测试chore: msg构建过程或辅助工具的变动rm: msg删除文件或代码pod: msgpod install / pod update podName","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lgzblog.com/tags/git/"},{"name":"sourcetree","slug":"sourcetree","permalink":"https://www.lgzblog.com/tags/sourcetree/"}],"author":"卢国峥"},{"title":"git修改远程仓库的commit注释信息","slug":"git如何修改push到远程仓库的commit注释信息","date":"2020-06-03T06:53:00.000Z","updated":"2020-06-03T07:10:12.396Z","comments":true,"path":"2020/06/03/git如何修改push到远程仓库的commit注释信息/","link":"","permalink":"https://www.lgzblog.com/2020/06/03/git如何修改push到远程仓库的commit注释信息/","excerpt":"1.修改最后一次的commit注释，输入指令：git rebase -i HEAD~1 ，点击回车键；2.然后将当前条的pick（左上角）修改为edit,保存.3.输入指令：git commit --amend4.顶部信息就是你要修改的commit注释5.输入指令：git rebase --continue6.强制提交到远程仓库：git push -f","text":"1.修改最后一次的commit注释，输入指令：git rebase -i HEAD~1 ，点击回车键；2.然后将当前条的pick（左上角）修改为edit,保存.3.输入指令：git commit --amend4.顶部信息就是你要修改的commit注释5.输入指令：git rebase --continue6.强制提交到远程仓库：git push -f1.修改最后一次的commit注释，输入指令：1git rebase -i HEAD~12.然后将当前条的pick（左上角）修改为edit，保存.3.输入指令：1git commit --amend4.顶部信息就是你要修改的commit注释5.输入指令：1git rebase --continue6.强制提交到远程仓库：1git push -f","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lgzblog.com/tags/git/"}],"author":"卢国峥"},{"title":"全局的日期转换类: string转date","slug":"全局的日期转换类-string-》date","date":"2020-05-09T07:44:00.000Z","updated":"2020-05-22T10:17:11.040Z","comments":true,"path":"2020/05/09/全局的日期转换类-string-》date/","link":"","permalink":"https://www.lgzblog.com/2020/05/09/全局的日期转换类-string-》date/","excerpt":"记录~!1234567891011121314151617181920212223/** * 全局的日期转换类 string-》date */@Componentpublic class DateConvert implements Converter&lt;String, Date&gt; &#123; private String[] pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;&#125;; @Override public Date convert(String s) &#123; if (StringUtils.isNullOrEmpty(s)) &#123; return null; &#125; try &#123; if (s.contains(&quot;:&quot;)) &#123; return new SimpleDateFormat(pattern[0]).parse(s); &#125; else &#123; return new SimpleDateFormat(pattern[1]).parse(s); &#125; &#125; catch (Exception e) &#123; throw new SOAException(&quot;日期格式不正确，无法转换&quot; + s); &#125; &#125;&#125;","text":"记录~!1234567891011121314151617181920212223/** * 全局的日期转换类 string-》date */@Componentpublic class DateConvert implements Converter&lt;String, Date&gt; &#123; private String[] pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;&#125;; @Override public Date convert(String s) &#123; if (StringUtils.isNullOrEmpty(s)) &#123; return null; &#125; try &#123; if (s.contains(&quot;:&quot;)) &#123; return new SimpleDateFormat(pattern[0]).parse(s); &#125; else &#123; return new SimpleDateFormat(pattern[1]).parse(s); &#125; &#125; catch (Exception e) &#123; throw new SOAException(&quot;日期格式不正确，无法转换&quot; + s); &#125; &#125;&#125;记录~!1234567891011121314151617181920212223/** * 全局的日期转换类 string-》date */@Componentpublic class DateConvert implements Converter&lt;String, Date&gt; &#123; private String[] pattern = &#123;&quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;yyyy-MM-dd&quot;&#125;; @Override public Date convert(String s) &#123; if (StringUtils.isNullOrEmpty(s)) &#123; return null; &#125; try &#123; if (s.contains(&quot;:&quot;)) &#123; return new SimpleDateFormat(pattern[0]).parse(s); &#125; else &#123; return new SimpleDateFormat(pattern[1]).parse(s); &#125; &#125; catch (Exception e) &#123; throw new SOAException(&quot;日期格式不正确，无法转换&quot; + s); &#125; &#125;&#125;","categories":[],"tags":[],"author":"卢国峥"},{"title":"docker四大网络模式","slug":"docker四大网络模式","date":"2020-04-23T14:50:00.000Z","updated":"2020-04-24T07:44:45.173Z","comments":true,"path":"2020/04/23/docker四大网络模式/","link":"","permalink":"https://www.lgzblog.com/2020/04/23/docker四大网络模式/","excerpt":"docker的网络管理之四大网络模式介绍~! bridge模式 host模式 container模式 none模式","text":"docker的网络管理之四大网络模式介绍~! bridge模式 host模式 container模式 none模式四大模式包含: bridge模式 host模式 container模式 none模式1.bridge模式当docker进程启动时,会在主机上创建一个名为docker0的虚拟网卡,此主机上启动的Docker容器会连接到这个虚拟网卡上,从docker0子网中分配一个IP给容器使用,并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备,docker将veth pair设备的一段放在新创建的容器中,并命名为eth0(容器的网卡),另一端放在主机中,以vethxxx这样类似的名字命名,并将这个网络设备加入到docker0网卡中。该模式是docker默认的网络模式。1docker run -d --name bridge_tomcat1 --net bridge [镜像ID]bridge模式如下图所示:bridge模式容器的网络端口映射:容器中的环境与宿主机隔离,name此时容器内与外部进行网络通信就会有些问题,外部不能直接访问容器内的IP地址和端口。docker为我们提供了宿主机的端口与容器内的端口映射来解决此问题,方式有两种,一种是随机映射,一种是指定映射,我一般都使用指定映射。在运行容器时,添加一下参数:随机映射:-p 会将容器中暴露的端口随机映射到宿主机的某一个端口上演示:1docker run --name tomcat1 -d -p [镜像ID]指定映射:-p hostPort:containerPort-p ip:hostPort:containerPort-p ip::containerPort-p 参数可以指定多次,如-p 9001:8001 -p 9002:8002演示:把容器8001端口映射到宿主机9001端口1docker run --name tomcat2 -d -p 9001:8001 tomcat2.host模式如果启动容器的时候使用host模式,那么容器将不会虚拟出自己的网卡,配置自己的IP等,而是使用宿主机的IP和端口。但是,容器的其他方面,如文件系统、进程列表等还是和宿主机隔离的。host模式如下图所示:3.container模式这个模式指定新创建的容器不会创建自己的网卡,配置自己的IP,而是和一个指定的容器共享IP、端口范围等。同样,两个容器除了网络方面,其他的如文件系统、进程列表等还是隔离的。演示:1docker run -d --name container_tomcat --net container:bridge_tomcat1 tomcatcontainer模式如下图所示:4.none模式:使用none模式,docker容器不会进行任何网络配置。也就是说,这个docker容器没有网卡、IP、路由等信息。需要我们自己为docker容器添加网卡、配置IP等。none模式如下图所示:","categories":[{"name":"docker容器系列","slug":"docker容器系列","permalink":"https://www.lgzblog.com/categories/docker容器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"}],"author":"卢国峥"},{"title":"秒杀功能设计思路","slug":"秒杀功能设计思路","date":"2020-04-21T02:58:00.000Z","updated":"2020-04-21T03:05:06.677Z","comments":true,"path":"2020/04/21/秒杀功能设计思路/","link":"","permalink":"https://www.lgzblog.com/2020/04/21/秒杀功能设计思路/","excerpt":"中间件使用: Redis RabbitMQ","text":"中间件使用: Redis RabbitMQ一. 使用Redis原因秒杀场景是属于一个高并发的场景,需要处理商品超卖的情况,而Redis是属于单线程的Nosql数据库,在Redis中使用String类型存储抢购商品的数量,每次抢购使用decr操作商品数量,如果返回的数据大于等于0,则抢购成功,否则失败.ps:decr是做减一操作,并返回结果.改操作是原子性的.二. 相关队列的设计介绍:order_pendding_queue: 用户抢购成功后向该队列发送订单信息,排队生成订单;delay_queue: 死信队列,不需要任何消费者,设置该队列的消息超时时间为15分钟,消息超时后发送到order_timeout_queue队列;order_timeout_queue: 订单超时的队列,消费者消费该队列的消息,验证订单是否付款(根据业务逻辑判断状态即可),未支付则该订单作废,并且回补库存,发送消息到pub_sub_queue队列,通知contorller释放本地标识;order_result_faile_queue: 下单失败则发送消息到该队列,做回补库存操作,并发送消息到pub_sub_queue队列,通知contorller释放本地标识;order_msg_queue: 订单服务创建订单不管成功/失败,都要向该队列发送消息,由websocket服务消费消息,通知用户抢购结果;pub_sub_queue: 该队列为发布订阅模式,在做库存回补操作后发布消息,通知controller释放本地标识;三.未完,待续…","categories":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"秒杀功能","slug":"秒杀功能","permalink":"https://www.lgzblog.com/tags/秒杀功能/"}],"author":"卢国峥"},{"title":"ElasticSearch常见面试题","slug":"ElasticSearch常见面试题","date":"2020-03-19T01:57:00.000Z","updated":"2020-03-19T03:21:07.000Z","comments":true,"path":"2020/03/19/ElasticSearch常见面试题/","link":"","permalink":"https://www.lgzblog.com/2020/03/19/ElasticSearch常见面试题/","excerpt":"整理最近面试遇到的Elasticsearch面试题~! 0.组件介绍 1.详细描述一下Elasticsearch索引文档的过程 2.详细描述一下Elasticsearch更新和删除文档的过程。 3.详细描述一下Elasticsearch搜索的过程 4.在并发情况下Elasticsearch如何保证读写一致 5.如何监控Elasticsearch集群状态? 6.elasticsearch了解多少,说说你们公司es的集群架构,索引数","text":"整理最近面试遇到的Elasticsearch面试题~! 0.组件介绍 1.详细描述一下Elasticsearch索引文档的过程 2.详细描述一下Elasticsearch更新和删除文档的过程。 3.详细描述一下Elasticsearch搜索的过程 4.在并发情况下Elasticsearch如何保证读写一致 5.如何监控Elasticsearch集群状态? 6.elasticsearch了解多少,说说你们公司es的集群架构,索引数0.组件介绍E1asticsearchTemplate: 框架封装的用于便捷操作Elasticsearth的模板类ElasticsearchRepository: 框架封装的用于便捷完成CRUD的接口NativeSearBuilder: 用于生成查询条件的构建器,需要去封装各种查询条件QueryBuilder: 该接口表示一个查询条件,其对象可以通过QueryBuilders工具类中的方法快速生成各种条件boolQuery(): 生成bool条件,相当于”boo”:{}matchquery(): 生成match条件,相当于” match”:{}rangeQuery(): 生成range条件,相当于” range”:{}bstractAggregati der: 用于生成分组查询的构建器,其对象通过AggregationBuilders工具类生成Pageable: 表示分页参数,对象通过PageRequest.of(页数,容量)获取SortBuil der: 排序构建器,对象通过SortBuilders.fieldsort(字段).order(规则)获取1.详细描述一下 Elasticsearch索引文档的过程协调节点默认使用文档D参与计算(也支持通过routing),以便为路由提供合适的分片。shard hash (document_id) % (num_of_primary_shards)当分片所在的节点接收到来自协调节点的请求后,会将请求写入到Memory Buffer,然后定时(默认是每隔1秒)写入到Filesystem Cache,这个从Momery Buffer到Filesystem Cache的过程就叫做refresh;当然在某些情况下,存在Momery Buffer.和Filesystem Cache的数据可能会丢失,ES是通过translog的机制来保证数据的可靠性的。其实现机制是接收到请求后,同时也会写入到translog中,当Filesystem cache中的数据写入到磁盘中时,才会清除掉,这个过程叫做fush;在fush过程中,内存中的缓冲将被清除,内容被写入一个新段,段的fsync将创建一个新的提交点,并将内容刷新到磁盘,旧的 Translog将被删除并开始一个新的translogfush触发的时机是定时触发(默认30分钟)或者translog变得太大(默认为512M)时;2.详细描述一下 Elasticsearch更新和删除文档的过程。·删除和更新也都是写操作,但是Elasticsearch!中的文档是不可变的,因此不能被删除或者改动以展示其变更;·磁盘上的每个段都有一个相应的.del文件。当删除请求发送后,文档并没有真的被删除,而是在.del文件中被标记为删除。该文档依然能匹配查询,但是会在结果中被过滤掉。当段合并时,在de文件中被标记为删除的文档将不会被写入新段。在新的文档被创建时,Elasticsearch会为该文档指定一个版本号,当执行更新时,旧版本的文档在.del文件中被标记为删除,新版本的文档被索引到—一个新段。旧版本的文档依然能匹配查询,但是会在结果中被过滤掉。3.详细描述一下 Elasticsearch搜索的过程搜索被执行成一个两阶段过程,我们称之为Query Then Fetch;在初始查询阶,时,查询会广播到索引中每一个分片拷贝(主分片或者副本分片)。每个分片在本地执行搜索并构建一个匹配文档的大小为from+se的优先队列。PS:在搜索的时候是会查询filesystem Cache的,但是有部分数据还在Memory Buffer,所以搜索是近实的的。·每个分片返回各自优先队列中所有文档的ID和排序值给协调节点它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表。接下来就是回阶段,协调节点辨别出哪些文档需要被取回并向相关的分片提交多个GET请求。每个分片加载并丰富文档,如果有需要的话,接着返回文档给协调节点。一旦所有的文档都被取回了,协调节点返回结果给客户端。补充:Query Then Fetch的索类型在文档相关性打分的的候参考的是本分片的数据,这样在文档数量较少的候可能不够准确,DFS Query Then Fet增加了一个预查询的处理,询可Term和Document frequency,这个评分更准确,但是性能会变差4.在并发情况下, Elasticsearch如何保证读写一致·可以通过版本号使用乐观并发控制,以确保新版本不会被旧版本覆盖,由应用层来处理具体的冲突;另外对于写操作,一致性级别支持quorum/one/a,默认为quorum,即只有当大多数分片可用时才允许写操作。但即使大多数可用,也可能存在因为网络等原因导致写入副本失败,这样该副本被认为故障,分片将会在一个不同的节点上重建。对于读操作,可以设置replication为syn(默认),这使得操作在主分片和副本分片都完成后才会返回;如果设置replication为async时,也可以通过设置搜索请求参数preference为primary来查询主分片,确保文档是最新版本5.如何监控 Elasticsearch集群状态?Marvel让你可以很简单的通过Kiana监控Elasticsearch。你可以实时查看你的集群健康状态和性能,也可以分析过去的集群、索引和节点指标6.elasticsearch了解多少,说说你们公司es的集群架构,索引数据大小,分片有多少,以及一些调优手段。面试官:想了解应聘者之前公司接触的ES使用场景、规模,有没有做过比较大规模的索引设计、规划、调优。解答:如实结合自己的实践场景回答即可。比如:ES集群架构13个节点,索引根据通道不同共20+索引,根据日期,毎日递增20+,索引:10分片,毎日递增1亿+数据,每个通道每天索引大小控制:150GB之内","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"Lambda&Stream专集","slug":"Lambda-Stream专集","date":"2019-11-20T01:32:00.000Z","updated":"2019-11-20T09:26:29.000Z","comments":true,"path":"2019/11/20/Lambda-Stream专集/","link":"","permalink":"https://www.lgzblog.com/2019/11/20/Lambda-Stream专集/","excerpt":"Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 Stream APIStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！","text":"Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。 Stream APIStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！Java8新特性简介:Java 8可谓是自Java 5以来最具革命性的版本了，她在语言、编译器、类库、开发工具以及Java虚拟机等方面都带来了不少新特性:（其中最为核心的为Lambda 表达式与Stream API）Lambda表达式Lambda表达式可以说是Java 8最大的卖点，她将函数式编程引入了Java。Lambda允许把函数作为一个方法的参数，或者把代码看成数据。Stream APIStream API是把真正的函数式编程风格引入到Java中。其实简单来说可以把Stream理解为MapReduce。从语法上看，也很像linux的管道、或者链式编程，代码写起来简洁明了，非常酷帅！接口的默认方法与静态方法我们可以在接口中定义默认方法，使用default关键字，并提供默认的实现。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。方法引用通常与Lambda表达式联合使用，可以直接引用已有Java类或对象的方法。重复注解Java 8引入重复注解，相同的注解在同一地方也可以声明多次。扩展注解的支持Java 8扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。OptionalJava 8引入Optional类来防止空指针异常，使用Optional类我们就不用显式进行空指针检查了。Date/Time API (JSR 310)Java 8新的Date-Time API (JSR 310)受Joda-Time的影响，提供了新的java.time包，可以用来替代 java.util.Date和java.util.Calendar。JavaScript引擎NashornNashorn允许在JVM上开发运行JavaScript应用，允许Java与JavaScript相互调用。Base64在Java 8中，Base64编码成为了Java类库的标准。Base64类同时还提供了对URL、MIME友好的编码器与解码器。更好的类型推测机制Java 8在类型推测方面有了很大的提高，这就使代码更整洁，不需要太多的强制类型转换了。编译器优化Java 8将方法的参数名加入了字节码中，这样在运行时通过反射就能获取到参数名，只需要在编译时使用-parameters参数。并行（parallel）数组支持对数组进行并行处理，主要是parallelSort()方法，它可以在多核机器上极大提高数组排序的速度。并发（Concurrency）在新增Stream机制与Lambda的基础之上，加入了一些新方法来支持聚集操作。Nashorn引擎jjs基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。类依赖分析器jdeps可以显示Java类的包级别或类级别的依赖。JVM的PermGen空间被移除取代它的是Metaspace（JEP 122）。Stream理解元素序列就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。因为集合是数据结构，所以它的主要目的是以特定的时间/空间复杂度存储和访问元素（如ArrayList 与 LinkedList）。但流的目的在于表达计算，比如filter、sorted和map。集合讲的是数据(存储)，流讲的是计算(处理)。源流会使用一个提供数据的源，如集合、数组或输入/输出资源。 请注意，从有序集合生成流时会保留原有的顺序。由列表生成的流，其元素顺序与列表一致。数据处理操作流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。此外，流操作有两个重要的特点。流水线很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线的操作可以看作对数据源进行数据库式查询。内部迭代与使用迭代器外部迭代的集合不同，流的迭代操作是在背后进行的。–摘自《Java 8 In Action》总结:整体来看，流式思想类似于车间的“生产流水线”。一. 创建流的方式Collection的默认方法stream()和parallelStream()Arrays.stream()Stream.of()Stream.iterate()//迭代无限流(1, n-&gt;n +1)Stream.generate()//生成无限流(Math::random)二. 筛选和切片① 过滤：filter(Predicatep):(根据传入的Lambda返回的ture/false 从流中过滤掉某些数据(筛选出某些数据))三. 去重：distinct():(根据流中数据的 hashCode和 equals去除重复元素)① limit(long n)：限定保留n个数据② 跳过n个数据：skip(long n)四. 映射① map(Function&lt;T, R&gt; f)：接收一个函数作为参数，该函数会被应用到流中的每个元素上，并将其映射成一个新的元素。② flatMap(Function&lt;T, Stream&gt; mapper)：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流五. 排序① sorted()：自然排序使用Comparable的int compareTo(T o)方法② sorted(Comparatorcom)：定制排序使用Comparator的int compare(T o1, T o2)方法六. 查找匹配① 检查是否匹配所有元素:allMatch② 检查是否至少匹配一个元素:anyMatch③ 检查是否没有匹配的元素:noneMatch④ findFirst:返回第一个元素(返回值为Optional)⑤ findAny:返回当前流中的任意元素(一般用于并行流)●备注Optional是Java8新加入的一个容器，这个容器只存1个或0个元素，它用于防止出现NullpointException，它提供如下方法：isPresent()判断容器中是否有值。ifPresent(Consume lambda)容器若不为空则执行括号中的Lambda表达式。T get()获取容器中的元素，若容器为空则抛出NoSuchElement异常。T 获取容器中的元素，若容器为空则返回括号中的默认值 。orElse(T other)七. 统计① 返回流中元素的总个数:count()② max(Comparator):返回流中最大值③ min(Comparator):返回流中最小值八. 归约reduce(T identity, BinaryOperator) / reduce(BinaryOperator) :将流中元素挨个结合起来，得到一个值。九. 分组和分区① Collectors.groupingBy()对元素做group操作。分组–根据条件分成多个组② Collectors.partitioningBy()对元素进行二分区操作。分区–根据boolean条件分成两个区Stream总结(Stream vs Collection)Stream vs Collection虽然大部分情况下Stream是容器调用Collection.stream()方法得到的，但Stream和Collection有以下不同：无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，集合等。不修改。对Stream的任何修改都不会修改背后的数据源，比如过滤操作并不会删除被过滤的元素，而是产生一个新Stream。惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。Stream分类中间操作(intermediate operations)返回值为Stream的大都是中间操作，中间操作支持链式调用，并且会惰式执行终端操作(结束操作)(terminal operations)返回值不为Stream 的为终端操作(立即求值)，终端操作不支持链式调用，会触发实际计算","categories":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"Lambda","slug":"Lambda","permalink":"https://www.lgzblog.com/tags/Lambda/"},{"name":"Stream","slug":"Stream","permalink":"https://www.lgzblog.com/tags/Stream/"}],"author":"卢国峥"},{"title":"RabbitMQ四大模式(Worker模式丶Pub/Sub模式丶Routing模式丶Topic模式)","slug":"2018-08-06-RabbitMQ-Four-models","date":"2019-11-13T06:13:00.000Z","updated":"2019-11-14T03:21:04.000Z","comments":true,"path":"2019/11/13/2018-08-06-RabbitMQ-Four-models/","link":"","permalink":"https://www.lgzblog.com/2019/11/13/2018-08-06-RabbitMQ-Four-models/","excerpt":"记录RabbitMQ四大模式: Worker模式 Pub/Sub模式 Routing模式 Topic模式","text":"记录RabbitMQ四大模式: Worker模式 Pub/Sub模式 Routing模式 Topic模式一. Worker模式如果生产者的生产速率大于消费者的消费速率,有可能导致消费的积压.queue中的消息个数理论上是没有限制,取决于内存有多大,积压的消息越多会影响MQ的性能队列的fetchCount值: 默认值是250.每个消费者会想队列预取250条消息,不管消费的快慢都属于自己处理了一般预取数量设置为1,SpringBoot整合RabbitMQ配置如下:1spring.rabbitmq.listener.simple.prefetch=1二. Pub/Sub模式(发布订阅模式) 发布订阅模式;实现发布订阅模式创建交换机类型只能是fanout,队列要绑定到交换机上.三. Rounting模式与Topic模式:Rounting模式: type=&quot;direct&quot;在队列绑定交换机时,需要设置一个RountingKey,生产者生成消息指定key后发送给交换机,交换机根据key把消息放入到对应的队列中.(key可以为多个)Topic模式: type=&quot;topic&quot;与Rounting模式相同,区别在于Topic模式在设置路由key可以使用通配符.路由key理解:在生产者发送消息时没有指定交换机时,MQ就会把该消息发送到AMQP default这个默认的交换机中,并且对应的路由key就是该队列的名称(默认定义queue时就使用队列名称当做路由key绑定到默认的交换机上),所以每个队列必定都会绑定交换机.","categories":[{"name":"消息队列MQ系列","slug":"消息队列MQ系列","permalink":"https://www.lgzblog.com/categories/消息队列MQ系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.lgzblog.com/tags/RabbitMQ/"}],"author":"卢国峥"},{"title":"RabbitMQ总结","slug":"RabbitMQ总结","date":"2019-11-11T02:19:00.000Z","updated":"2019-11-15T08:39:20.000Z","comments":true,"path":"2019/11/11/RabbitMQ总结/","link":"","permalink":"https://www.lgzblog.com/2019/11/11/RabbitMQ总结/","excerpt":"场景:订单业务每执行一个需要3s时间,不使用MQ现场会积压越来越多,CPU切换需要更多时间.使用MQ原因由于做业务需要很长时间,如果没有任何的措施,服务器无法及时的把请求响应,意味着有更多的请求进入到服务器,服务器的CPU需要在线程中间切换执行权,这样的话会导致处理的时间变得更长,久而久之,服务器就响应不过来,最终导致服务器崩溃.MQ作用总结:(MQ可以持久化消息,重启可以恢复)缓解类似秒杀高并发的场景压力可以对流量进行削峰可以实现解耦可以提高系统的可靠性","text":"场景:订单业务每执行一个需要3s时间,不使用MQ现场会积压越来越多,CPU切换需要更多时间.使用MQ原因由于做业务需要很长时间,如果没有任何的措施,服务器无法及时的把请求响应,意味着有更多的请求进入到服务器,服务器的CPU需要在线程中间切换执行权,这样的话会导致处理的时间变得更长,久而久之,服务器就响应不过来,最终导致服务器崩溃.MQ作用总结:(MQ可以持久化消息,重启可以恢复)缓解类似秒杀高并发的场景压力可以对流量进行削峰可以实现解耦可以提高系统的可靠性一. 场景:订单业务每执行一个需要3s时间,不使用MQ现场会积压越来越多,CPU切换需要更多时间.二. 使用MQ原因由于做业务需要很长时间,如果没有任何的措施,服务器无法及时的把请求响应,意味着有更多的请求进入到服务器,服务器的CPU需要在线程中间切换执行权,这样的话会导致处理的时间变得更长,久而久之,服务器就响应不过来,最终导致服务器崩溃.三. MQ作用总结:(MQ可以持久化消息,重启可以恢复)缓解类似秒杀高并发的场景压力可以对流量进行削峰可以实现解耦可以提高系统的可靠性四. MQ流程:五. RabbitMQ管理界面Ready: 准备被消费的消息total: 总消息数量Unacked: 没有确认的消息(被消费者消费了,却没有收到消息的ACK,则由Ready变为Unacked状态)定义queue:如果broker中没有这个队列就会帮我们在broker中创建队列,如果已经有了就不创建六. 消息持久化/签收机制持久化配置:(略)MQ自动签收弊端:队列想消费者发送一个ACK,消费者会马上发送一个ACK给MQ,然后队列会马上把消息删除掉,但是如果消费者在处理这条消息过程中出现异常,这样会导致这条消息的丢失,所以一般使用手动签收.ACK:消费者渠道消息后MQ没有收到ACK,则消息则变为Unacked状态,当消费者断开时,该消息又会变为Ready状态(相当于重新入队继续被消费).手动签收:当消费者处理完消息后,调用basicAck方法签收.七. 消费消息设计消费者消费消息处理: (使用redis)拿到消息的tag,利用redis原子性递增如果执行成功就不做任何动作,直接发送ACK删除消息如果失败,则判断在redis中的tag对应数值是多少,判断是否大于设定值3.1 如果没有大于设定值,则使用basicNack方法吧消息重新放入队列中重新消费.3.2 如果已经大于设定值,说明已经达到重试上限,则不再重新放入队列中,而是放入到另一个私信队列中等待人工处理.八. MQ幂等性处理处理消息的方法需要试下幂等性幂等性: f(x) = f(f(x))执行一次的结果和执行多次的结果都是一样的PS: get:幂等性的, insert:非幂等性当①②步骤都没有问题是,C又向MQ发送ACK,但是在③步骤中遇到网络延迟,MQ没有收到ACK则不会删除消息,C则会重复消费一次消息,这样就重复消费了,所有需要实现幂等性.st=>start: 生产者 e=>end: 消费者 op1=>operation: 消息 op2=>operation: 交换机 op3=>operation: 队列 st(right)->op1(right)->op2(right)->op3(right)->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12}var code=document.getElementById(\"flowchart-0-code\").value,options=JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)),diagram=flowchart.parse(code);diagram.drawSVG(\"flowchart-0\",options)","categories":[{"name":"消息队列MQ系列","slug":"消息队列MQ系列","permalink":"https://www.lgzblog.com/categories/消息队列MQ系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.lgzblog.com/tags/RabbitMQ/"}],"author":"卢国峥"},{"title":"SpringBoot整合RabbitMQ并使用","slug":"SpringBoot整合RabbitMQ并使用","date":"2019-11-09T06:51:00.000Z","updated":"2019-11-09T07:13:25.000Z","comments":true,"path":"2019/11/09/SpringBoot整合RabbitMQ并使用/","link":"","permalink":"https://www.lgzblog.com/2019/11/09/SpringBoot整合RabbitMQ并使用/","excerpt":"SpringBoot版本: 2.1.3.RELEASE SpringBoot整合RabbitMQ添加依赖:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;","text":"SpringBoot版本: 2.1.3.RELEASE SpringBoot整合RabbitMQ添加依赖:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;一. SpringBoot整合RabbitMQ添加依赖:12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;二. 提供者1234567891011121314151617181920212223242526272829303132333435363738394041/** * @author LuGuoZheng * @date 2019/11/6 9:48 * @Version 3.0 * @description */@RestController@RequestMapping(\"/mqTest\")public class Provider &#123; @Autowired private AmqpTemplate amqpTemplate; @NoAuth @RequestMapping(\"/queue\") public String sendMq(String msg) &#123; amqpTemplate.convertAndSend(\"\", \"boot_queue\", msg); return \"发送成功\"; &#125; @NoAuth @RequestMapping(\"/pubsub\") public String sendPubsub(String msg) &#123; amqpTemplate.convertAndSend(\"boot_pubsub_exchange\", \"\", msg); return \"发送成功\"; &#125; @NoAuth @RequestMapping(\"/rounting\") public String rounting(String key) &#123; amqpTemplate.convertAndSend(\"boot_rounting_exchange\", key, \"rounting消息\"); return \"发送成功\"; &#125; @NoAuth @RequestMapping(\"/topic\") public String topic(String key) &#123; amqpTemplate.convertAndSend(\"boot_topic_exchange\",key,\"topic消息\"); return \"发送成功\"; &#125;&#125;三. 消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author LuGuoZheng * @date 2019/11/6 9:47 * @Version 3.0 * @description */@Component@Slf4jpublic class Consumer &#123; @RabbitListener(queuesToDeclare = @Queue(\"boot_queue\")) public void consumerMq(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"普通队列消息:&#123;&#125;\", msg); channel.basicAck(delivery, false); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue, exchange = @Exchange(name = \"boot_pubsub_exchange\", type = \"fanout\"))) public void receiveMsg1(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"订阅发布模式1:&#123;&#125;\", msg); channel.basicAck(delivery, false); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue, exchange = @Exchange(name = \"boot_pubsub_exchange\", type = \"fanout\"))) public void receiveMsg2(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"订阅发布模式2:&#123;&#125;\", msg); channel.basicAck(delivery, false); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"boot_rounting_queue01\"), exchange = @Exchange(name = \"boot_rounting_exchange\", type = \"direct\"), key = &#123;\"info\", \"error\", \"warning\"&#125;)) public void rountiong1(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"rounting1:&#123;&#125;\", msg); channel.basicAck(delivery, false); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = \"boot_rounting_queue02\"), exchange = @Exchange(name = \"boot_rounting_exchange\", type = \"direct\"), key = &#123;\"info\", \"warning\"&#125;)) public void rounting2(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"rounting2:&#123;&#125;\", msg); channel.basicAck(delivery, false); &#125; @RabbitListener(bindings = @QueueBinding( value = @Queue, exchange = @Exchange(name = \"boot_topic_exchange\",type = \"topic\"), key = &#123;\"order.*\",\"user.*\",\"order.update\"&#125;)) public void topic1(String msg, @Header(AmqpHeaders.DELIVERY_TAG) long delivery, Channel channel) throws Exception &#123; log.warn(\"topic1:&#123;&#125;\", msg); channel.basicAck(delivery,false); &#125;&#125;","categories":[{"name":"消息队列MQ系列","slug":"消息队列MQ系列","permalink":"https://www.lgzblog.com/categories/消息队列MQ系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"RabbitMQ","slug":"RabbitMQ","permalink":"https://www.lgzblog.com/tags/RabbitMQ/"}],"author":"卢国峥"},{"title":"SpringBoot整合ES并使用","slug":"SpringBoot整合ES并使用","date":"2019-11-03T03:53:00.000Z","updated":"2019-11-08T03:38:09.000Z","comments":true,"path":"2019/11/03/SpringBoot整合ES并使用/","link":"","permalink":"https://www.lgzblog.com/2019/11/03/SpringBoot整合ES并使用/","excerpt":"SpringBoot版本: 2.1.3.RELEASESpringBoot整合ES添加依赖:12345&lt;!--SpringBoot整合elasticsearch依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;","text":"SpringBoot版本: 2.1.3.RELEASESpringBoot整合ES添加依赖:12345&lt;!--SpringBoot整合elasticsearch依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;一. 添加ES依赖:12345&lt;!--SpringBoot整合elasticsearch依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;二. 实体类1234567891011121314151617181920212223242526272829/** * @Created by LuGuoZheng * @Description TODO * @Date 2019/9/26 9:27 */@Data@Document(indexName = \"log\",type = \"log\")public class LogDto implements Serializable &#123; //自增ID @Id private String id; //日志级别 private String loglevel; //类名 @Field(analyzer = \"ik_max_word\",searchAnalyzer = \"ik_max_word\",type = FieldType.Text) private String classname; //日志内容 @Field(analyzer = \"ik_max_word\",searchAnalyzer = \"ik_max_word\",type = FieldType.Text) private String mess; //创建时间 @Field(type = FieldType.Keyword) private String createrTime;&#125;三. 实现ElasticsearchRepository接口123456789101112/** * @author LuGuoZheng * @date 2019/9/24 15:40 * @Version 3.0 * @description 泛型1:domain的类型 * 泛型2:@Id的类型 * 该接口会交给spring,底层会使用JDK动态代理的方式创建对象,交给容器管理 */@Servicepublic interface LogESRepostoryService extends ElasticsearchRepository&lt;LogDto, String&gt; &#123; // 自定义JPA高级查询&#125;四. Facade层(实现高亮查询)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @author LuGuoZheng * @date 2019/9/26 9:24 * @Version 3.0 * @description */@Servicepublic class LogESRepostoryFacadeImpl implements LogESRepostoryFacade &#123; @Autowired private LogESRepostoryService logESRepostoryService; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Override public LogDto save(LogDto logDto) &#123; return logESRepostoryService.save(logDto); &#125; @Override public JSONResult selectByParams(LogCondition logCondition) &#123; String loglevel = logCondition.getLoglevel(); String classname = logCondition.getClassname(); String mess = logCondition.getMess(); String beginTime = logCondition.getBeginTime(); String endTime = logCondition.getEndTime(); // 自定义JPA高级查询 NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); BoolQueryBuilder boolQuery = QueryBuilders.boolQuery(); if (StringUtil.isNotEmpty(loglevel)) &#123; // 日志级别 boolQuery.must(QueryBuilders.matchQuery(\"loglevel\", loglevel)); &#125; if (StringUtil.isNotEmpty(classname)) &#123; // 模块 boolQuery.must(QueryBuilders.matchQuery(\"classname\", classname)); &#125; if (StringUtil.isNotEmpty(mess)) &#123; // 内容 boolQuery.must(QueryBuilders.matchQuery(\"mess\", mess)); //指定高亮字段 HighlightBuilder.Field field = new HighlightBuilder.Field(\"mess\"); //高亮显示规则 field.preTags(\"&lt;span style='color:red'&gt;\"); field.postTags(\"&lt;/span&gt;\"); builder.withHighlightFields(field); &#125; boolQuery.filter(QueryBuilders.rangeQuery(\"createrTime\").gte(beginTime).lte(endTime)); // 分页 builder.withPageable(PageRequest.of(logCondition.getCurrentPage() - 1, logCondition.getPageSize())); // 按照时间排序 builder.withSort(SortBuilders.fieldSort(\"createrTime\").order(SortOrder.DESC)); builder.withQuery(boolQuery); ObjectMapper mapper = new ObjectMapper(); Page&lt;LogDto&gt; logDtos = elasticsearchTemplate.queryForPage(builder.build(), LogDto.class, new SearchResultMapper() &#123; @Override public &lt;T&gt; AggregatedPage&lt;T&gt; mapResults(SearchResponse searchResponse, Class&lt;T&gt; aClass, Pageable pageable) &#123; List&lt;T&gt; list = new ArrayList&lt;&gt;(); long totalHits = searchResponse.getHits().getTotalHits(); try &#123; for (SearchHit hit : searchResponse.getHits()) &#123; // 把JSON字符串转换成java对象 T result = mapper.readValue(hit.getSourceAsString(), aClass); // 获取高亮显示的字段名称 Collection&lt;HighlightField&gt; highlightFields = hit.getHighlightFields().values(); for (HighlightField highlightField : highlightFields) &#123; // 替换高亮查询到的属性 BeanUtils.setProperty(result,highlightField.getName(),highlightField.getFragments()); &#125; list.add(result); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; return new AggregatedPageImpl&lt;&gt;(list,pageable,totalHits,searchResponse.getAggregations()); &#125; &#125;); PageResult pageResult = new PageResult(Long.valueOf(logDtos.getTotalElements()).intValue(), logCondition.getCurrentPage(), logCondition.getPageSize(), logDtos.getContent()); return JSONResult.SUCC(\"\",pageResult); &#125;&#125;五. 条件实体123456789101112131415161718192021222324/** * @Created by LuGuoZheng * @Description TODO * @Date 2019/9/26 9:28 */@Datapublic class LogCondition extends BaseCondition &#123; //日志级别 private String loglevel; //类名 private String classname; //内容 private String mess; //起始时间 private String beginTime; //结束时间 private String endTime;&#125;五. 测试类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author LuGuoZheng * @date 2019/9/26 9:29 * @Version 3.0 * @description */@RunWith(SpringRunner.class)@SpringBootTestpublic class TestDemo &#123; @Autowired private LogESRepostoryFacade logESRepostoryFacade; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void saveOrUpdate() throws ParseException &#123; LogDto logDto = new LogDto(); logDto.setId(UUID.randomUUID().toString()); logDto.setClassname(\"com.ylcloud.common.filter.CorsFilter\"); logDto.setLoglevel(\"INFO \"); logDto.setMess(\"=====admin-web应用启动成功=====\"); logDto.setCreaterTime(\"2019-09-25 18:30:00\"); logESRepostoryFacade.save(logDto); &#125; @Test public void search() throws ParseException &#123; NativeSearchQueryBuilder builder = new NativeSearchQueryBuilder(); builder.withQuery(QueryBuilders.rangeQuery(\"createrTime\").lte(\"2019-09-25 19:00:00\")); List&lt;LogDto&gt; logDtos = elasticsearchTemplate.queryForList(builder.build(), LogDto.class); logDtos.forEach(System.out::println); &#125; @Test public void selectByParams() &#123; LogCondition logCondition = new LogCondition(); logCondition.setLoglevel(\"warn\"); logCondition.setClassname(\"ClassPathMapperScanner\"); logCondition.setMess(\"yllog\"); logCondition.setBeginTime(\"2019-09-26 10:00:00\"); logCondition.setEndTime(\"2019-09-26 12:00:00\"); logCondition.setCurrentPage(1); logCondition.setPageSize(10); JSONResult jsonResult = logESRepostoryFacade.selectByParams(logCondition); Object data = jsonResult.getData(); System.out.println(data); &#125;&#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":" sql语句查询经纬度范围(转)","slug":"sql语句查询经纬度范围","date":"2019-10-22T02:19:00.000Z","updated":"2019-10-22T02:23:52.000Z","comments":true,"path":"2019/10/22/sql语句查询经纬度范围/","link":"","permalink":"https://www.lgzblog.com/2019/10/22/sql语句查询经纬度范围/","excerpt":"原文链接:https://segmentfault.com/q/1010000005100905SQL语句如下:123456789101112131415161718192021222324SELECT *FROM locationWHERE sqrt( ( ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) * ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) ) + ( ( (22.50128 - latitude) * PI() * 12656 / 180 ) * ( (22.50128 - latitude) * PI() * 12656 / 180 ) ) ) &lt; 2","text":"原文链接:https://segmentfault.com/q/1010000005100905SQL语句如下:123456789101112131415161718192021222324SELECT *FROM locationWHERE sqrt( ( ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) * ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) ) + ( ( (22.50128 - latitude) * PI() * 12656 / 180 ) * ( (22.50128 - latitude) * PI() * 12656 / 180 ) ) ) &lt; 2原文链接:https://segmentfault.com/q/1010000005100905最近在做查询指定经纬度范围的数据；问题不知如何下手，于是网上找了点资料，其中有些不懂的地方希望大家能给点想法！问题是这样的：sql语句查询经纬度范围指定一个经纬度，给定一个范围值(单位:千米)，查出在经纬度周围这个范围内的数据。经度:113.914619纬度:22.50128范围:2kmlongitude为数据表经度字段latitude为数据表纬度字段SQL在mysql下测试通过,其他数据库可能需要修改SQL语句如下:123456789101112131415161718192021222324SELECT *FROM locationWHERE sqrt( ( ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) * ( (113.914619 - longitude) * PI() * 12656 * cos( ((22.50128 + latitude) / 2) * PI() / 180 ) / 180 ) ) + ( ( (22.50128 - latitude) * PI() * 12656 / 180 ) * ( (22.50128 - latitude) * PI() * 12656 / 180 ) ) ) &lt; 2","categories":[{"name":"MySQL数据库系列","slug":"MySQL数据库系列","permalink":"https://www.lgzblog.com/categories/MySQL数据库系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.lgzblog.com/tags/MySQL/"}],"author":"卢国峥"},{"title":"docker容器内操作权限问题","slug":"docker容器内目录间移动权限问题","date":"2019-09-28T07:20:00.000Z","updated":"2019-09-28T03:24:39.000Z","comments":true,"path":"2019/09/28/docker容器内目录间移动权限问题/","link":"","permalink":"https://www.lgzblog.com/2019/09/28/docker容器内目录间移动权限问题/","excerpt":"参考博客:https://blog.csdn.net/weixin_43577800/article/details/84844438 问题解决:退出容器进入宿主机中,授权挂载的两个数据卷1chown -R 1000 /home/softs/jenkins","text":"参考博客:https://blog.csdn.net/weixin_43577800/article/details/84844438 问题解决:退出容器进入宿主机中,授权挂载的两个数据卷1chown -R 1000 /home/softs/jenkins映射了两个数据卷,但是在docker容器内需要把数据卷1的内容移到数据卷2目录项,出现以下提示:没有权限操作…参考博客:https://blog.csdn.net/weixin_43577800/article/details/848444381cannot create regular file &apos;/var/yl_cloud/order.war&apos;: Permission denied问题解决:退出容器进入宿主机中,授权挂载的两个数据卷1chown -R 1000 /home/softs/jenkins","categories":[{"name":"docker容器系列","slug":"docker容器系列","permalink":"https://www.lgzblog.com/categories/docker容器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"}],"author":"卢国峥"},{"title":"解决创建容器是出现的错误:IPv4 forwarding is disabled. Networking will not work.","slug":"解决创建容器是出现的错误-IPv4-forwarding-is-disabled-Networking-will-not-work","date":"2019-09-28T06:58:00.000Z","updated":"2019-09-28T03:26:11.000Z","comments":true,"path":"2019/09/28/解决创建容器是出现的错误-IPv4-forwarding-is-disabled-Networking-will-not-work/","link":"","permalink":"https://www.lgzblog.com/2019/09/28/解决创建容器是出现的错误-IPv4-forwarding-is-disabled-Networking-will-not-work/","excerpt":"记录~!","text":"记录~!测试服务器跟换IP后,在启动容器的时候导致无法访问,然后尝试重新创建容器,出现了IPv4 forwarding is disabled. Networking will not work.错误..解决办法：在宿主机下更改00-system.conf文件1vi /usr/lib/sysctl.d/00-system.conf添加一下代码1net.ipv4.ip_forward=1重启network服务1systemctl restart network原文博客:https://blog.csdn.net/zhydream77/article/details/81902457","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"},{"name":"IPv4","slug":"IPv4","permalink":"https://www.lgzblog.com/tags/IPv4/"}],"author":"卢国峥"},{"title":"ElasticSearch基础练习","slug":"ElasticSearch基础应用","date":"2019-09-22T01:34:00.000Z","updated":"2019-09-28T03:32:29.000Z","comments":true,"path":"2019/09/22/ElasticSearch基础应用/","link":"","permalink":"https://www.lgzblog.com/2019/09/22/ElasticSearch基础应用/","excerpt":"记录ElasticSearch基础CRUD操作","text":"记录ElasticSearch基础CRUD操作参数格式都是6.x的格式,实例是在7.x版本下完成的,所以实例格式与参数格式有所差异基于lasticSearch 7.0版本的CRUD操作1. 建立索引库12# 建立索引库PUT /user1.1 建立索引库并设置副本和分片Ps: 7.x版本副本和分片默认为: 1参数格式:PUT /{索引库名称}12345678# 建立索引库并设置副本和分片PUT /user&#123; \"settings\": &#123; \"number_of_replicas\": 2, \"number_of_shards\": 3 &#125;&#125;1.2 # 建立索引库并设置mapping1234567891011121314151617181920212223PUT /user&#123; \"settings\": &#123; \"number_of_replicas\": 1, \"number_of_shards\": 4 &#125;, \"mappings\": &#123; \"properties\": &#123; \"userId\":&#123; \"type\": \"keyword\" &#125;, \"name\":&#123; \"type\": \"keyword\" &#125;, \"age\":&#123; \"type\": \"keyword\" &#125;, \"deptId\":&#123; \"type\": \"keyword\" &#125; &#125; &#125;&#125;2. 删除索引库参数格式:DELETE /{索引库名称}12# 删除索引库DELETE /user3. 添加文档参数格式:PUT /{索引库}/{类型}/{索引id}1234567# 添加文档PUT /user/_doc/1&#123; \"userId\":\"4\", \"name\":\"I kittle\", \"memo\":\"xiao mi\"&#125;4. 检索文档参数格式:GET /{索引库}/{类型}/{索引id}12# 获取文档GET /user/_doc/15. 检索文档:排序参数格式GET /{索引库}/{类型}/_search{“sort”:[{“age”:”asc”}]}1234567# 搜索文档:排序GET /user/_doc/_search&#123; \"sort\":[ &#123;\"age\":\"asc\"&#125; ]&#125;6.检索查询参数格式:GET /user/_doc/_search{“query”:{{检索方式}:{field:value}}}检索方式:term表示精确匹配,value值不会被分词器拆分,按照倒排索引匹配,一般用于filter中match_phrase表示短语检索,value值不会被分词器拆分,直接去倒排索引中匹配match表示全文检索,value值会被分词器拆分,然后去倒排索引中匹配range表示范围检索,有 gt/gte/lt/lte 等6.1 查询名称为’wang da’的员工123456789# 查询名称为'wang da'的员工GET /user/_search&#123; \"query\":&#123; \"term\":&#123; \"name\":\"wang\" &#125; &#125;&#125;6.2 使用match查询’wang’员工123456789# 使用match查询'wang'员工GET /user/_search&#123; \"query\":&#123; \"term\":&#123; \"name\":\"wang\" &#125; &#125;&#125;6.3 查询出28到30岁的员工123456789101112# 查询出28到30岁的员工GET /user/_search&#123; \"query\": &#123; \"range\": &#123; \"age\": &#123; \"gte\": 28, \"lte\": 30 &#125; &#125; &#125;&#125;7. 关键字查询multi_match:表示在多个字段间做检索12345678910#关键字查询GET /emp/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"am\", \"fields\": [\"name\",\"memo\"] &#125; &#125;&#125;8. 投影查询类似MySQL的查询语句中select后面的字段一样12345678910111213# 查询指定字段'_source'和'query'是同一级别的GET /user/_search&#123; \"_source\":[\"name\",\"age\"] , \"query\": &#123; \"range\": &#123; \"age\": &#123; \"gte\": 28, \"lte\": 30 &#125; &#125; &#125;&#125;9. 高亮显示1234567891011121314151617# 'am'高亮显示,高亮查询:把检索出来的文档匹配的内容高亮显示,需要配合检索使用,把查询的内容高亮GET /emp/_search&#123; \"query\": &#123; \"multi_match\": &#123; \"query\": \"am\", \"fields\": [\"name\",\"memo\"] &#125; &#125;, \"_source\": [\"userId\",\"name\",\"memo\"], \"highlight\": &#123; \"fields\": &#123; \"name\":&#123;&#125;, \"memo\":&#123;&#125; &#125; &#125;&#125;10. 逻辑查询逻辑查询规则: must/should/must_not,相当于 and/or/not参数格式:10.1 检索部门为1,并且大于32岁的员工12345678910111213141516171819202122#需求:获取部门为1,并且大于32岁的员工GET /user/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"term\": &#123; \"deptId\":1 &#125; &#125;, &#123; \"range\": &#123; \"age\": &#123; \"gt\": 32 &#125; &#125; &#125; ] &#125; &#125;&#125;10.2 检索出部门1或者小于30岁的员工.123456789101112131415161718192021222324252627282930#需求:检索出部门1或者小于30岁的员工.GET /user/_search&#123; \"sort\": [ &#123; \"age\": &#123; \"order\": \"asc\" &#125;, \"deptId\":\"asc\" &#125; ], \"query\": &#123; \"bool\": &#123; \"should\": [ &#123; \"term\": &#123; \"deptId\":1 &#125; &#125;, &#123; \"range\": &#123; \"age\": &#123; \"gt\": 30 &#125; &#125; &#125; ] &#125; &#125;&#125;10.3 获取部门不为1的员工12345678910111213141516171819202122#需求:获取部门不为1的员工GET /user/_search&#123; \"sort\": [ &#123; \"deptId\": &#123; \"order\": \"asc\" &#125; &#125; ], \"query\": &#123; \"bool\": &#123; \"must_not\": [ &#123; \"term\": &#123; \"deptId\": \"1\" &#125; &#125; ] &#125; &#125;&#125;11. 过滤查询filter表示在查询中不涉及评分,并且有缓存,用于精确匹配,filter中的检索方式多为term123456789101112131415161718192021GET /user/_search&#123; \"query\": &#123; \"bool\": &#123; \"filter\": [ &#123; \"term\": &#123; \"deptId\": 1 &#125; &#125;, &#123; \"range\": &#123; \"age\":&#123; \"gt\":30 &#125; &#125; &#125; ] &#125; &#125;&#125;12. 分组查询分组运算:avg/sum/min/max/value_count/stats(执行以上所有功能)12.1 统计各部门平均年龄12345678910111213141516171819#需求:统计各部门平均年龄GET /user/_search&#123; \"aggs\": &#123; \"groupByDeptId\":&#123; \"terms\": &#123; \"field\": \"deptId\", \"size\": 10 &#125;, \"aggs\": &#123; \"userAge\": &#123; \"avg\": &#123; \"field\": \"age\" &#125; &#125; &#125; &#125; &#125;&#125;12.2 统计各部门的人数12345678910111213141516171819#需求:统计各部门的人数GET /user/_search&#123; \"aggs\": &#123; \"groupByDeptId\": &#123; \"terms\": &#123; \"field\": \"deptId\", \"size\": 10 &#125;, \"aggs\": &#123; \"totalCount\": &#123; \"value_count\": &#123; \"field\": \"deptId\" &#125; &#125; &#125; &#125; &#125;&#125;12.3 统计每个部门最大年龄12345678910111213141516171819#需求:统计每个部门最大年龄GET /user/_search&#123; \"aggs\": &#123; \"groupByDeptId\": &#123; \"terms\": &#123; \"field\": \"deptId\", \"size\": 10 &#125;, \"aggs\": &#123; \"maxAge\": &#123; \"max\": &#123; \"field\": \"age\" &#125; &#125; &#125; &#125; &#125;&#125;12.4 统计每个部门最小年龄12345678910111213141516171819#需求:统计每个部门最小年龄GET /user/_search&#123; \"aggs\": &#123; \"groupBydeptId\": &#123; \"terms\": &#123; \"field\": \"deptId\", \"size\": 10 &#125;, \"aggs\": &#123; \"minAge\": &#123; \"min\": &#123; \"field\": \"age\" &#125; &#125; &#125; &#125; &#125;&#125;12.5 统计所有员工年龄总和1234567891011#需求:统计所有员工年龄总和GET /user/_search&#123; \"aggs\": &#123; \"sumAge\": &#123; \"sum\": &#123; \"field\": \"age\" &#125; &#125; &#125;&#125;12.6 使用state函数12345678910111213141516171819#需求:使用state函数GET /user/_search&#123; \"aggs\": &#123; \"groupByDeptId\": &#123; \"terms\": &#123; \"field\": \"deptId\", \"size\": 10 &#125;, \"aggs\": &#123; \"stateUse\": &#123; \"stats\": &#123; \"field\": \"age\" &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"Linux查看MySQL初始密码,配置远程访问","slug":"MySQL安装","date":"2019-09-21T08:52:00.000Z","updated":"2019-09-21T09:07:53.000Z","comments":true,"path":"2019/09/21/MySQL安装/","link":"","permalink":"https://www.lgzblog.com/2019/09/21/MySQL安装/","excerpt":"","text":"查看初始密码1grep &quot;password&quot; /var/log/mysqld.log登录MySQL1mysql -u root -p实现远程连接（改表法）12use mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;实现远程连接(授权法)123use mysql;grant all privileges on *.* to root@&apos;%&apos; identified by &quot;password&quot;;flush privileges;","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.lgzblog.com/tags/MySQL/"}],"author":"卢国峥"},{"title":"解决MySQL错误:Too many connections","slug":"解决MySQL错误-Too-many-connections","date":"2019-09-21T06:39:00.000Z","updated":"2019-09-28T03:19:21.000Z","comments":true,"path":"2019/09/21/解决MySQL错误-Too-many-connections/","link":"","permalink":"https://www.lgzblog.com/2019/09/21/解决MySQL错误-Too-many-connections/","excerpt":"记录~!解决MySQL错误:Too many connections","text":"记录~!解决MySQL错误:Too many connections在搭建测试服务器的时候重新安装了MySQL,配置文件没有备份过来,导致项目启动的时候出现了Too many connections错误..即是连接太多了..这就需要我们配置MySQL的连接数了..在MySQL官方文档中有说明连接数默认值为151MySQL官方文档","categories":[{"name":"MySQL数据库系列","slug":"MySQL数据库系列","permalink":"https://www.lgzblog.com/categories/MySQL数据库系列/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.lgzblog.com/tags/MySQL/"}],"author":"卢国峥"},{"title":"yum安装MySQL","slug":"yum安装MySQL","date":"2019-09-21T02:04:00.000Z","updated":"2019-11-22T03:30:38.000Z","comments":true,"path":"2019/09/21/yum安装MySQL/","link":"","permalink":"https://www.lgzblog.com/2019/09/21/yum安装MySQL/","excerpt":"docker部署MySQL可参考一下博客.https://www.cnblogs.com/zuxing/articles/9005234.html","text":"docker部署MySQL可参考一下博客.https://www.cnblogs.com/zuxing/articles/9005234.htmldocker部署MySQL可参考一下博客.https://www.cnblogs.com/zuxing/articles/9005234.html下载并安装MySQL官方的 Yum Repository1wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm使用上面的命令就直接下载了安装用的Yum Repository,然后就可以直接yum安装。1yum -y install mysql57-community-release-el7-10.noarch.rpm使用yum安装MySQL1yum -y install mysql-community-serverMySQL数据库设置先启动MySQL1systemctl start mysqld查看启动状态1systemctl status mysqld查看初始密码1grep &quot;password&quot; /var/log/mysqld.log登录MySQL1mysql -u root -p实现远程连接（改表法）12use mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;实现远程连接(授权法)123use mysql;grant all privileges on *.* to root@&apos;%&apos; identified by &quot;password&quot;;flush privileges;","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://www.lgzblog.com/tags/MySQL/"}],"author":"卢国峥"},{"title":"Linux配置java环境","slug":"Linux配置java环境","date":"2019-09-20T07:57:00.000Z","updated":"2019-09-28T03:18:45.000Z","comments":true,"path":"2019/09/20/Linux配置java环境/","link":"","permalink":"https://www.lgzblog.com/2019/09/20/Linux配置java环境/","excerpt":"","text":"java环境配置通过ftp把jdk上传到服务器并解压1tar -zxvf jdk-8u181-linux-x64.tar.gz通过pwd命令获取路径修改/etc/profile文件加入以下配置ps:多个环境变量路径之间用:隔开123456#Jdk JAVA_HOME=/home/softs/java8/jdk1.8.0_181/PATH=$JAVA_HOME/bin#文件尾部加入PATH=$PATHexport PATH刷新配置1source /etc/profile测试是否配置成功1java -version","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"Linux","slug":"Linux","permalink":"https://www.lgzblog.com/tags/Linux/"},{"name":"maven","slug":"maven","permalink":"https://www.lgzblog.com/tags/maven/"}],"author":"卢国峥"},{"title":"Hexo添加代码复制功能","slug":"Hexo添加代码复制功能","date":"2019-09-08T02:16:00.000Z","updated":"2019-09-08T07:13:50.000Z","comments":true,"path":"2019/09/08/Hexo添加代码复制功能/","link":"","permalink":"https://www.lgzblog.com/2019/09/08/Hexo添加代码复制功能/","excerpt":"记录Hexo添加代码复制功能~!","text":"记录Hexo添加代码复制功能~!1. 在js目录添加clipboard.min.js文件clipboard.min.js2.在js目录添加cpbutt.js文件1234567891011121314151617181920212223242526272829303132$(function () &#123; $('table').each(function (i, e) &#123; var $wrap = $('&lt;div&gt;').addClass('highlight-wrap'); $(e).after($wrap); $wrap.append($('&lt;button&gt;').addClass('copy-btn').append('复制').on('click', function (e) &#123; var code = $(this).parent().find('.code').find('.line').map(function (i, e) &#123; return $(e).text(); &#125;).toArray().join('\\n'); var ta = document.createElement('textarea'); var yPosition = window.pageYOffset || document.documentElement.scrollTop; ta.style.top = yPosition + 'px'; // Prevent page scroll ta.style.position = 'absolute'; ta.style.opacity = '0'; ta.readOnly = true; ta.value = code; document.body.appendChild(ta); ta.select(); ta.setSelectionRange(0, code.length); ta.readOnly = false; var result = document.execCommand('copy'); if (result) $(this).text('复制成功'); else $(this).text('复制失败'); ta.blur(); // For iOS $(this).blur(); &#125;)).on('mouseleave', function (e) &#123; var $b = $(this).find('.copy-btn'); setTimeout(function () &#123; $b.text('复制'); &#125;, 300); &#125;).append(e); &#125;);&#125;)Ps:记得引入连个js文件","categories":[{"name":"Hexo之瞎折腾系列","slug":"Hexo之瞎折腾系列","permalink":"https://www.lgzblog.com/categories/Hexo之瞎折腾系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.lgzblog.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.lgzblog.com/tags/博客/"}],"author":"卢国峥"},{"title":"Hexo添加伊布模型","slug":"Hexo添加伊布模型","date":"2019-09-08T02:04:00.000Z","updated":"2019-09-08T02:15:19.000Z","comments":true,"path":"2019/09/08/Hexo添加伊布模型/","link":"","permalink":"https://www.lgzblog.com/2019/09/08/Hexo添加伊布模型/","excerpt":"记录Hexo添加伊布模型~!","text":"记录Hexo添加伊布模型~!1. 在layout.ejs中加入以下html代码片段123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;div class=\"eevee\"&gt; &lt;div class=\"message\"&gt;嗨，你好啊~~&lt;/div&gt; &lt;div class=\"body\"&gt; &lt;div class=\"head\"&gt; &lt;div class=\"ears\"&gt; &lt;div class=\"ear\"&gt; &lt;div class=\"lobe\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"ear\"&gt; &lt;div class=\"lobe\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"face\"&gt; &lt;div class=\"eyes\"&gt; &lt;div class=\"eye\"&gt; &lt;div class=\"eyelid\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"eye\"&gt; &lt;div class=\"eyelid\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"nose\"&gt;&lt;/div&gt; &lt;div class=\"mouth\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"chest\"&gt; &lt;div class=\"fur\"&gt; &lt;div class=\"patch\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"fur\"&gt; &lt;div class=\"patch\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"fur\"&gt; &lt;div class=\"patch\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"legs\"&gt; &lt;div class=\"leg\"&gt; &lt;div class=\"inner-leg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"leg\"&gt; &lt;div class=\"inner-leg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"leg\"&gt; &lt;div class=\"inner-leg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"leg\"&gt; &lt;div class=\"inner-leg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"tail\"&gt; &lt;div class=\"tail\"&gt; &lt;div class=\"tail\"&gt; &lt;div class=\"tail\"&gt; &lt;div class=\"tail\"&gt; &lt;div class=\"tail -end\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;2. js相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697(() =&gt; &#123;// 伊布复制消息 document.addEventListener('copy', function (e) &#123; showMessage('&lt;span style=\"color:red;\"&gt;你都复制了些什么呀，转载要记得加上出处哦~~&lt;/span&gt;', 5000); var seletedText = window.getSelection() if (seletedText.toString().length &lt; 88) &#123; return &#125; addCopyright(e) e.preventDefault() &#125;) function renderTip(template, context) &#123; var tokenReg = /(\\\\)?\\&#123;([^\\&#123;\\&#125;\\\\]+)(\\\\)?\\&#125;/g; return template.replace(tokenReg, function (word, slash1, token, slash2) &#123; if (slash1 || slash2) &#123; return word.replace('\\\\', ''); &#125; var variables = token.replace(/\\s/g, '').split('.'); var currentObject = context; var i, length, variable; for (i = 0, length = variables.length; i &lt; length; ++i) &#123; variable = variables[i]; currentObject = currentObject[variable]; if (currentObject === undefined || currentObject === null) return ''; &#125; return currentObject; &#125;); &#125; String.prototype.renderTip = function (context) &#123; return renderTip(this, context); &#125;; function initTips() &#123; $.ajax(&#123; cache: true, url: `http://localhost:4000/message.json`, dataType: \"json\", success: function (result) &#123; console.log(result); $.each(result.mouseover, function (index, tips) &#123; $(tips.selector).mouseover(function () &#123; var text = tips.text; if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1]; text = text.renderTip(&#123; text: $(this).text() &#125;); showMessage(text, 3000); &#125;); &#125;); $.each(result.click, function (index, tips) &#123; $(tips.selector).click(function () &#123; var text = tips.text; if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1]; text = text.renderTip(&#123; text: $(this).text() &#125;); showMessage(text, 3000); &#125;); &#125;); &#125; &#125;); &#125;// 初始化消息 initTips(); function showMessage(text, timeout) &#123; if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1]; $('.message').stop(); $('.message').html(text).fadeTo(200, 1); timeout = timeout || 5000; hideMessage(timeout); &#125; function hideMessage(timeout) &#123; $('.message').stop().css('opacity', 1); if (timeout === null) timeout = 5000; $('.message').delay(timeout).fadeTo(200, 0); &#125;&#125;)();window.setInterval(showHitokoto, 30000);function showHitokoto() &#123; $.getJSON('https://v1.hitokoto.cn/', function (result) &#123; showMessage(result.hitokoto, 5000); &#125;);&#125;function showHitokoto() &#123; $.getJSON('', function (result) &#123; showMessage(result.hitokoto, 5000); &#125;);&#125;","categories":[{"name":"Hexo之瞎折腾系列","slug":"Hexo之瞎折腾系列","permalink":"https://www.lgzblog.com/categories/Hexo之瞎折腾系列/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.lgzblog.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.lgzblog.com/tags/博客/"}],"author":"卢国峥"},{"title":"jenkins通过ssh发送文件或执行命令","slug":"jenkins通过ssh发送文件或执行命令","date":"2019-09-07T06:40:00.000Z","updated":"2019-09-07T02:45:50.000Z","comments":true,"path":"2019/09/07/jenkins通过ssh发送文件或执行命令/","link":"","permalink":"https://www.lgzblog.com/2019/09/07/jenkins通过ssh发送文件或执行命令/","excerpt":"记录jenkins通过ssh执行命令配置~!","text":"记录jenkins通过ssh执行命令配置~!1.需求:由于使用docker部署的jenkins,在项目构建完成之后,需要调用宿主机的shell脚本把服务启动起来2.在jenkins安装Publish over SSH插件系统管理 &gt; 插件管理 &gt; 可选插件: 搜索Publish over SSH,直接安装即可.3.配置Publish over SSH系统管理 &gt; 系统设置 &gt; Publish over SSH这里直接采用了登录账号和密码直接登录的,没有采用配置密钥的方式.PS:配置完后,可以点击右下角的测试按钮检查是否能连接上,如果成功即配置完成了,失败就检查下登录名和密码吧…4.Publish over SSH使用创建任务的时,在够建步骤中选择通过SSH发送文件或执行命令,","categories":[{"name":"测试服务器搭建记录","slug":"测试服务器搭建记录","permalink":"https://www.lgzblog.com/categories/测试服务器搭建记录/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://www.lgzblog.com/tags/jenkins/"}],"author":"卢国峥"},{"title":"Linux配置LD_LIBRARY_PATH环境变量","slug":"Linux配置LD-LIBRARY-PATH环境变量","date":"2019-09-07T01:50:00.000Z","updated":"2019-09-08T01:23:04.000Z","comments":true,"path":"2019/09/07/Linux配置LD-LIBRARY-PATH环境变量/","link":"","permalink":"https://www.lgzblog.com/2019/09/07/Linux配置LD-LIBRARY-PATH环境变量/","excerpt":"记录Linux配置LD_LIBRARY_PATH环境变量~!","text":"记录Linux配置LD_LIBRARY_PATH环境变量~!项目开发中有用到一些第三方的动态库(so),就需要把.so文件放置某个目录下,然后配置环境变量即可..修改/etc/profile文件.加入以下配置即可.1export LD_LIBRARY_PATH=/home/yanfa_ylcloud_java/solib:$LD_LIBRARY_PATH刷新配置1source /etc/profilePs:刷下配置后发现还是没有效果,需要重新启动项目..修改后:","categories":[{"name":"测试服务器搭建记录","slug":"测试服务器搭建记录","permalink":"https://www.lgzblog.com/categories/测试服务器搭建记录/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lgzblog.com/tags/Linux/"}],"author":"卢国峥"},{"title":"docker部署jenkins","slug":"docker部署jenkins","date":"2019-09-05T01:22:00.000Z","updated":"2019-09-08T01:27:56.000Z","comments":true,"path":"2019/09/05/docker部署jenkins/","link":"","permalink":"https://www.lgzblog.com/2019/09/05/docker部署jenkins/","excerpt":"使用docker部署jenkins,实现流水线部署项目~!jenkins容器地址:https://hub.docker.com/r/jenkins/jenkins","text":"使用docker部署jenkins,实现流水线部署项目~!jenkins容器地址:https://hub.docker.com/r/jenkins/jenkins使用docker部署jenkins,实现流水线部署项目~!jenkins容器地址:https://hub.docker.com/r/jenkins/jenkins1. 直接拉去官方镜像1docker pull jenkins/jenkins2. 启动jenkins1docker run -d -p 8081:8080 --name jenkins --privileged=true -v /home/softs/jenkins:/var/jenkins_home jenkins/jenkins:latest2.1 参数说明:-d: 后台运行容器-p: 把容器8080端口映射到宿主机8081端口,浏览器访问8081端口即可.–name: 容器的别名-v: 数据卷,把容器中的/var/jenkins_home目录映射到宿主机的/home/softs/jenkins`目录上,可以与宿主机共享空间2.2 进入容器获取jenkins初始密码123docker exec -it jenkins /bin/bashcat /var/jenkins_home/secrets/initialAdminPassword3. 配置jenkins系统管理 &gt; 全局工具配置JDK/Maven/Git:这里都是使用自动安装,也可用通过数据卷映射,使用宿主机的配置Ps:自动安装JDK需要通过Oracle等账号下载安装,没有就需要去注册一个..4. 新建任务测试接下来建立一个任务测试源码管理配置构建以及需要执行的命令配置5. 执行构建任务查看控制台:SUCCESS:表示构建成功.","categories":[{"name":"测试服务器搭建记录","slug":"测试服务器搭建记录","permalink":"https://www.lgzblog.com/categories/测试服务器搭建记录/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"},{"name":"jenkins","slug":"jenkins","permalink":"https://www.lgzblog.com/tags/jenkins/"}],"author":"卢国峥"},{"title":"Redis常用配置","slug":"Redis常用配置","date":"2019-09-04T12:46:00.000Z","updated":"2019-09-08T01:33:27.000Z","comments":true,"path":"2019/09/04/Redis常用配置/","link":"","permalink":"https://www.lgzblog.com/2019/09/04/Redis常用配置/","excerpt":"记录redis常用的配置~!把redis安装上去后，接下来我们来了解一下redis的常用配置。Redis的配置文件在redis安装目录中，文件名叫redis.conf","text":"记录redis常用的配置~!把redis安装上去后，接下来我们来了解一下redis的常用配置。Redis的配置文件在redis安装目录中，文件名叫redis.conf我们已经把redis安装上去了，接下来我们来了解一下redis的常用配置。Redis的配置文件在redis安装目录中，文件名叫redis.conf1.端口:portport：服务的端口号，默认为63792.后台运行:daemonizedaemonize：后台运行，值为yes | no 默认为no3.密码:requirepassrequirepass：密码，默认是没有密码Ps:登录有密码的redis123redis-cli -p 6379 -a &lt;密码&gt;auth &lt;密码&gt;也可用登录redis命令设置密码,但这是一次性的,重启后失效12345// 设置密码config set requirepass test123// 获取密码config get requirepass4.保护模式:protected-modeprotected-mode：保护模式，值为es | no默认是yes，不能远程访问该redis服务，如果需要远程访问，则该为no。5.绑定的IP地址bind：绑定的IP地址，默认是绑定本机地址127.0.0.1，如果需要其他IP能访问到该redis服务，则在这个属性添加IP地址，或者直接把该属性注释掉，这样所有的IP地址都可以访问","categories":[{"name":"测试服务器搭建记录","slug":"测试服务器搭建记录","permalink":"https://www.lgzblog.com/categories/测试服务器搭建记录/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://www.lgzblog.com/tags/redis/"}],"author":"卢国峥"},{"title":"Redis安装","slug":"Redis安装","date":"2019-09-04T09:35:00.000Z","updated":"2019-09-08T01:38:49.000Z","comments":true,"path":"2019/09/04/Redis安装/","link":"","permalink":"https://www.lgzblog.com/2019/09/04/Redis安装/","excerpt":"Linux安装redis步骤记录~!","text":"Linux安装redis步骤记录~!1.安装gcc1yum install -y gcc2.下载所需的 redis 安装包，并上传至服务器1/home/softs/redis3.解压安装包1tar -zxvf redis.x.tar.gz4.进入 redis 根目录,执行编译与安装1make &amp;&amp; make install5.进入src目录，启动 redis 服务器1redis-server6.注册redis服务并设置后台运行1、修改redis.conf配置文件中的daemonize为yes2、找到 redis 根目录下面 utils 中的 redis_init_script 文件，并将其复制到 /etc/init.d/ 后重命名为 redis1cp /home/softs/reddis/utils/redis_init_script /etc/init.d/redis3、修改 /etc/init.d/redis 配置，将相关的 redis 路径已经配置文件路径修改为你自己的 redis 所在位置的路径即可。4、此时就可以后台的方式运行redis了，在任意地方执行Linux服务命令，后台运行redis服务：开启服务：service redis start关闭服务：service redis stopPS: （注意：如果redis设置了密码，那么需要在/etc/init.d/redis这个脚本文件stop项，把$CLIEXEC -P $REDISPORT shutdown这行配置添加一个密码：-a YouPassword）,否则redis将不能正常关闭。7. Redis客户端测试进入src目录，运行redis的客户端程序:redis-cli参数：-h 主机ip（不写的话默认本机）-p 端口（不写的话默认6379）-a 密码8. 开启远程连接1、把redis.conf配置文件的protected-mode属性修改为no，关闭redis的包含模式。2、把redis.conf配置文件的bind属性注释掉，让所有远程的IP都可以访问到该redis的服务。3、由于开启了远程连接，所以有必要设置redis的访问密码，不然的话安全性太低，在redis.conf配置文件中模式是没有密码这行配置的，需要添加密码的话则新增该属性：requirepass，属性值为密码字符串。4、开启6379网络端口，并重新加载防火墙规则。","categories":[{"name":"测试服务器搭建记录","slug":"测试服务器搭建记录","permalink":"https://www.lgzblog.com/categories/测试服务器搭建记录/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://www.lgzblog.com/tags/redis/"}],"author":"卢国峥"},{"title":"LocalDate操作时间","slug":"LocalDate操作时间","date":"2019-08-10T03:21:00.000Z","updated":"2019-10-12T09:25:58.000Z","comments":true,"path":"2019/08/10/LocalDate操作时间/","link":"","permalink":"https://www.lgzblog.com/2019/08/10/LocalDate操作时间/","excerpt":"记录工具类API👇: 字符串转LocalDate 获取连续时间集合 获取连续时间集合12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";","text":"记录工具类API👇: 字符串转LocalDate 获取连续时间集合 获取连续时间集合12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";12// 默认的时间格式public static final String DEFUALT_SHOT_TIME_FORMAT = \"yyyy-MM-dd\";1. 字符串转LocalDate123456789/** * * @param time 时间yyyy-MM-dd * @return */ public static LocalDateTime stringToLocalDate(String time) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); return LocalDateTime.parse(time, df); &#125;2. 两个时间相差多少天123456789101112131415/** * 获取两个时间相差多少天 * * @param dates * @return */ public static long getDiffDays(String[] dates) &#123; if (dates.length &lt; 2) &#123; return 1; &#125; DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate begin = LocalDate.parse(dates[0], fmt); LocalDate end = LocalDate.parse(dates[1], fmt); return end.toEpochDay() - begin.toEpochDay() + 1; &#125;3. 获取连续时间集合1234567891011121314151617/** * 数据填充 * 可操作: 天/周/月/年 * @param time 间隔天数 * @param begin 开始时间 * @return */ public static List&lt;String&gt; getRangeIncres2(long time, String begin) &#123; List&lt;String&gt; list = Lists.newArrayList(); DateTimeFormatter fmt = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\"); LocalDate localDate = LocalDate.parse(begin, fmt); for (int i = 0; i &lt; time; i++) &#123; list.add(localDate.plusDays(i).toString()); &#125; return list; &#125;4. 计算时间差:xx天xx小时xx分钟123456789101112131415161718192021/** * 计算时间差:xx天xx小时xx分钟 * @param endDate 结束时间 * @param beginDate 开始时间 * @return */ public static List&lt;Long&gt; getDatePoor(Date endDate, Date beginDate) &#123; long nd = 1000 * 24 * 60 * 60;//每天毫秒数 long nh = 1000 * 60 * 60;//每小时毫秒数 long nm = 1000 * 60;//每分钟毫秒数 long diff = endDate.getTime() - beginDate.getTime(); // 获得两个时间的毫秒时间差异 long day = diff / nd; // 计算差多少天 long hour = diff % nd / nh; // 计算差多少小时 long min = diff % nd % nh / nm; // 计算差多少分钟 System.out.println(day + \"天\" + hour + \"小时\" + min + \"分钟\"); List&lt;Long&gt; list = new ArrayList&lt;&gt;(); list.add(day); list.add(hour); list.add(min); return list; &#125;","categories":[{"name":"工具类收藏","slug":"工具类收藏","permalink":"https://www.lgzblog.com/categories/工具类收藏/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"}],"author":"卢国峥"},{"title":"ElasticSearch 中boolQueryBuilder的使用","slug":"ElasticSearch-中boolQueryBuilder的使用","date":"2019-08-08T01:29:00.000Z","updated":"2019-08-21T03:27:46.000Z","comments":true,"path":"2019/08/08/ElasticSearch-中boolQueryBuilder的使用/","link":"","permalink":"https://www.lgzblog.com/2019/08/08/ElasticSearch-中boolQueryBuilder的使用/","excerpt":"Bool查询现在包括四种子句，must，filter,should,must_not.","text":"Bool查询现在包括四种子句，must，filter,should,must_not.转载自:https://blog.csdn.net/metheir/article/details/850803341. 为什么filter会快？看上面的流程图就能很明显的看到，filter与query还是有很大的区别的。比如，query的时候，会先比较查询条件，然后计算分值，最后返回文档结果；而filter则是先判断是否满足查询条件，如果不满足，会缓存查询过程（记录该文档不满足结果）；满足的话，就直接缓存结果。综上所述，filter快在两个方面：1 对结果进行缓存2 避免计算分值2. bool查询的使用Bool查询对应Lucene中的BooleanQuery,它由一个或者多个子句组成,每个子句都有特定的类型must返回的文档必须满足must子句的条件,并且参与计算分值filter返回的文档必须满足filter子句的条件,但是不会像must一样,参与计算分值should返回的文档可能满足should子句的条件.在一个bool查询中,如果没有must或者filter,有一个或者多个should子句,那么只要满足一个就可以返回.minimum_should_match参数定义了至少满足几个子句.must_not返回的文档必须不满足定义的条件如果一个查询既有filter又有should,那么至少包含一个should子句.bool查询也支持禁用协同计分选项disable_coord.一般计算分值的因素取决于所有的查询条件.bool查询也是采用more_matches_is_better的机制,因此满足must和should子句的文档将会合并起来计算分值.3.JavaAPI使用1234567891011121314151617@Testpublic void searchApi2() throws IOException &#123; SearchRequest searchRequest = new SearchRequest(\"item\"); SearchSourceBuilder sourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); // 必须匹配条件 boolQueryBuilder.must(QueryBuilders.matchQuery(\"scompCode\", \"G0000001\")); // 模糊查询 boolQueryBuilder.filter(QueryBuilders.wildcardQuery(\"itemDesc\", \"*手机*\")); // 范围查询 from:相当于闭区间; gt:相当于开区间(&gt;) gte:相当于闭区间 (&gt;=) lt:开区间(&lt;) lte:闭区间 (&lt;=) boolQueryBuilder.filter(QueryBuilders.rangeQuery(\"itemPrice\").from(4500).to(8899)); sourceBuilder.query(boolQueryBuilder); searchRequest.source(sourceBuilder); SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT); logger.info(\"查询数据:&#123;&#125;\", Arrays.toString(searchResponse.getHits().getHits()));&#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"},{"name":"转载","slug":"转载","permalink":"https://www.lgzblog.com/tags/转载/"}],"author":"卢国峥"},{"title":"ElasticSearch API","slug":"ElasticSearch-API","date":"2019-08-07T07:58:00.000Z","updated":"2019-08-21T03:25:51.000Z","comments":true,"path":"2019/08/07/ElasticSearch-API/","link":"","permalink":"https://www.lgzblog.com/2019/08/07/ElasticSearch-API/","excerpt":"ElasticSearch java API应用https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.0/java-rest-high-document-index.html","text":"ElasticSearch java API应用https://www.elastic.co/guide/en/elasticsearch/client/java-rest/7.0/java-rest-high-document-index.html1. 创建索引12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ElasticsearchRestClient &#123; private static final Logger logger = LogManager.getLogger(ElasticsearchRestClient.class); @Before public void beforGet() &#123; client = new RestHighLevelClient( RestClient.builder(new HttpHost(\"106.14.116.156\", 9200, \"http\"))); logger.info(\"ES客户端初始化\"); &#125; @After public void afterGet() throws IOException &#123; client.close(); logger.info(\"关闭ES连接\"); &#125; /** * 创建索引 * * @throws IOException */ @Test public void createIndex() throws IOException &#123; GetIndexRequest getIndexRequest = new GetIndexRequest(\"item\"); // 索引是否存在 boolean exists = client.indices().exists(getIndexRequest, RequestOptions.DEFAULT); if (!exists) &#123; CreateIndexRequest request = new CreateIndexRequest(\"item\"); XContentBuilder builder = XContentFactory.jsonBuilder(); builder.startObject(); &#123; // 固定格式 builder.startObject(\"properties\"); &#123; // itemCode字段 builder.startObject(\"itemCode\"); &#123; // 字段属性 builder.field(\"type\", \"keyword\"); &#125; builder.endObject(); // itemDesc字段 builder.startObject(\"itemDesc\"); &#123; // 字段属性 builder.field(\"type\", \"keyword\"); &#125; builder.endObject(); &#125; builder.endObject(); &#125; builder.endObject(); request.mapping(\"doc\", builder); CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT); logger.info(\"创建索引结果:&#123;&#125;\", createIndexResponse.isAcknowledged()); &#125; else &#123; logger.info(\"[employee]索引已经存在\"); &#125; &#125;&#125;2.新增数据12345678910111213141516171819202122/** * 新增数据 * * @param client * @param index 索引 * @param id 文档id * @param jsonMap 需要建立索引的数据 key:字段,value:值 */ public static void index(RestHighLevelClient client, String index,String id, Map&lt;String, Object&gt; jsonMap) &#123; IndexRequest indexRequest = new IndexRequest(index); // id为空则自动生成id if (StringUtil.isNotEmpty(id)) &#123; indexRequest.id(id); &#125; indexRequest.source(jsonMap); try &#123; IndexResponse response = client.index(indexRequest, RequestOptions.DEFAULT); logger.info(\"索引结果:&#123;&#125;\", response.status().getStatus()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;3.删除数据12345678910111213141516171819/** * 删除数据 * * @param client * @param index 索引名称 * @param id 文档id */ @Test public static void delete(RestHighLevelClient client, String index,String id) &#123; DeleteRequest request = new DeleteRequest(index, id); DeleteResponse deleteResponse = null; try &#123; deleteResponse = client.delete(request, RequestOptions.DEFAULT); &#125; catch (Exception e) &#123; e.printStackTrace(); logger.warn(\"ES删除异常信息:&#123;&#125;\",e.getMessage()); &#125; logger.warn(\"删除结果:&#123;&#125;\",deleteResponse.status().getStatus()); &#125;4.更新数据12345678910111213141516171819/** * * @param client * @param index 索引名称 * @param id 文档id */ @Test public static void update(RestHighLevelClient client, String index,String id,Map&lt;String,Object&gt; map) &#123; UpdateRequest request = new UpdateRequest(index,id); request.doc(map); UpdateResponse updateResponse = null; try &#123; updateResponse = client.update( request, RequestOptions.DEFAULT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; logger.warn(\"ES更新结果:&#123;&#125;\",updateResponse.getResult()); &#125;","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"远程调试springboot项目","slug":"远程调试springboot项目","date":"2019-07-27T03:27:00.000Z","updated":"2019-07-27T05:41:09.000Z","comments":true,"path":"2019/07/27/远程调试springboot项目/","link":"","permalink":"https://www.lgzblog.com/2019/07/27/远程调试springboot项目/","excerpt":"IDEA远程调试项目~!","text":"IDEA远程调试项目~!1. 配置远程①②③2. 启动项目1nohup java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8888 &lt;jar包名称&gt;3. 远程debug开始4. 连接成功在本地打断点,访问服务器接口时,在本地即可实时调试了","categories":[{"name":"工具配置相关","slug":"工具配置相关","permalink":"https://www.lgzblog.com/categories/工具配置相关/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"}],"author":"卢国峥"},{"title":"阿里CodeGIT账号密码获取方法","slug":"阿里CodeGIT账号密码获取方法","date":"2019-07-22T02:44:00.000Z","updated":"2019-08-21T03:31:05.000Z","comments":true,"path":"2019/07/22/阿里CodeGIT账号密码获取方法/","link":"","permalink":"https://www.lgzblog.com/2019/07/22/阿里CodeGIT账号密码获取方法/","excerpt":"输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）","text":"输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）输入https://code.aliyun.com -&gt; 设置 -&gt; 个人设置 Username （GIT账号）输入https://code.aliyun.com/profile/password/edit -&gt; 忘记密码 –&gt;到邮箱重置密码 （GIT密码）","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lgzblog.com/categories/工具使用/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.lgzblog.com/tags/git/"}],"author":"卢国峥"},{"title":"Alibaba Cloud Toolkit插件使用","slug":"Alibaba-Cloud-Toolkit插件使用","date":"2019-07-22T02:22:00.000Z","updated":"2019-07-22T02:43:15.000Z","comments":true,"path":"2019/07/22/Alibaba-Cloud-Toolkit插件使用/","link":"","permalink":"https://www.lgzblog.com/2019/07/22/Alibaba-Cloud-Toolkit插件使用/","excerpt":"Alibaba Cloud Toolkit 工具一键部署本地jar包","text":"Alibaba Cloud Toolkit 工具一键部署本地jar包1.安装 Alibaba Cloud Toolkit直接在IDEA插件中搜索安装即可2.添加远程服务器3. 配置打包部署项目","categories":[{"name":"插件使用系列","slug":"插件使用系列","permalink":"https://www.lgzblog.com/categories/插件使用系列/"}],"tags":[{"name":"插件","slug":"插件","permalink":"https://www.lgzblog.com/tags/插件/"}],"author":"卢国峥"},{"title":"时间转cron表达式","slug":"时间转cron表达式","date":"2019-07-15T01:50:00.000Z","updated":"2019-07-15T01:53:13.000Z","comments":true,"path":"2019/07/15/时间转cron表达式/","link":"","permalink":"https://www.lgzblog.com/2019/07/15/时间转cron表达式/","excerpt":"记录一个时间转cron表达式的工具类","text":"记录一个时间转cron表达式的工具类DateToCronUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697/** * @author LuGuoZheng * @date 2019/7/12 13:45 * @Version 3.0 * @description */public class DateToCronUtil &#123; private static final Logger logger = LoggerFactory.getLogger(DateToCronUtil.class); public static final String DEFUALT_LONG_TIME_FORMAT = \"yyyy-MM-dd HH:mm:ss\"; private final static String H = \"H\"; private final static String D = \"D\"; private final static String W = \"W\"; private final static String M = \"M\"; private final static String Q = \"Q\"; private final static String Y = \"Y\"; /** * 每小时 */ private final static String DEFAULT_H_CRON = \"0 H * * * ? *\"; /** * 每天 */ private final static String DEFAULT_D_CRON = \"0 H D * * ? *\"; /** * 每周 */ private final static String DEFAULT_W_CRON = \"0 H D ? * W\"; /** * 每月 */ private final static String DEFAULT_M_CRON = \"0 H D M * ? *\"; /** * 每季度 */ private final static String DEFAULT_Q_CRON = \"0 H D M 1/3 ? *\"; /** * 每年 */ private final static String DEFAULT_Y_CRON = \"0 H D M Y ? *\"; public static LocalDateTime stringToLocalDate(String time) &#123; DateTimeFormatter df = DateTimeFormatter.ofPattern(DEFUALT_LONG_TIME_FORMAT); return LocalDateTime.parse(time, df); &#125; /** * @param time 时间 yyyy-MM-dd HH:mm * @param timeType 类型:H-&gt;小时,D-&gt;天,W-&gt;周,M-&gt;月,Q-&gt;季度,Y-&gt;每年 * @return */ public static String getCron(String time, String timeType) &#123; LocalDateTime localDateTime = stringToLocalDate(time); logger.info(\"localDateTime:&#123;&#125;\", localDateTime); if (DateToCronUtil.H.equals(timeType)) &#123; return DEFAULT_H_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\"); &#125; else if (DateToCronUtil.D.equals(timeType)) &#123; return DEFAULT_D_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\"); &#125; else if (DateToCronUtil.W.equals(timeType)) &#123; return DEFAULT_W_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.W, (localDateTime.get(ChronoField.DAY_OF_WEEK) == 7 ? 1 : localDateTime.get(ChronoField.DAY_OF_WEEK) + 1) + \"\"); &#125; else if (DateToCronUtil.M.equals(timeType)) &#123; return DEFAULT_M_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.M, localDateTime.get(ChronoField.MONTH_OF_YEAR) + \"\"); &#125; else if (DateToCronUtil.Q.equals(timeType)) &#123; return DEFAULT_Q_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.DAY_OF_MONTH) + \"\"); &#125; else if (DateToCronUtil.Y.equals(timeType)) &#123; return DEFAULT_Y_CRON.replace(DateToCronUtil.H, localDateTime.get(ChronoField.MINUTE_OF_HOUR) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.HOUR_OF_DAY) + \"\") .replace(DateToCronUtil.D, localDateTime.get(ChronoField.DAY_OF_MONTH) + \"\") .replace(DateToCronUtil.Y, localDateTime.get(ChronoField.MONTH_OF_YEAR) + \"\"); &#125; return DEFAULT_D_CRON; &#125; @Test public void get() &#123;// DateTimeFormatter df = DateTimeFormatter.ofPattern(DEFUALT_LONG_TIME_FORMAT);// LocalDateTime now = LocalDateTime.parse(\"2019-07-11 14:22\",df);// System.out.println(now);// System.out.println(now.get(ChronoField.MINUTE_OF_HOUR)); String d = getCron(\"2019-07-16 14:25:12\", \"W\"); System.out.println(d); &#125;&#125;","categories":[{"name":"工具类收藏","slug":"工具类收藏","permalink":"https://www.lgzblog.com/categories/工具类收藏/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"}],"author":"卢国峥"},{"title":"ElasticSearch 9200端口与9300端口的区别","slug":"ElasticSearch-JAVA客户端-端口","date":"2019-07-05T16:24:00.000Z","updated":"2019-07-05T16:33:16.000Z","comments":true,"path":"2019/07/06/ElasticSearch-JAVA客户端-端口/","link":"","permalink":"https://www.lgzblog.com/2019/07/06/ElasticSearch-JAVA客户端-端口/","excerpt":"ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.","text":"ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.ES启动监听两个端口:9300和92009300端口9300是Tcp协议端口:通过Tcp协议通讯,ES集群之间是通过9300进行通讯,java客户端(TransportClient)的方式也是以Tcp协议在9300端口上与集群进行通讯.9200端口9200是Http协议端口:主要用于外部通讯,外部使用RESTful接口进行访问.","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"}],"author":"卢国峥"},{"title":"Docker 简单部署 ElasticSearch","slug":"Docker-简单部署-ElasticSearch","date":"2019-07-02T03:56:00.000Z","updated":"2019-07-05T16:37:17.000Z","comments":true,"path":"2019/07/02/Docker-简单部署-ElasticSearch/","link":"","permalink":"https://www.lgzblog.com/2019/07/02/Docker-简单部署-ElasticSearch/","excerpt":"ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据","text":"ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据ElasticSearch官网API一、ElasticSearch是什么?Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它：分布式的实时文件存储，每个字段都被索引并可被搜索分布式的实时分析搜索引擎可以扩展到上百台服务器，处理PB级结构化或非结构化数据二、Docker 部署 ElasticSearch2.1 拉取镜像1docker pull docker.elastic.co/elasticsearch/elasticsearch:7.0.02.2 运行容器ElasticSearch的默认端口是9200，我们把宿主环境9200端口映射到Docker容器中的9200端口，就可以访问到Docker容器中的ElasticSearch服务了，同时我们把这个容器命名为es。1docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; &lt;容器ID&gt;2.3 配置跨域2.3.1 进入容器由于要进行配置，因此需要进入容器当中修改相应的配置信息。1docker exec -it es /bin/bash2.3.2 进行配置123456789101112131415161718192021# 显示文件ls结果如下：LICENSE.txt README.textile config lib modulesNOTICE.txt bin data logs plugins# 进入配置文件夹cd config# 显示文件ls结果如下：elasticsearch.keystore ingest-geoip log4j2.properties roles.yml users_roleselasticsearch.yml jvm.options role_mapping.yml users# 修改配置文件vi elasticsearch.yml# 加入跨域配置http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;2.3 重启容器由于修改了配置，因此需要重启ElasticSearch容器。1docker restart es展示如下：三、Docker 部署 ElasticSearch-Head为什么要安装ElasticSearch-Head呢，原因是需要有一个管理界面进行查看ElasticSearch相关信息3.1 拉取镜像1docker pull mobz/elasticsearch-head:53.2 运行容器1docker run -d --name es_admin -p 9100:9100 mobz/elasticsearch-head:5展示如下：这样，我们就完成了用Docker提供Elasticsearch服务，而不污染宿主机环境了，这样还有一个好处，如果想同时启动多个不同版本的Elastcsearch或者其他服务，Docker也是一个理想的解决方案。原文出处:https://www.cnblogs.com/jianxuanbing/p/9410800.html","categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","permalink":"https://www.lgzblog.com/categories/ElasticSearch系列/"}],"tags":[{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"https://www.lgzblog.com/tags/ElasticSearch/"},{"name":"转载","slug":"转载","permalink":"https://www.lgzblog.com/tags/转载/"}],"author":"卢国峥"},{"title":"dubbo隐式参数丢失问题","slug":"dubbo隐式参数丢失问题","date":"2019-06-29T06:18:00.000Z","updated":"2019-06-29T07:48:38.000Z","comments":true,"path":"2019/06/29/dubbo隐式参数丢失问题/","link":"","permalink":"https://www.lgzblog.com/2019/06/29/dubbo隐式参数丢失问题/","excerpt":"记录在消费端连续调用两次远程服务导致隐式参数丢失问题~!","text":"记录在消费端连续调用两次远程服务导致隐式参数丢失问题~!演示代码controller层12345678910111213141516@Controller@RequestMapping(\"/test\")public class TestController &#123; @Reference private ICarService iCarService; @RequestMapping(\"/test\") @ResponseBody public String test()&#123; // 传递参数 RpcContext.getContext().setAttachment(\"TOKEN\",\"测试隐士参数传递\"); iCarService.test(); return \"参数\"; &#125;&#125;服务层123456789101112131415161718192021@Service(retries = -1)public class CeshiServiceImpl implements ICeshiService &#123; private static final Logger logger = LoggerFactory.getLogger(CeshiServiceImpl.class); @Reference private ICarService iCarService; @Reference private IUserInfoService iUserInfoService; @Override public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"token信息:&#123;&#125;\", token); // 第一次调用rpc服务 iCarService.test(); logger.info(\"token信息:&#123;&#125;\", RpcContext.getContext().getAttachment(\"TOKEN\")); // 第二次调用rpc服务 iUserInfoService.test(); &#125;&#125;ICarServiceImpl12345678910@Service(retries = -1)public class CarServiceImpl implements ICarService &#123; private static final Logger logger = LoggerFactory.getLogger(CarServiceImpl.class); public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"carService:&#123;&#125;\",token); &#125;&#125;userInfoServiceImpl1234567891011@Service(retries = -1)@Transactionalpublic class UserInfoServiceImpl implements IUserInfoService &#123; private static final Logger logger = LoggerFactory.getLogger(UserInfoServiceImpl.class); public void test() &#123; String token = RpcContext.getContext().getAttachment(\"TOKEN\"); logger.info(\"userInfoService:&#123;&#125;\",token); &#125; &#125;打印结果ceshiService结果ICarServiceImpl结果userInfoServiceImpl结果源码12345678910111213141516171819202122@Activate(group = Constants.CONSUMER, order = -10000)public class ConsumerContextFilter implements Filter &#123; public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123; RpcContext.getContext() .setInvoker(invoker) .setInvocation(invocation) .setLocalAddress(NetUtils.getLocalHost(), 0) .setRemoteAddress(invoker.getUrl().getHost(), invoker.getUrl().getPort()); if (invocation instanceof RpcInvocation) &#123; ((RpcInvocation) invocation).setInvoker(invoker); &#125; try &#123; return invoker.invoke(invocation); &#125; finally &#123; // 清空隐式参数 RpcContext.getContext().clearAttachments(); &#125; &#125;&#125;消费端在执行Rpc调用之前，经过Filter处理, 会将信息写入RpcContex,而且在每次调用rpc后都会把隐式参数清空,所以在第二次调用rpc就无法拿到之前的隐式参数了拓展Filter何时进行url过滤filter（过滤器）作用于在intreceptor(拦截器)之前，不像intreceptor一样依赖于springmvc框架，只需要依赖于serverlet。","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"https://www.lgzblog.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://www.lgzblog.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"docker基本命令使用","slug":"docker基本命令使用","date":"2019-06-24T03:22:00.000Z","updated":"2020-04-21T09:48:15.660Z","comments":true,"path":"2019/06/24/docker基本命令使用/","link":"","permalink":"https://www.lgzblog.com/2019/06/24/docker基本命令使用/","excerpt":"记录docker常用命令","text":"记录docker常用命令1. 查看本地镜像列表1docker images2. 查看运行中的容器1docker ps3. 查看所有容器(包括未运行的)1docker ps -a4. 删除镜像1docker rmi &lt;镜像ID&gt;5. run命令docker run [参数] [镜像id] | [镜像名]:[镜像标签] [命令]-i 表示容器的输入终端保持打开,不直接关闭-t 表示开启一个虚拟终端, 绑定到标准输入上-d 表示让该容器在后台运行–name 给该容器起一个容器名，如果没有此参数，则有一个默认的容器名–rm 停止该容器时，把容器删除掉6. 使用镜像运行容器1docker run -it --name &lt;容器名称&gt; -d -p &lt;port:port&gt; &lt;镜像ID&gt;7. 启动容器1docker start &lt;容器ID&gt;8. 停止容器1docker stop &lt;容器ID&gt;9. 删除容器1docker rm &lt;容器ID&gt;10. 查看docker的所有容器运行状态1docker stats11. 进入容器里面1docker exec -it &lt;容器ID&gt; /bin/bash12. 查看容器运行日志(类似 tail -f 命令)1docker logs -f &lt;容器ID/名称&gt;13. 构建镜像进入存放dockerfile目录,执行构建命令1docker build -t [镜像名]:[镜像标签] [存放dockerfile的目录]14.修改镜像名称和标签1docker tag [镜像名]:[镜像标签] [新镜像名]:[新镜像标签]15.查看docker的所有容器运行状态1docker stats15.获取容器的详细信息1docker inspect -f &#123;&#123;.State.Pid&#125;&#125; 54ada6028aa9","categories":[{"name":"docker容器系列","slug":"docker容器系列","permalink":"https://www.lgzblog.com/categories/docker容器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"}],"author":"卢国峥"},{"title":"使用 JConsole 监控 springboot 项目","slug":"使用-JConsole-监控-springboot-项目","date":"2019-06-24T03:07:00.000Z","updated":"2019-06-24T03:16:22.000Z","comments":true,"path":"2019/06/24/使用-JConsole-监控-springboot-项目/","link":"","permalink":"https://www.lgzblog.com/2019/06/24/使用-JConsole-监控-springboot-项目/","excerpt":"JConsole 使用记录~!","text":"JConsole 使用记录~!添加启动参数1234567nohup java -jar -Djava.rmi.server.hostname=x.x.x.x # 服务ip-Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 # 端口(不能与服务端口冲突)-Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Xms200m -Xmx200m ylcloud-item-service-0.0.1-SNAPSHOT.jar &gt; /pro/test/home/yanfa/nohup_item.out &amp; 2&gt;&amp;1 &amp;启动JConsole直接在windows命令窗口输入JConsole选择远程进程输入对应的ip:port即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lgzblog.com/categories/工具使用/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"}],"author":"卢国峥"},{"title":"dubbo重试机制","slug":"Dubbo重试机制","date":"2019-06-15T06:21:00.000Z","updated":"2019-06-24T03:21:54.000Z","comments":true,"path":"2019/06/15/Dubbo重试机制/","link":"","permalink":"https://www.lgzblog.com/2019/06/15/Dubbo重试机制/","excerpt":"DUBBO中文官方文档记录Dubbo重试机制配置~!","text":"DUBBO中文官方文档记录Dubbo重试机制配置~!DUBBO中文官方文档默认重试次数: 2在官方文档中有介绍到dubbo的重试次数默认是2属性对应URL参数类型是否必填缺省值作用描述兼容性retriesretriesint可选2性能调优远程服务调用重试次数，不包括第一次调用，不需要重试请设为02.0.0以上版本修改重试次数duboo-provider.xml配置方式: 在dubbo:service配置retries参数123&lt;!--常用菜单推荐--&gt;&lt;dubbo:service ref=\"userMenuClickFacade\" interface=\"com.ylcloud.user.facade.UserMenuClickFacade\" retries=\"1\"/&gt;&lt;bean id=\"userMenuClickFacade\" class=\"com.ylcloud.user.facade.impl.UserMenuClickFacadeImpl\"/&gt;使用注解如果使用的@Service配置重试次数,不设置retries参数,那么该参数默认值是0,但是不管显示配置retries为0,还是不显示设置,0都是使用dubbo默认的重试次数如果要配置重试次数为0,只有把retries小于0才会起作用如果使用@Reference引用服务时配置了retries,重试次数以改次数为准只有显示设置retries大于或等于1才会起作用dubbo相关代码(dubbo版本:2.6.1)package com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker;1234567891011public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123; List&lt;Invoker&lt;T&gt;&gt; copyinvokers = invokers; checkInvokers(copyinvokers, invocation); // len:最多调用次数--&gt; 重试次数 + 1 int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1; // 控制至少调用一次:即重试次数为 0 if (len &lt;= 0) &#123; len = 1; &#125; /** 部分源码省略**/&#125;dubbo注册服务相关代码package com.alibaba.dubbo.config.AbstractConfig;123456789101112131415protected void appendAnnotation(Class&lt;?&gt; annotationClass, Object annotation) &#123; /** 省略部分代码 **/ // 获取直接配置的数据 Object value = method.invoke(annotation, new Object[0]); // 如果不为空并且不等于默认值,则注册url中 if (value != null &amp;&amp; !value.equals(method.getDefaultValue())) &#123; /** 省略部分代码 **/ &#125; /** 省略部分代码 **/ &#125;所以如果使用注解配置重试次数,如果配置的是默认值,则不会注册到url中,会使用dubbo默认的值","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"https://www.lgzblog.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://www.lgzblog.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"Nginx+ffmpeg搭建推流服务器","slug":"Nginx-ffmpeg搭建推流服务器","date":"2019-06-14T07:23:00.000Z","updated":"2019-06-14T08:19:25.000Z","comments":true,"path":"2019/06/14/Nginx-ffmpeg搭建推流服务器/","link":"","permalink":"https://www.lgzblog.com/2019/06/14/Nginx-ffmpeg搭建推流服务器/","excerpt":"环境👇:CentOS7搭建推流服务器~!","text":"环境👇:CentOS7搭建推流服务器~!安装Nginx(忽略)略直接进入到Nginx的解压目录// 参考:这是我目录1cd /usr/local/softs/nginx-1.10.1目录下面的内容:下载nginx-rtmp-module,并解压123wget https://github.com/arut/nginx-rtmp-module/archive/master.zipunzip master.zip先备份Nginx(稳点来)1cp objs/nginx /usr/local/nginx/sbin/nginx重新配置Nginx123./configure --with-http_ssl_module --add-module=/usr/local/softs/nginx-1.10.1/nginx-rtmp-module-mastermakePS: 用make,不要使用make install,不然会覆盖已经添加的模块(网上是这么说的,但是好像没有效果,我之前装了ssl模块的,直接就给我覆盖掉了)因为我之前就加了个ssl模块,所有我直接在配置上加上了,不过之前也有备份将新的nginx覆盖旧安装目录1cp objs/nginx /usr/local/nginx/sbin/nginx修改Nginx配置文件(nginx.conf)123456789101112rtmp &#123; #RTMP服务 server &#123; listen 1935; #//服务端口 chunk_size 4096; #//数据传输块的大小 application vod &#123; play /opt/video; #//视频文件存放位置。 &#125; application live&#123; #直播 live on; &#125; &#125;&#125;PS: rtmp是一个单独的模块,不要放在http里面重启Nginx123cd /usr/local/nginx/sbin./nginx -s reload安装EPEL Release，因为安装需要使用其他的repo源，所以需要EPEL支持1yum install -y epel-release安装完成之后，可以查看是否安装成功1yum repolist安装nux-dextop 源1rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-1.el7.nux.noarch.rpm安装ffmpeg1yum install -y ffmpeg安装完成后检查ffmpeg 版本1ffmpeg -version测试1ffmpeg -re -i lgz.mp4 -c copy -f flv rtmp://localhost:1935/live/film使用VLC1rtmp://&#123;你的服务IP&#125;:1935/live/film","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.lgzblog.com/tags/Nginx/"},{"name":"推流服务器","slug":"推流服务器","permalink":"https://www.lgzblog.com/tags/推流服务器/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://www.lgzblog.com/tags/ffmpeg/"}],"author":"卢国峥"},{"title":"结束Windows占用端口进程","slug":"结束Windows占用端口进程","date":"2019-06-12T06:46:00.000Z","updated":"2019-11-08T03:19:14.000Z","comments":true,"path":"2019/06/12/结束Windows占用端口进程/","link":"","permalink":"https://www.lgzblog.com/2019/06/12/结束Windows占用端口进程/","excerpt":"netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80tasklist | findstr 9268taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程","text":"netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80tasklist | findstr 9268taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程netstat -ano | findstr 80 //列出进程极其占用的端口，且包含 80tasklist | findstr 9268taskkill -PID &lt;进程号&gt; -F //强制关闭某个进程","categories":[],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.lgzblog.com/tags/Windows/"}],"author":"卢国峥"},{"title":"SQL函数使用记录","slug":"QL函数使用记录","date":"2019-06-06T06:19:00.000Z","updated":"2019-06-15T06:47:12.000Z","comments":true,"path":"2019/06/06/QL函数使用记录/","link":"","permalink":"https://www.lgzblog.com/2019/06/06/QL函数使用记录/","excerpt":"sql函数使用记录~!","text":"sql函数使用记录~!SUM函数中使用case统计t1.groupNumber大于2的数量12345678SELECT IF(SUM(case when t1.groupNumber &gt; 2 then 1 else 0 end) / COUNT(t1.groupNumber),SUM(case when t1.groupNumber &gt; 2 then 1 else 0 end) / COUNT(t1.groupNumber),0) AS fgl FROM (SELECT COUNT(visitor_code) groupNumber FROM sales_order WHERE scomp_code = 'G0000001' GROUP BY visitor_code) t1;格式化日期分组查询函数描述DATE_FORMAT(creater_time,’%Y-%m’)订货日期(日)DATE_FORMAT(creater_time,’%Y-%m-%d’)订货日期(月)1SELECT COUNT(1),DATE_FORMAT(creater_time,'%Y-%m-%d') FROM patrolshop_plan GROUP BY DATE_FORMAT(creater_time,'%Y-%m-%d')日效果:月效果:","categories":[{"name":"MySQL数据库系列","slug":"MySQL数据库系列","permalink":"https://www.lgzblog.com/categories/MySQL数据库系列/"}],"tags":[{"name":"SQL函数","slug":"SQL函数","permalink":"https://www.lgzblog.com/tags/SQL函数/"}],"author":"卢国峥"},{"title":"xml文件注释注意事项","slug":"xml文件注释注意事项","date":"2019-06-06T05:43:00.000Z","updated":"2019-06-06T05:50:58.000Z","comments":true,"path":"2019/06/06/xml文件注释注意事项/","link":"","permalink":"https://www.lgzblog.com/2019/06/06/xml文件注释注意事项/","excerpt":"记录一个调试中偶然碰到的问题~!在mapper.xml文件中注释语句必须使用&lt;!-- --&gt;","text":"记录一个调试中偶然碰到的问题~!在mapper.xml文件中注释语句必须使用&lt;!-- --&gt;在一次调试中直接在mapper.xml顺手使用CTRL + /了快捷键注释:#符号然而那一行代码也是变灰了也就没留意在访问的时候直接报错了之后换成&lt;!-- --&gt;即可","categories":[{"name":"BUG系列","slug":"BUG系列","permalink":"https://www.lgzblog.com/categories/BUG系列/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://www.lgzblog.com/tags/Mybatis/"}],"author":"卢国峥"},{"title":"Sourcetree 更新git账号密码","slug":"sourectree使用","date":"2019-05-31T15:02:00.000Z","updated":"2019-05-31T15:25:27.000Z","comments":true,"path":"2019/05/31/sourectree使用/","link":"","permalink":"https://www.lgzblog.com/2019/05/31/sourectree使用/","excerpt":"Sourcetree记录~!","text":"Sourcetree记录~!更新git密码使用sourcetree时登录git账号,git账号修改了密码后sourcetree在提交/拉取代码时只会报错,并不会弹出git登录窗口让用户重新登录.解决方法: windows进入以下目录,删除passwd文件1C:\\Users\\USERNAME\\AppData\\Local\\Atlassian\\SourceTree删除文件后,再次拉取/提交代码就会弹出git登录窗口修改git登录名称sourcetree重新登录git时无法修改用户名称解决方法: windows进入上面目录,修改userhosts文件对应的登录名称即可","categories":[{"name":"工具使用","slug":"工具使用","permalink":"https://www.lgzblog.com/categories/工具使用/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.lgzblog.com/tags/git/"}],"author":"卢国峥"},{"title":"ZK分布式锁","slug":"ZK分布式锁","date":"2019-05-17T02:13:00.000Z","updated":"2019-05-17T02:37:05.000Z","comments":true,"path":"2019/05/17/ZK分布式锁/","link":"","permalink":"https://www.lgzblog.com/2019/05/17/ZK分布式锁/","excerpt":"只做记录","text":"只做记录介绍使用curator客户端操作zookeeper引入依赖123456789&lt;!-- 版本号 --&gt;&lt;curator.version&gt;4.0.0&lt;/curator.version&gt;&lt;!-- ZK客户端:curator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.curator&lt;/groupId&gt; &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt; &lt;version&gt;$&#123;curator.version&#125;&lt;/version&gt;&lt;/dependency&gt;zookeeper相关依赖1234567891011121314&lt;!-- 版本号 --&gt;&lt;zookeeper.version&gt;3.4.10&lt;/zookeeper.version&gt;&lt;zkclient.version&gt;0.10&lt;/zkclient.version&gt;&lt;dependency&gt; &lt;groupId&gt;com.101tec&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;$&#123;zkclient.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;$&#123;zookeeper.version&#125;&lt;/version&gt;&lt;/dependency&gt;代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @author LuGuoZheng * @date 2019/5/15 13:33 * @Version 3.0 * @description */public class ZKLock &#123; /** * zk客户端 */ public static CuratorFramework client = null; public InterProcessMutex mutex = null; /** * 初始化zk客户端 */ static &#123; System.out.println(\"开始初始化zk客户端\"); // 重试策略:重试3次,每次重试间隔1s RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3); client = CuratorFrameworkFactory.builder() .connectString(\"139.159.253.188:2181\")// zk地址 .sessionTimeoutMs(15000) // 会话超时时间 .connectionTimeoutMs(30000) // 连接超时时间 .retryPolicy(retryPolicy) // 重试策略 .namespace(\"YL_LGZ\") // 名称 .build(); // 启动zk客户端连接zk client.start(); &#125; /** * * @param code 节点名称 */ public void init(String code) &#123; System.out.println(\"创建节点对象\"); mutex = new InterProcessMutex(client, code); &#125; /** * 加锁:互斥锁 */ public void lock()&#123; try &#123; mutex.acquire(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"枷锁失败\"); &#125; &#125; /** * 释放锁 */ public void unLock() &#123; try &#123; mutex.release(); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"释放锁失败\"); &#125; &#125;&#125;测试123456789101112131415161718192021222324/** * @author LuGuoZheng * @date 2019/5/15 15:06 * @Version 3.0 * @description */public class TestLock extends ZKLock &#123; public TestLock()&#123; super.init(\"/LGZ_TEST_CODE\"); &#125; @Test public void test() throws InterruptedException &#123; TestLock testLock = new TestLock(); try &#123; testLock.lock(); System.out.println(\"\"); Thread.sleep(5000); &#125; finally &#123; testLock.unLock(); System.out.println(\"释放成功\"); &#125; &#125;&#125;","categories":[{"name":"中间件","slug":"中间件","permalink":"https://www.lgzblog.com/categories/中间件/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"分布式锁","slug":"分布式锁","permalink":"https://www.lgzblog.com/tags/分布式锁/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://www.lgzblog.com/tags/zookeeper/"}],"author":"卢国峥"},{"title":"zk命令","slug":"zk命令","date":"2019-05-15T08:02:00.000Z","updated":"2019-06-18T08:15:11.000Z","comments":true,"path":"2019/05/15/zk命令/","link":"","permalink":"https://www.lgzblog.com/2019/05/15/zk命令/","excerpt":"zk操作命令","text":"zk操作命令启动zk1./zkServer.sh start连接客户端1[root@ecs-e339-0002 bin]# ./zkCli.shls查看命令1[zk: localhost:2181(CONNECTED) 2] ls /","categories":[{"name":"中间件","slug":"中间件","permalink":"https://www.lgzblog.com/categories/中间件/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"https://www.lgzblog.com/tags/zookeeper/"}],"author":"卢国峥"},{"title":"Shell脚本","slug":"Shell脚本","date":"2019-05-13T08:40:00.000Z","updated":"2019-05-13T08:47:44.000Z","comments":true,"path":"2019/05/13/Shell脚本/","link":"","permalink":"https://www.lgzblog.com/2019/05/13/Shell脚本/","excerpt":"收藏常用的shell脚本","text":"收藏常用的shell脚本重启java项目test.sh (结束进程)12345678910#!/bin/bashecho \"Stopping SpringBoot Application for CMP\"pid=`ps -ef | grep $1* | grep -v grep | awk '&#123;print $2&#125;'`if [ -n \"$pid\" ]then kill -9 $pidecho 'kill process'else echo \"no pid\"fitt.sh(检查项目是否启动完毕)12345678910111213141516171819#!/bin/bashecho \"start script ................\"file=$1while [ -f $file ]do echo \"find log .........\" result=`grep \"启动成功\" $file` if [[ \"$result\" != \"\" ]] then echo \"springboot start .........\" break else echo \"running .......\" sleep 1s fidoneecho \"springboot Started...........\"run.sh(主shell脚本)1234567891011121314151617181920212223#!/bin/bashsource /etc/profile#版本信息jarversion='-0.0.1-SNAPSHOT.jar'#日志路径logpath='/pro/test/home/yanfa/'runjar()&#123; sh test.sh $1 nohup java -jar $4 $1$jarversion &gt; $logpath$2 &amp; 2&gt;&amp;1 &amp; sh tt.sh $logpath$2 echo $3&#125;runjar 'ylcloud-item-service' 'nohup_item.out' '商品模块启动完成' '-Xms10m -Xmx200m'echo '项目启动成功'","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lgzblog.com/tags/Linux/"},{"name":"shell","slug":"shell","permalink":"https://www.lgzblog.com/tags/shell/"}],"author":"卢国峥"},{"title":"git命令","slug":"git命令-1","date":"2019-05-13T08:33:00.000Z","updated":"2020-06-03T03:28:38.709Z","comments":true,"path":"2019/05/13/git命令-1/","link":"","permalink":"https://www.lgzblog.com/2019/05/13/git命令-1/","excerpt":"记录常用的git命令","text":"记录常用的git命令删除已关联的远程仓库1git remote rm origin暂存到本地仓库1git commit -m &quot;add 3 files.&quot;推送到远程仓库1234git pull origin master// 强行推送git pull origin master -f删除本地tag1git tag -l | xargs git tag -dGit合并某个分支的某次提交到指定分支1git cherry-pick commitIDcommitID : 8位数","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lgzblog.com/tags/git/"}],"author":"卢国峥"},{"title":"设计模式之动态代理模式","slug":"设计模式之动态代理模式","date":"2019-05-13T07:29:00.000Z","updated":"2019-05-13T08:26:17.000Z","comments":true,"path":"2019/05/13/设计模式之动态代理模式/","link":"","permalink":"https://www.lgzblog.com/2019/05/13/设计模式之动态代理模式/","excerpt":"动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。","text":"动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。如何动态的创建一份字节码：由于 JVM 通过字节码的二进制信息加载类的，如果我们在运行期系统中，遵循 Java 编译系统组织 .class 文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。如此，就完成了在代码中动态创建一个类的能力了。相关资料InvocationHandler 类InvocationHandler是由代理实例的调用处理程序实现的接口 。每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。1234567主要方法：public Object invoke(Object proxy, Method method, Object[] args) 方法职责：负责集中处理动态代理类上的所有方法调用 参数： proxy ：生成的代理对象 method：当前调用的真实方法对象 args ：当前调用方法的实参 返回：真实方法的返回结果Proxy 类Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。1234567主要方法：public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler hanlder) 方法职责：为指定类加载器、一组接口及调用处理器生成动态代理类实例 参数: loader ：类加载器，一般传递真实对象的类加载器 interfaces：代理类需要实现的接口 hanlder：代理对象如何做增强: 返回：创建的代理对象静态方法static ObjectnewProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) 返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。实现动态代理方式 针对有接口：使用 JDK 动态代理； 针对无接口：使用 CGLIB 或 Javassist 组件。若使用 JDK 动态代理生成代理类,真实类必须实现一个接口代码实现(JDK动态代理)代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println(\"我是真实对象,与\" + name + \"签订了\" + contract); &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println(\"开启事务\"); &#125; public void rollback()&#123; System.out.println(\"回滚事务\"); &#125; public void commit()&#123; System.out.println(\"提交事务\"); &#125;&#125;处理器123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author LuGuoZheng * @date 2019/5/11 16:45 * @Version 3.0 * @description */public class TransactionManagerHandler implements InvocationHandler &#123; // 真实对象 private Object target; // 事务对象 private MyTransactionManger tx; public void setTarget(Object target) &#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger tx) &#123; this.tx = tx; &#125; // 获取代理对象 public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; tx.begin(); try &#123; result = method.invoke(target,args); tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); tx.rollback(); &#125; return result; &#125;&#125;测试12345678910111213141516171819202122232425/** * @author LuGuoZheng * @date 2019/5/11 16:58 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; MyTransactionManger tx = new MyTransactionManger(); EmployeeService employeeService = new EmployeeServiceImpl(); TransactionManagerHandler handler = new TransactionManagerHandler(); handler.setMyTransactionManger(tx); handler.setTarget(employeeService); System.out.println(\"真实类:\" + employeeService); EmployeeService proxy = handler.getProxy(); System.out.println(\"代理类:\" + proxy); proxy.save(\"张三\",\"10年长期合同\"); &#125;&#125;结果123开启事务我是真实对象,与张三签订了10年长期合同提交事务调用流程JDK动态代理总结Java 动态代理是使用 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口这两个来完成的。要使用 JDK 动态代理，委托类必须实现接口。JDK 动态代理将会拦截所有 pubic 的方法（因为只能调用接口中定义的方法），这样即使在接口中增加了新的方法，不用修改代码也会被拦截。动态代理的最小单位是类（类中某些方法都会被处理），如果只想拦截一部分方法，可以在 invoke 方法中对要执行的方法名进行判断。对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统，也更符合面向接口编程规范。若委托类实现了接口，优先选用 JDK 动态代理。若委托类没有实现任何接口，使用 Javassit 和 CGLIB 动态代理。","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之静态代理模式","slug":"设计模式之静态代理模式","date":"2019-05-09T03:40:00.000Z","updated":"2019-05-09T05:56:43.000Z","comments":true,"path":"2019/05/09/设计模式之静态代理模式/","link":"","permalink":"https://www.lgzblog.com/2019/05/09/设计模式之静态代理模式/","excerpt":"客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。","text":"客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。代理模式客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。1. 静态代理在程序运行前就已经存在代理类的字节码文件,代理对象和真实对象的关系在运行前就确定了.2. 代码实现代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println(\"我是真实对象,与\" + name + \"签订了\" + contract); &#125;&#125;代理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author LuGuoZheng * @date 2019/5/9 10:34 * @Version 3.0 * @description 代理对象 */public class EmployeeProxyImpl implements EmployeeService &#123; /** * 真实对象 */ private EmployeeService target; private MyTransactionManger myTransactionManger; public void setTarget(EmployeeService target)&#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger myTransactionManger)&#123; this.myTransactionManger = myTransactionManger; &#125; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; myTransactionManger.begin(); try &#123; // 真实对象只负责签订合同 target.save(name,contract); // TODO 签订合同后处理一系列其他问题 myTransactionManger.commit(); &#125; catch (Exception e) &#123; myTransactionManger.rollback(); e.printStackTrace(); &#125; &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println(\"开启事务\"); &#125; public void rollback()&#123; System.out.println(\"回滚事务\"); &#125; public void commit()&#123; System.out.println(\"提交事务\"); &#125;&#125;测试123456789101112131415161718192021/** * @author LuGuoZheng * @date 2019/5/9 11:01 * @Version 3.0 * @description 测试 * * */public class Test &#123; public static void main(String[] args) &#123; EmployeeServiceImpl employeeService = new EmployeeServiceImpl(); EmployeeProxyImpl employeeProxy = new EmployeeProxyImpl(); MyTransactionManger myTransactionManger = new MyTransactionManger(); employeeProxy.setMyTransactionManger(myTransactionManger); employeeProxy.setTarget(employeeService); employeeProxy.save(\" 张三 \",\"10长期合同~!\"); &#125;&#125;测试结果123开启事务我是真实对象,与 张三 签订了10长期合同~!提交事务3. 静态代理优缺点优点业务只需要关注业务逻辑本身,保证了业务类的重要性.把真实对象隐藏起来,保护真实对象缺点代理对象的某个接口只服务于某一种类型的对象,也就是为每个真实类创建一个代理类.若需要代理的方法很多,那么就要为每一种方法都进行代理处理.若接口增加一个方法,除了所有实现类需要实现这个方法,代理类也需要实现此方法.","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之观察者模式","slug":"设计模式之观察者模式","date":"2019-05-08T07:21:00.000Z","updated":"2019-05-08T07:51:53.000Z","comments":true,"path":"2019/05/08/设计模式之观察者模式/","link":"","permalink":"https://www.lgzblog.com/2019/05/08/设计模式之观察者模式/","excerpt":"在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。","text":"在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。观察者模式的定义在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。MQ的发布订阅模式其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。模式涵盖的角色抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。代码实现被观察者接口12345678910111213141516171819202122232425262728/** * @author LuGuoZheng * @date 2019/5/8 13:42 * @Version 3.0 * @description 被观察者接口 */public interface Observerable &#123; /** * 注册观察者 * * @param observer 观察者 */ void registerObServer(Observer observer); /** * 移除观察 * * @param observer 观察者 */ void removeObServer(Observer observer); /** * 通知观察者 * @param message 消息 */ void notifyObServer(String message);&#125;观察者接口12345678910111213141516/** * @author LuGuoZheng * @date 2019/5/8 13:44 * @Version 3.0 * @description */public interface Observer &#123; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ void update(String message);&#125;被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author LuGuoZheng * @date 2019/5/8 13:51 * @Version 3.0 * @description 公众号 */public class WechatServer implements Observerable &#123; /** * 寄存订阅了该公众号的用户(观察者) */ private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 注册观察者 * * @param observer 观察者 */ @Override public void registerObServer(Observer observer) &#123; observerList.add(observer); System.out.println(\"[\" + ((User) observer).getName() + \"]\" + \"关注了公众号~!\"); &#125; /** * 取消观察 * * @param observer 观察者 */ @Override public void removeObServer(Observer observer) &#123; if (observer == null) &#123; return; &#125; boolean remove = observerList.remove(observer); if (remove) &#123; System.out.println(\"[\" + ((User) observer).getName() + \"]\" + \"取消了关注~! (╯‵□′)╯︵┻━┻\"); &#125; &#125; /** * 通知观察者 * * @param message 消息 */ @Override public void notifyObServer(String message) &#123; for (Observer observer : observerList) &#123; observer.update(message); &#125; &#125;&#125;观察者123456789101112131415161718192021222324/** * @author LuGuoZheng * @date 2019/5/8 13:56 * @Version 3.0 * @description 观察者 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Observer &#123; private String name; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ @Override public void update(String message) &#123; System.out.println(\"我是:\" + name + \",\" + message); &#125;&#125;测试1234567891011121314151617181920212223242526272829303132/** * @author LuGuoZheng * @date 2019/5/8 14:24 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; Observer u1 = new User(\"张三\"); Observer u2 = new User(\"李四\"); Observer u3 = new User(\"王五\"); Observerable wecahtService = new WechatServer(); // 观察(订阅)公众号 wecahtService.registerObServer(u1); wecahtService.registerObServer(u2); wecahtService.registerObServer(u3); System.out.println(\"--------------------------------\"); // 发布消息 wecahtService.notifyObServer(\"第一波福利\"); System.out.println(\"--------------------------------\"); // 取消关注 wecahtService.removeObServer(u1); System.out.println(\"--------------------------------\"); // 发布消息 wecahtService.notifyObServer(\"这是第二波福利\"); &#125;&#125;测试结果123456789101112[张三]关注了公众号~![李四]关注了公众号~![王五]关注了公众号~!--------------------------------我是:张三,第一波福利我是:李四,第一波福利我是:王五,第一波福利--------------------------------[张三]取消了关注~! (╯‵□′)╯︵┻━┻--------------------------------我是:李四,这是第二波福利我是:王五,这是第二波福利参考:JAVA设计模式之观察者模式","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"Linux相关命令","slug":"Linux相关命令","date":"2019-04-26T13:53:00.000Z","updated":"2019-09-17T07:35:00.000Z","comments":true,"path":"2019/04/26/Linux相关命令/","link":"","permalink":"https://www.lgzblog.com/2019/04/26/Linux相关命令/","excerpt":"如题记录不常用的Linux命令","text":"如题记录不常用的Linux命令运行java项目1nohup java -jar -Xms10m -Xmx200m ylcloud-item-service-0.0.1-SNAPSHOT.jar &gt; /pro/test/home/yanfa/nohup_item.out &amp; 2&gt;&amp;1 &amp;nohup: 后台启动项目-Xms10m -Xmx200m: jvm虚拟机参数查看某端口占用的线程的pid1netstat -nlp |grep :4000查看pid占用的端口号1netstat -nap | grep 32716二. 防火墙2.1 查看所有打开的端口1firewall-cmd --zone=public --list-ports2.2 开启端口（–permanent参数为永久生效，不加则重启后失效）1firewall-cmd --zone=public --add-port=端口号/tcp --permanent2.3 更新防火墙规则：1firewall-cmd --reload2.4 查看防火墙状态123firewall-cmd --state###### 查看安装目录which git1##### 查看文件大小du -sh *123##### 重启``nginx``- 在``sbin``目录下执行命令./nginx -s reload1##### 查找文件find / -name ${fileName}`VI操作VI操作:用的是键盘的左边的数字键逐字符移动:行内跳转:右边的数字键0:跳转到行首(编辑模式)$(Shift+4): 跳转到行尾(编辑模式)^(Shift+6): 跳转到行首的第一个字母位置(编辑模式)行间跳转:(末行模式)gg: 跳转到文件第一行(编辑模式)G(Shift+g): 跳到文件的最后一行(编辑模式)直接输入行号就可以跳转到对应行注意:可以先把行号显示出来:set number在编辑模式下:ctrl+f 向下翻一页 forwardctrl+b 向上翻一页 backwarddd: 删除光标所在行 (编辑模式)3dd:从光标行开始删除3行(编辑模式)——1,4d 删除第一行到第四行(末行模式)u 撤销上一个操作(编辑模式)yy 复制光标所在行 (编辑模式)2yy 从光标行开始复制2行(编辑模式)p: 粘贴命令末行模式:文件的查找/parttern 从前往后查找?parttern 从后往前查找n: 下一个匹配的字符串N: 上一个匹配的字符串g:全局替换i:忽略大小写%s/f/F/gi创建文件vi 文件名touch 文件名创建目录mkdir 目录名mkdir -p 目录名1/目录名2 创建层级目录 可以是相对目录,也可以是绝对目录rm 文件名rm -f 文件名rm -fr 目录 删除目录必须使用 -r 递归删除拷贝: cp拷贝目录的话要带上参数-r移动: mv: mv","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lgzblog.com/tags/Linux/"}],"author":"卢国峥"},{"title":"设计模式之策略模式","slug":"设计模式之策略模式","date":"2019-04-26T07:45:00.000Z","updated":"2019-04-26T08:03:13.000Z","comments":true,"path":"2019/04/26/设计模式之策略模式/","link":"","permalink":"https://www.lgzblog.com/2019/04/26/设计模式之策略模式/","excerpt":"策略模式思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。","text":"策略模式思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。1. 简介思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。2. 代码实现接口123456789101112131415/** * @author LuGuoZheng * @date 2019/4/26 14:37 * @Version 3.0 * @description */public interface Condition &#123; /** * 条件 * @param num 数据 * @return */ boolean check(int num);&#125;类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author LuGuoZheng * @date 2019/4/26 14:36 * @Version 3.0 * @description 策略模式 */public class Strategy &#123; /** * 过滤数据方法 * @param nums 数据源 * @param condition 策略 * @return */ public List&lt;Integer&gt; filteNum(List&lt;Integer&gt; nums,Condition condition)&#123; List&lt;Integer&gt; newNums = new ArrayList&lt;&gt;(); for (Integer num : nums) &#123; if (condition.check(num))&#123; newNums.add(num); &#125; &#125; return newNums; &#125; @Test public void test() &#123; List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 6, 7); // 使用匿名内部类测试 list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num % 2 == 0; &#125; &#125;); System.out.println(list); // [2, 4, 6] list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num &lt; 5; &#125; &#125;); System.out.println(list); // [2, 4] &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之模板模式","slug":"设计模式之模板模式","date":"2019-04-25T02:50:00.000Z","updated":"2019-04-26T07:57:15.000Z","comments":true,"path":"2019/04/25/设计模式之模板模式/","link":"","permalink":"https://www.lgzblog.com/2019/04/25/设计模式之模板模式/","excerpt":"模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.","text":"模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.1. 简介模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.2. 代码实现抽象类1234567891011121314151617181920public abstract class Times &#123; private static final SimpleDateFormat fmt = new SimpleDateFormat(\"HH:mm:ss.SSS\"); abstract void doWord(); public void test(String title) &#123; title = (title == null) ? \"\" : (\"【\" + title + \"】\"); System.out.println(title); System.out.println(\"开始：\" + fmt.format(new Date())); long begin = System.currentTimeMillis(); doWord(); long end = System.currentTimeMillis(); System.out.println(\"结束：\" + fmt.format(new Date())); double delta = (end - begin) / 1000.0; System.out.println(\"耗时：\" + delta + \"秒\"); System.out.println(\"-------------------------------------\"); &#125;&#125;子类1234567891011121314151617public class MyTemplate extends Times&#123; @Override public void doWord()&#123; int sum = 0; for (int i = 0; i &lt; 1000; i++) &#123; for (int j = 0; j &lt; 1000; j++) &#123; sum += j; &#125; &#125; System.out.println(sum); &#125; public static void main(String[] args) &#123; new MyTemplate().test(\"doWord\"); &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"设计模式之单例模式","slug":"设计模式之单例模式","date":"2019-04-24T01:51:00.000Z","updated":"2019-04-24T07:42:20.000Z","comments":true,"path":"2019/04/24/设计模式之单例模式/","link":"","permalink":"https://www.lgzblog.com/2019/04/24/设计模式之单例模式/","excerpt":"单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例","text":"单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例1. 简介单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例2. 使用场景spring框架就是单例模式的3. 代码实现3.1 懒汉式(双检查保证线程安全)12345678910111213141516171819202122232425public class Singleton &#123; private Integer id; private String namge; private Integer age; private volatile static Singleton INSTANCE; // 私有化构造器 private Singleton ()&#123;&#125; // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; if (INSTANCE == null)&#123; synchronized (Singleton.class)&#123; if (INSTANCE == null)&#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125;3.2 饥饿式123456789101112131415161718192021222324/** * * 优点: 直接在类加载时就初始化一个实例,可以避免线程安全问题 * 缺点: 由于是类加载时就初始化了一个实例,如果一直没有使用该实例,会造成内存浪费,而且没能起到懒加载效果 */public class Singleton &#123; private Integer id; private String name; private Integer age; // 私有化构造器 private Singleton()&#123;&#125; // 初始化一个实例 private static final Singleton INSTANCE = new Singleton(); // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125;3.3 枚举1234567891011121314public enum Singleton &#123; INSTANCE; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;3.4 枚举反编译(使用XJad反编译)通过反编译可以看出就是一个饥饿式单例模式,所有实现单例模式直接写一个枚举即可.123456789101112131415161718192021222324252627282930313233343536373839404142// 使用final修饰类,并继承了Enum类public final class Singleton extends Enum&#123; public static final Singleton INSTANCE; private String name; private static final Singleton $VALUES[]; public static Singleton[] values() &#123; return (Singleton[])$VALUES.clone(); &#125; public static Singleton valueOf(String name) &#123; return (Singleton)Enum.valueOf(53554F8B6A215F0F/Singleton, name); &#125; private Singleton(String s, int i) &#123; super(s, i); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; // 在静态代码块中直接创建了一个实例 static &#123; INSTANCE = new Singleton(\"INSTANCE\", 0); $VALUES = (new Singleton[] &#123; INSTANCE &#125;); &#125;&#125;","categories":[{"name":"设计模式系列","slug":"设计模式系列","permalink":"https://www.lgzblog.com/categories/设计模式系列/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://www.lgzblog.com/tags/设计模式/"}],"author":"卢国峥"},{"title":"算法复杂度","slug":"复杂度","date":"2019-04-19T01:37:00.000Z","updated":"2019-04-20T04:50:54.000Z","comments":true,"path":"2019/04/19/复杂度/","link":"","permalink":"https://www.lgzblog.com/2019/04/19/复杂度/","excerpt":"时间复杂度:估算程序指令的执行次数(执行时间)空间复杂度:估算所需占用的存储空间算法网站👇:https://leetcode-cn.com/","text":"时间复杂度:估算程序指令的执行次数(执行时间)空间复杂度:估算所需占用的存储空间算法网站👇:https://leetcode-cn.com/时间复杂度 百度百科:时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 个人理解:估算程序指令的执行次数(执行时间)空间复杂度 百度百科:空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 个人理解:估算所需占用的存储空间大O表示法一般用大O表示法来描述复杂度,表示的是数据规模n对应的复杂度123456789忽略常数、系数、低阶9 &gt;&gt;&gt; O(1)2n + 3 &gt;&gt;&gt; O(n)$n^2$ + 2n + 6 &gt;&gt;&gt; O($n^2$)$4n^3$ + $3n^2$ + 22n + 100 &gt;&gt;&gt; O($n^3$)注意:大O表示法仅仅只是一种粗略的分析模型,是一种估算,能帮助我们短时间内了解一个算法的执行效率常见的复杂度对数阶细节对数阶一般省略底数1$log_2 n = log_2 9 * log_9 n$$所以log_2 n、log_9 n统称为log_n$","categories":[{"name":"数据结构与算法系列","slug":"数据结构与算法系列","permalink":"https://www.lgzblog.com/categories/数据结构与算法系列/"}],"tags":[{"name":"复杂度","slug":"复杂度","permalink":"https://www.lgzblog.com/tags/复杂度/"}],"author":"卢国峥"},{"title":"dubbo隐式参数传递","slug":"Dobbu隐式参数传递","date":"2019-04-17T03:13:00.000Z","updated":"2019-06-29T06:18:22.000Z","comments":true,"path":"2019/04/17/Dobbu隐式参数传递/","link":"","permalink":"https://www.lgzblog.com/2019/04/17/Dobbu隐式参数传递/","excerpt":"记录一个dobbu传递隐式参数demo,调用RPC服务时用于服务消费者向服务提供者传递隐式参数,比如向服务提供者传递token信息.","text":"记录一个dobbu传递隐式参数demo,调用RPC服务时用于服务消费者向服务提供者传递隐式参数,比如向服务提供者传递token信息.上下文信息RpcContext是一个ThreadLocal的临时状态记录器，当接收到RPC请求，或发起RPC请求时，RpcContext的状态都会变化。比如A调用B，B再调用C，则B机器上，在B调用C之前，RpcContext记录的是A调用B的信息，在B调用C之后，RpcContext记录的是B调用C。服务消费者:controller层12345678910111213141516@Controller@RequestMapping(\"/test\")public class TestController &#123; @Reference private ICarService iCarService; @RequestMapping(\"/test\") @ResponseBody public String test()&#123; // 传递参数 RpcContext.getContext().setAttachment(\"TOKEN\",\"测试隐士参数传递\"); iCarService.test(); return \"参数\"; &#125;&#125;服务提供者:service层接口123public interface ICarService &#123; void test();&#125;实现类123456789@Service@Transactionalpublic class CarServiceImpl implements ICarService &#123; public void test() &#123; // 获取参数 String token = RpcContext.getContext().getAttachment(\"TOKEN\"); System.out.println(token); &#125;&#125;项目使用场景在项目中使用的是登录后,会生成一个token返回给用户,用户每次登录都要把改token带过来进行登录验证,验证通过后则去调用RPC服务,可以通过隐士参数传递把token传递到服务提供者,这样就可以获取到当前登录用户的token,然后去获取当前登录用户信息.注意如果使用setAttachments会把原来的参数清空,后再保存现在的参数.源码123456789public RpcContext setAttachments(Map&lt;String, String&gt; attachment) &#123; // 清空参数 this.attachments.clear(); if (attachment != null &amp;&amp; attachment.size() &gt; 0) &#123; this.attachments.putAll(attachment); &#125; return this;&#125;","categories":[{"name":"Dubbo系列","slug":"Dubbo系列","permalink":"https://www.lgzblog.com/categories/Dubbo系列/"}],"tags":[{"name":"dubbo","slug":"dubbo","permalink":"https://www.lgzblog.com/tags/dubbo/"}],"author":"卢国峥"},{"title":"配置maven打包方式","slug":"配置maven打包方式","date":"2019-04-15T03:33:00.000Z","updated":"2019-09-07T02:56:48.000Z","comments":true,"path":"2019/04/15/配置maven打包方式/","link":"","permalink":"https://www.lgzblog.com/2019/04/15/配置maven打包方式/","excerpt":"使用maven-jar-plugin和maven-dependency-plugin插件打包","text":"使用maven-jar-plugin和maven-dependency-plugin插件打包使用maven-jar-plugin和maven-dependency-plugin打包的原因及好处现在项目使用的springboot框架搭建的maven项目,由于使用jenkins自动部署项目,而且并没有配置单个模块部署,导致每次部署都要10来分钟,严重浪费时间,现在使用该插件打包后不用每次都使用jenkins部署,直接本地打包好之后替换掉服务器的jar就行,而且打包完可以看到jar是很小的,上传也很快1. 配置pom文件12345678910111213141516171819202122232425262728293031323334&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- springboot启动类 --&gt; &lt;mainClass&gt;cn.lgz.shop.GoodsApp&lt;/mainClass&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;2. 打包效果打包后会把项目代码和依赖分离开来:依赖会打包到lib目录项目代码会打包成一个jar包","categories":[{"name":"工具配置相关","slug":"工具配置相关","permalink":"https://www.lgzblog.com/categories/工具配置相关/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://www.lgzblog.com/tags/maven/"}],"author":"卢国峥"},{"title":"SSL数字证书Nginx配置部署","slug":"SSL数字证书Nginx配置部署","date":"2019-04-13T08:55:00.000Z","updated":"2019-04-17T07:27:13.000Z","comments":true,"path":"2019/04/13/SSL数字证书Nginx配置部署/","link":"","permalink":"https://www.lgzblog.com/2019/04/13/SSL数字证书Nginx配置部署/","excerpt":"记录Nginx配置SSL数字证书的步骤以及遇到一些的问题 实践成果：为本网站部署SSL证书，实现https访问👇环境以及证书👇:阿里云服务器: CentOS7SSL数字证书: Symantec DV SSL证书（免费版）","text":"记录Nginx配置SSL数字证书的步骤以及遇到一些的问题 实践成果：为本网站部署SSL证书，实现https访问👇环境以及证书👇:阿里云服务器: CentOS7SSL数字证书: Symantec DV SSL证书（免费版）一. 添加SSL模块1.0 进入nginx解压目录使用执行以下命令添加SSL模块1./configure --with-http_ssl_module如果报错./configure: error: SSL modules require the OpenSSL library.则执行123yum -y install openssl openssl-devel./configure执行make（切记不能make install会覆盖安装目录）将原来nginx备份(可选）:如果自己nginx有什么重要配置可以先备份以防丢失1cp objs/nginx /usr/local/nginx/sbin/nginx将新的nginx覆盖旧安装目录1cp objs/nginx /usr/local/nginx/sbin/nginx二. 配置SSL证书1.0 进入Nginx安装目录conf目录(PS:安装目录和解压目录不是同一个目录）1cd /usr/local/nginx/conf/创建cert目录,并把准备好的SSL数字证书放在该目录下1mkdir cert返回conf文件，编辑nginx.conf配置文件，找到以下内容12345678910111213141516 # HTTPS server #server &#123; #listen 443; #server_name localhost; #ssl_certificate cert.pem; #ssl_certificate_key cert.key; #ssl_session_timeout 5m; #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; #ssl_prefer_server_ciphers on; #location / &#123; #root html; #index index.html index.htm; #proxy_pass http://localhost:4000; #&#125;#&#125;把以上内容替换为以下内容，或者注释以上内容重新添加也可以：123456789101112131415161718# 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。 server &#123; listen 443; server_name localhost; # localhost修改为您证书绑定的域名。 ssl on; #设置为on启用SSL功能。 root html; index index.html index.htm; ssl_certificate cert/domain name.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录。 index index.html index.htm; #添加属性。 &#125; &#125;三. 配置阿里云服务器安全组规则⭐ 如果你以上步骤都没有问题，但是还是访问不了，那就要查看下是否有配置443端口的安全组，如果没有加上即可。四. 参考资料https://help.aliyun.com/document_detail/98728.htmlhttps://help.aliyun.com/video_detail/54216.html?spm=5176.2000002.0.0.19057747sUlwcdhttps://blog.csdn.net/weiyangdong/article/details/80008543","categories":[{"name":"服务器系列","slug":"服务器系列","permalink":"https://www.lgzblog.com/categories/服务器系列/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.lgzblog.com/tags/Linux/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.lgzblog.com/tags/Nginx/"},{"name":"SSL","slug":"SSL","permalink":"https://www.lgzblog.com/tags/SSL/"}],"author":"卢国峥"},{"title":"Excel导入导出","slug":"Excel导入导出","date":"2019-04-10T07:00:00.000Z","updated":"2019-04-17T07:27:29.000Z","comments":true,"path":"2019/04/10/Excel导入导出/","link":"","permalink":"https://www.lgzblog.com/2019/04/10/Excel导入导出/","excerpt":"记录一个java基于jxl实现的Excel导入导出功能","text":"记录一个java基于jxl实现的Excel导入导出功能一. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jexcelapi&lt;/groupId&gt; &lt;artifactId&gt;jxl&lt;/artifactId&gt; &lt;version&gt;2.6.12&lt;/version&gt;&lt;/dependency&gt;二. 导出2.0 接口编写1234567891011121314151617181920@RequestMapping(value = \"/export\")public void test(HttpServletResponse response) throws Exception &#123; WritableWorkbook workbook = Workbook.createWorkbook(response.getOutputStream()); // 响应格式 response.setContentType(\"application/vnd.ms-excel\"); response.setHeader(\"Content-Disposition\", \"attachment; filename=\" + URLEncoder.encode(\"文件名称.xls\", \"UTF-8\")); // 创建一个工作簿: WritableSheet sheet1 = workbook.createSheet(\"工作簿名称\", 0); Label label1 = new Label(0, 0, \"商品id\"); sheet1.addCell(label1); Label label2 = new Label(1, 0, \"公司编号\"); sheet1.addCell(label2); //查询数据写到workbook中 workbook.write(); System.out.println(\"查询数据写到workbook中\"); //关闭资源 workbook.close();&#125;2.1 导出效果如下三. 导入3.0 读取Excel接口12345678910111213141516171819202122232425262728293031@PostMapping(value = \"/excel\")public void importExcel(MultipartFile file) &#123; Workbook workbook = null; List&lt;ItemDto&gt; items = new ArrayList&lt;&gt;(); HashMap&lt;String, ItemDto&gt; map = new HashMap&lt;&gt;(); try &#123; //获取xls文件Excel workbook = Workbook.getWorkbook(file.getInputStream()); //获取商品工作簿:可通过索引获取不同工作簿 Sheet itemSheet = workbook.getSheet(0); //获取总行数 int rows = itemSheet.getRows(); //格式化导入的日期格式 for (int i = 1; i &lt; rows; i++) &#123; Cell[] row = itemSheet.getRow(i); if (row.length == 0) &#123; continue; &#125; String itemId = itemSheet.getCell(0, i).getContents(); System.out.println(itemId); String scompCode = itemSheet.getCell(1, i).getContents(); System.out.println(scompCode); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 workbook.close(); &#125;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://www.lgzblog.com/tags/java/"},{"name":"Excel","slug":"Excel","permalink":"https://www.lgzblog.com/tags/Excel/"}],"author":"卢国峥"},{"title":"Hexo之瞎折腾系列","slug":"Hexo瞎折腾系列","date":"2019-03-30T12:11:00.000Z","updated":"2019-05-13T03:13:50.000Z","comments":true,"path":"2019/03/30/Hexo瞎折腾系列/","link":"","permalink":"https://www.lgzblog.com/2019/03/30/Hexo瞎折腾系列/","excerpt":"该文档记录Theme-AD主题个人博客部署到云服务器以及记录新增的一些小功能~！Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/Let’s Go~!","text":"该文档记录Theme-AD主题个人博客部署到云服务器以及记录新增的一些小功能~！Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/Let’s Go~!Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/一.云服务器部署Hexo参考文档：https://www.jianshu.com/p/b2e47ec9359d1.1 后台运行Hexo部署到云服务器后如果还是在hexo根目录下使用命令启动，会有个问题就是：当你断开服务器连接之后hexo服务就会停止，无法访问。那么可以用pm2启动hexo，这样hexo就在后台运行了，就算断开服务器连接也不会停止1.2 安装pm21npm install -g pm2ps：如果感兴趣也可以了解下Linux的nohup命令1.2 在hexo创建run.js文件12345678910//run.jsconst &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(`exec error: $&#123;error&#125;`) return &#125; console.log(`stdout: $&#123;stdout&#125;`); console.log(`stderr: $&#123;stderr&#125;`);&#125;)1.3 运行脚本1pm2 start run.js二.为自己的博客添加萌宠参考博客：https://blog.csdn.net/u010820857/article/details/822707362.1 安装模块1npm install --save hexo-helper-live2d2.2 选择想要的萌宠12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z162.3 选择好之后还需要安装例如我选择的是：live2d-widget-model-z161npm install live2d-widget-model-z162.4 最后一步配置Hexo的主配置文件_config.yml1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 // 这里改为自己选择的萌宠 其他参数可以根据自己喜好看着修改 display: position: right width: 150 height: 300 mobile: show: true三. hexo部署到GitHub后绑定域名(未备案域名也可以)3.1 GitHub相关配置在根目录下添加CNAME文件(名称大写),在文件中输入域名CNAME 文件:文件内容就是你的域名:在设置中配置域名:3.2 修改域名解析记录按照下面添加域名解析记录:ps:截图中记录值的ip是通过ping`自己的xxx.github.io得到四. 新增站内搜索功能原本Theme-AD主题是没有站内搜索的,本站点移植的是Ocean主题的站内搜索功能.4.1 修改header.ejs文件把原本主题的搜索框移除,在相对应位置加入搜索按钮和搜索框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;header class=\"site-header\"&gt; &lt;div class=\"site-header-brand\"&gt; &lt;% if(theme.nav_name) &#123; %&gt; &lt;span class=\"site-header-brand-title\"&gt; &lt;a href=\"&lt;%- url_for('/') %&gt;\"&gt;&lt;%- theme.nav_name %&gt;&lt;/a&gt; &lt;/span&gt; &lt;% &#125; %&gt; &lt;% if(theme.motto) &#123; %&gt; &lt;span class=\"site-header-brand-motto\"&gt; | &lt;%- theme.motto %&gt;&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class=\"site-header-right\"&gt; &lt;nav class=\"site-header-navigation\"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;a href=\"&lt;%- url_for(link.path) %&gt;\" target=\"&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;\"&gt;&lt;%= link.name%&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;/nav&gt; &lt;!-- 搜索按钮 --&gt; &lt;nav class=\"navbar\"&gt; &lt;a href=\"#\" class=\"nav-item-link nav-item-search\" title=\"&lt;%= __('搜索') %&gt;\"&gt; &lt;i class=\"fe fe-search\"&gt;&lt;/i&gt; &lt;%- theme.search_text %&gt; &lt;/a&gt; &lt;/nav&gt; &lt;div class=\"site-header-btn\"&gt; &lt;% if(theme.github) &#123; %&gt; &lt;a href=\"&lt;%- theme.github %&gt;\" target=\"_blank\" id=\"site-github\"&gt; &lt;i class=\"fa fa-github-alt\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;/dev&gt;&lt;/div&gt;&lt;!-- 搜索框 --&gt;&lt;div class=\"search-form-wrap\"&gt; &lt;div class=\"local-search local-search-plugin\"&gt; &lt;input type=\"search\" id=\"local-search-input\" class=\"local-search-input\" placeholder=\"Search...\"&gt; &lt;div id=\"local-search-result\" class=\"local-search-result\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/header&gt;&lt;nav class=\"table-content\" id=\"site-nav\"&gt; &lt;div class=\"table-content-title\"&gt; &lt;span&gt;导航&lt;/span&gt; &lt;/div&gt; &lt;div class=\"table-content-main\"&gt; &lt;ol class=\"toc\"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;li class=\"toc-item\"&gt; &lt;a href=\"&lt;%- url_for(link.path) %&gt;\" target=\"&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;\"&gt; &lt;%= link.name %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div id=\"site-process\"&gt;&lt;/div&gt;4.2 把Ocean主题中source中css的feathericon移到自己主题的css目录下4.3 在css目录下创建_feathericon.styl文件12345678910111213141516171819202122232425262728293031323334353637@charset \"utf-8\"//---------------------------------------------------------------------------// feathericon//---------------------------------------------------------------------------//// variablesfeathericon-font-path = 'feathericon/' !default;//// font path@font-face font-family feathericon font-weight normal font-style normal src: url(feathericon-font-path + 'feathericon.eot') src: url(feathericon-font-path + 'feathericon.eot?#iefix') format('embedded-opentype'), url(feathericon-font-path + 'feathericon.woff') format('woff'), url(feathericon-font-path + 'feathericon.ttf') format('truetype'), url(feathericon-font-path + 'feathericon.svg') format('svg');//// feathericon//.fe display inline-block font normal normal normal 16px feathericon font-size inherit text-rendering auto -webkit-font-smoothing antialiased -moz-osx-font-smoothing grayscale.fe-search:before &#123; content: \"\\f14e\"; &#125;.fe-search-minus:before &#123; content: \"\\f16a\"; &#125;.fe-search-plus:before &#123; content: \"\\f16b\"; &#125;4.4 在css目录下创建_mixins.styl文件123456border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n// Media queries4.5 在css目录下创建_variables.styl文件123456789101112131415161718192021// Configsupport-for-ie = falsevendor-prefixes = webkit moz ms official// Fontsfont-size-browser = 62.5%font-size-base = 1.4remfont-family-base = \"Helvetica Neue\", Helvetica, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft YaHei\", \"微软雅黑\", Arial, sans-seriffont-line-height = 1.7// Colorssea = #1e3e3ffroth-light = #f4f4f4white = #ffffffsand-light = #9c8079sand = #9e6a4d// Borderborder-radius = 0.4remborder-width = 0.1remborder-color = froth4.6 在css目录下创建style.styl文件123456789101112131415161718192021222324252627@import &quot;_variables&quot;@import &quot;_feathericon&quot;//@import &quot;_normalize&quot;@import &quot;_mixins&quot;@import &quot;search&quot;*,*::before*::after box-sizing border-boxhtml font-size font-size-browserbody background-color body-background font-family font-family-base font-size font-size-base line-height font-line-height color body-color padding 0 margin 0 overflow-x hidden text-size-adjust: 100% ::selection background sea-lighter color froth4.7 修改header.js文件(替换掉所有内容)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162(function ($) &#123; // Search ------------ var $searchWrap = $('.search-form-wrap'), isSearchAnim = false, searchAnimDuration = 200; var startSearchAnim = function () &#123; isSearchAnim = true; &#125;; var stopSearchAnim = function (callback) &#123; setTimeout(function () &#123; isSearchAnim = false; callback &amp;&amp; callback(); &#125;, searchAnimDuration); &#125;; $('.nav-item-search').on('click', function () &#123; if (isSearchAnim) return; startSearchAnim(); $searchWrap.addClass('on'); stopSearchAnim(function () &#123; $('.local-search-input').focus(); &#125;); &#125;); $(document).mouseup(function (e) &#123; var _con = $('.local-search'); if (!_con.is(e.target) &amp;&amp; _con.has(e.target).length === 0) &#123; $searchWrap.removeClass('on'); &#125; &#125;); // 移动设备侦测 var isMobile = &#123; Android: function () &#123; return navigator.userAgent.match(/Android/i); &#125;, BlackBerry: function () &#123; return navigator.userAgent.match(/BlackBerry/i); &#125;, iOS: function () &#123; return navigator.userAgent.match(/iPhone|iPad|iPod/i); &#125;, Opera: function () &#123; return navigator.userAgent.match(/Opera Mini/i); &#125;, Windows: function () &#123; return navigator.userAgent.match(/IEMobile/i); &#125;, any: function () &#123; return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); &#125; &#125;; // 建议在移动端不初始化，其实 /search.xml 文件还挺大的， if ($('.local-search').size() &amp;&amp; !isMobile.any()) &#123; $.getScript('/js/search.js', function () &#123; searchFunc(\"/search.xml\", 'local-search-input', 'local-search-result'); &#125;); &#125; // Share ------------ $('body').on('click', function () &#123; $('.article-share-box.on').removeClass('on'); &#125;).on('click', '.article-share-link', function (e) &#123; e.stopPropagation(); var $this = $(this), url = $this.attr('data-url'), encodedUrl = encodeURIComponent(url), id = 'article-share-box-' + $this.attr('data-id'), offset = $this.offset(); if ($('#' + id).length) &#123; var box = $('#' + id); if (box.hasClass('on')) &#123; box.removeClass('on'); return; &#125; &#125; else &#123; var html = [ '&lt;div id=\"' + id + '\" class=\"article-share-box\"&gt;', '&lt;input class=\"article-share-input\" value=\"' + url + '\"&gt;', '&lt;div class=\"article-share-links\"&gt;', '&lt;a href=\"https://twitter.com/intent/tweet?url=' + encodedUrl + '\" class=\"article-share-twitter\" target=\"_blank\" title=\"Twitter\"&gt;&lt;/a&gt;', '&lt;a href=\"https://www.facebook.com/sharer.php?u=' + encodedUrl + '\" class=\"article-share-facebook\" target=\"_blank\" title=\"Facebook\"&gt;&lt;/a&gt;', '&lt;a href=\"http://pinterest.com/pin/create/button/?url=' + encodedUrl + '\" class=\"article-share-pinterest\" target=\"_blank\" title=\"Pinterest\"&gt;&lt;/a&gt;', '&lt;a href=\"https://plus.google.com/share?url=' + encodedUrl + '\" class=\"article-share-google\" target=\"_blank\" title=\"Google+\"&gt;&lt;/a&gt;', '&lt;/div&gt;', '&lt;/div&gt;' ].join(''); var box = $(html); $('body').append(box); &#125; $('.article-share-box.on').hide(); box.css(&#123; top: offset.top + 25, left: offset.left &#125;).addClass('on'); &#125;).on('click', '.article-share-box', function (e) &#123; e.stopPropagation(); &#125;).on('click', '.article-share-box-input', function () &#123; $(this).select(); &#125;).on('click', '.article-share-box-link', function (e) &#123; e.preventDefault(); e.stopPropagation(); window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450'); &#125;); // fancybox if ($.fancybox) &#123; $('[data-fancybox]').fancybox(&#123; protect: true &#125;); &#125; // lazyload //$(\".lazy\").lazyload(); // $(document).ready(function ($) &#123; $(\".anchor\").click(function (event) &#123; event.preventDefault(); $('html,body').animate(&#123;scrollTop: $(this.hash).offset().top&#125;, 500); &#125;); &#125;); // Mobile nav var $content = $('.content'), $sidebar = $('.sidebar'), isMobileNavAnim = false, mobileNavAnimDuration = 200; var startMobileNavAnim = function () &#123; isMobileNavAnim = true; &#125;; var stopMobileNavAnim = function () &#123; setTimeout(function () &#123; isMobileNavAnim = false; &#125;, mobileNavAnimDuration); &#125;; $('.navbar-toggle').on('click', function () &#123; if (isMobileNavAnim) return; startMobileNavAnim(); $content.toggleClass('on'); $sidebar.toggleClass('on'); stopMobileNavAnim(); &#125;); $($content).on('click', function () &#123; if (isMobileNavAnim || !$content.hasClass('on')) return; $content.removeClass('on'); $sidebar.removeClass('on'); &#125;);&#125;)(jQuery);4.8 引入jquery-2.0.3.min.js4.9 创建search.js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)// Copyright (C) 2015 // Joseph Pan &lt;http://github.com/wzpan&gt;// Shuhao Mao &lt;http://github.com/maoshuhao&gt;// This library is free software; you can redistribute it and/or modify// it under the terms of the GNU Lesser General Public License as// published by the Free Software Foundation; either version 2.1 of the// License, or (at your option) any later version.// // This library is distributed in the hope that it will be useful, but// WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU// Lesser General Public License for more details.// // You should have received a copy of the GNU Lesser General Public// License along with this library; if not, write to the Free Software// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA// 02110-1301 USA// var searchFunc = function (path, search_id, content_id) &#123; 'use strict'; var BTN = \"&lt;button type='button' class='local-search-close' id='local-search-close'&gt;&lt;/button&gt;\"; $.ajax(&#123; url: path, dataType: \"xml\", success: function (xmlResponse) &#123; // get the contents from search data var datas = $(\"entry\", xmlResponse).map(function () &#123; return &#123; title: $(\"title\", this).text(), content: $(\"content\", this).text(), url: $(\"url\", this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function () &#123; var str = '&lt;ul class=\"search-result-list\"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\\s]+/); $resultContent.innerHTML = \"\"; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function (data) &#123; var isMatch = true; // var content_index = []; if (!data.title || data.title.trim() === '') &#123; data.title = \"Untitled\"; &#125; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, \"\").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') &#123; keywords.forEach(function (keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) &#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; // content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;); &#125; &#125;); &#125; else &#123; isMatch = false; &#125; // show search results if (isMatch) &#123; str += \"&lt;li&gt;&lt;a href='\" + data_url + \"' class='search-result-title'&gt;\" + data_title + \"&lt;/a&gt;\"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, \"\"); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 100; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, \"gi\"); match_content = match_content.replace(regS, \"&lt;em class=\\\"search-keyword\\\"&gt;\" + keyword + \"&lt;/em&gt;\"); &#125;); str += \"&lt;p class=\\\"search-result\\\"&gt;\" + match_content + \"...&lt;/p&gt;\" &#125; str += \"&lt;/li&gt;\"; &#125; &#125;); str += \"&lt;/ul&gt;\"; if (str.indexOf('&lt;li&gt;') === -1) &#123; return $resultContent.innerHTML = BTN + \"&lt;div class=\\\"search-result-empty\\\"&gt;&lt;p&gt;&lt;i class=\\\"fe fe-tired\\\"&gt;&lt;/i&gt; 没有找到内容，更换下搜索词试试吧~&lt;p&gt;&lt;/div&gt;\"; &#125; $resultContent.innerHTML = BTN + str; &#125;); &#125; &#125;); $(document).on('click', '#local-search-close', function () &#123; $('#local-search-input').val(''); $('#local-search-result').html(''); &#125;);&#125;;4.10 最后修改head.ejs文件,引入js和css五. 添加置顶功能5.1 在hexo目录下执行以下命令123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save5.2 在index.ejs加入以下代码1234&lt;% if(psg.top === true) &#123;%&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; |&lt;% &#125; %&gt;5.3 在需要置顶的博文中添加12top: true---六. 使用hexo-neat压缩页面6.1 安装hexo-neat插件1npm install hexo-neat --save6.2 在站点_config.yml配置文件中添加配置12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css: 这里只是压缩页面的css,如果是在source目录下的css要在exclude移除掉,否则压缩后会直接变成一个空文件 neat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩js:(同css说明)neat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos;","categories":[{"name":"Hexo之瞎折腾系列","slug":"Hexo之瞎折腾系列","permalink":"https://www.lgzblog.com/categories/Hexo之瞎折腾系列/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://www.lgzblog.com/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.lgzblog.com/tags/Hexo/"}],"author":"卢国峥"},{"title":"docker-安装(CentOS7)","slug":"Untitled","date":"2019-03-27T09:24:00.000Z","updated":"2020-01-29T07:18:02.000Z","comments":true,"path":"2019/03/27/Untitled/","link":"","permalink":"https://www.lgzblog.com/2019/03/27/Untitled/","excerpt":"CentOS7docker安装步骤","text":"CentOS7docker安装步骤1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker //有则删除对应的包yum remove docker ......1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker //有则删除对应的包yum remove docker ......2.设置yum源(阿里源)1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo3.查看yum库中有没有docker-ce1yum list | grep docker-ce4.安装docker1yum install -y docker-ce5.如果需要设置开机自动启动12345//先启动docker服务端systemctl start docker//启动docker服务开机自启systemctl enable docker6.校验docker是否启动成功1docker version常见问题: 普通用户运行docker 命令会报错:由于docker daemon需要绑定到主机的 Unix socket 而不是普通的TCP端口,而 Unix socket 的宿主为 root 用户,如果其他用户使用 docker 命令只有在命令钱添加 sudo 才能执行成功,如果不想每次使用 docker 命令是还要多敲 sudo ,可以按照下面的方法解决:s1.切换到 root 用户2.把普通用户添加到 docker 组3.再切换到&lt;普通用户&gt;4.验证 docker 命令是否成功","categories":[{"name":"docker容器系列","slug":"docker容器系列","permalink":"https://www.lgzblog.com/categories/docker容器系列/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://www.lgzblog.com/tags/docker/"}],"author":"卢国峥"}]}