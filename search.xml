<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[zk命令]]></title>
    <url>%2F2019%2F05%2F15%2Fzk%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[zk操作命令连接客户端1[root@ecs-e339-0002 bin]# ./zkCli.shls查看命令1[zk: localhost:2181(CONNECTED) 2] ls /]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本]]></title>
    <url>%2F2019%2F05%2F13%2FShell%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[收藏常用的shell脚本重启java项目test.sh (结束进程)12345678910#!/bin/bashecho "Stopping SpringBoot Application for CMP"pid=`ps -ef | grep $1* | grep -v grep | awk '&#123;print $2&#125;'`if [ -n "$pid" ]then kill -9 $pidecho 'kill process'else echo "no pid"fitt.sh(检查项目是否启动完毕)12345678910111213141516171819#!/bin/bashecho "start script ................"file=$1while [ -f $file ]do echo "find log ........." result=`grep "启动成功" $file` if [[ "$result" != "" ]] then echo "springboot start ........." break else echo "running ......." sleep 1s fidoneecho "springboot Started..........."run.sh(主shell脚本)1234567891011121314151617181920212223#!/bin/bashsource /etc/profile#版本信息jarversion='-0.0.1-SNAPSHOT.jar'#日志路径logpath='/pro/test/home/yanfa/'runjar()&#123; sh test.sh $1 nohup java -jar $4 $1$jarversion &gt; $logpath$2 &amp; 2&gt;&amp;1 &amp; sh tt.sh $logpath$2 echo $3&#125;runjar 'ylcloud-item-service' 'nohup_item.out' '商品模块启动完成' '-Xms10m -Xmx200m'echo '项目启动成功']]></content>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git命令]]></title>
    <url>%2F2019%2F05%2F13%2Fgit%E5%91%BD%E4%BB%A4-1%2F</url>
    <content type="text"><![CDATA[记录常用的git命令删除已关联的远程仓库1git remote rm origin推送到远程仓库1234git pull origin master// 强行推送git pull origin master -f]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之动态代理模式]]></title>
    <url>%2F2019%2F05%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。动态代理类是在程序运行期间由 JVM 通过反射等机制动态的生成的，所以不存在代理类的字节码文件，代理对象和真实对象的关系是在程序运行时期才确定的。如何动态的创建一份字节码：由于 JVM 通过字节码的二进制信息加载类的，如果我们在运行期系统中，遵循 Java 编译系统组织 .class 文件的格式和结构，生成相应的二进制数据，然后再把这个二进制数据加载转换成对应的类。如此，就完成了在代码中动态创建一个类的能力了。相关资料InvocationHandler 类InvocationHandler是由代理实例的调用处理程序实现的接口 。每个代理实例都有一个关联的调用处理程序。 当在代理实例上调用方法时，方法调用将被编码并分派到其调用处理程序的invoke方法。1234567主要方法：public Object invoke(Object proxy, Method method, Object[] args) 方法职责：负责集中处理动态代理类上的所有方法调用 参数： proxy ：生成的代理对象 method：当前调用的真实方法对象 args ：当前调用方法的实参 返回：真实方法的返回结果Proxy 类Proxy提供了创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类。1234567主要方法：public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler hanlder) 方法职责：为指定类加载器、一组接口及调用处理器生成动态代理类实例 参数: loader ：类加载器，一般传递真实对象的类加载器 interfaces：代理类需要实现的接口 hanlder：代理对象如何做增强: 返回：创建的代理对象静态方法static ObjectnewProxyInstance(ClassLoader loader, 类&lt;?&gt;[] interfaces, InvocationHandler h) 返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序。实现动态代理方式 针对有接口：使用 JDK 动态代理； 针对无接口：使用 CGLIB 或 Javassist 组件。若使用 JDK 动态代理生成代理类,真实类必须实现一个接口代码实现(JDK动态代理)代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println("我是真实对象,与" + name + "签订了" + contract); &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println("开启事务"); &#125; public void rollback()&#123; System.out.println("回滚事务"); &#125; public void commit()&#123; System.out.println("提交事务"); &#125;&#125;处理器123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author LuGuoZheng * @date 2019/5/11 16:45 * @Version 3.0 * @description */public class TransactionManagerHandler implements InvocationHandler &#123; // 真实对象 private Object target; // 事务对象 private MyTransactionManger tx; public void setTarget(Object target) &#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger tx) &#123; this.tx = tx; &#125; // 获取代理对象 public &lt;T&gt; T getProxy()&#123; return (T) Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object result = null; tx.begin(); try &#123; result = method.invoke(target,args); tx.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); tx.rollback(); &#125; return result; &#125;&#125;测试12345678910111213141516171819202122232425/** * @author LuGuoZheng * @date 2019/5/11 16:58 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; MyTransactionManger tx = new MyTransactionManger(); EmployeeService employeeService = new EmployeeServiceImpl(); TransactionManagerHandler handler = new TransactionManagerHandler(); handler.setMyTransactionManger(tx); handler.setTarget(employeeService); System.out.println("真实类:" + employeeService); EmployeeService proxy = handler.getProxy(); System.out.println("代理类:" + proxy); proxy.save("张三","10年长期合同"); &#125;&#125;结果123开启事务我是真实对象,与张三签订了10年长期合同提交事务调用流程JDK动态代理总结Java 动态代理是使用 java.lang.reflect 包中的 Proxy 类与 InvocationHandler 接口这两个来完成的。要使用 JDK 动态代理，委托类必须实现接口。JDK 动态代理将会拦截所有 pubic 的方法（因为只能调用接口中定义的方法），这样即使在接口中增加了新的方法，不用修改代码也会被拦截。动态代理的最小单位是类（类中某些方法都会被处理），如果只想拦截一部分方法，可以在 invoke 方法中对要执行的方法名进行判断。对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统，也更符合面向接口编程规范。若委托类实现了接口，优先选用 JDK 动态代理。若委托类没有实现任何接口，使用 Javassit 和 CGLIB 动态代理。]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之静态代理模式]]></title>
    <url>%2F2019%2F05%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。代理模式客户端直接使用的都是代理对象，不知道真实对象是谁，此时代理对象可以在客户端和真实对象之间起到中介的作用。1.1、代理对象完全包含真实对象，客户端使用的都是代理对象的方法，和真实对象没有直接关系；1.2、代理模式的职责：把不是真实对象该做的事情从真实对象上撇开——职责分离。1. 静态代理在程序运行前就已经存在代理类的字节码文件,代理对象和真实对象的关系在运行前就确定了.2. 代码实现代理接口123456789101112131415/** * @author LuGuoZheng * @date 2019/5/9 9:42 * @Version 3.0 * @description 代理接口 */public interface EmployeeService &#123; /** * 签订合同 * @param name 姓名 * @param contract 合同 */ void save(String name, String contract);&#125;真实对象12345678910111213141516171819/** * @author LuGuoZheng * @date 2019/5/9 10:31 * @Version 3.0 * @description 真实对象 */public class EmployeeServiceImpl implements EmployeeService &#123; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; System.out.println("我是真实对象,与" + name + "签订了" + contract); &#125;&#125;代理对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author LuGuoZheng * @date 2019/5/9 10:34 * @Version 3.0 * @description 代理对象 */public class EmployeeProxyImpl implements EmployeeService &#123; /** * 真实对象 */ private EmployeeService target; private MyTransactionManger myTransactionManger; public void setTarget(EmployeeService target)&#123; this.target = target; &#125; public void setMyTransactionManger(MyTransactionManger myTransactionManger)&#123; this.myTransactionManger = myTransactionManger; &#125; /** * 签订合同 * * @param name 姓名 * @param contract 合同 */ @Override public void save(String name, String contract) &#123; myTransactionManger.begin(); try &#123; // 真实对象只负责签订合同 target.save(name,contract); // TODO 签订合同后处理一系列其他问题 myTransactionManger.commit(); &#125; catch (Exception e) &#123; myTransactionManger.rollback(); e.printStackTrace(); &#125; &#125;&#125;事务1234567891011121314151617181920/** * @author LuGuoZheng * @date 2019/5/9 11:17 * @Version 3.0 * @description 事务 */public class MyTransactionManger &#123; public void begin()&#123; System.out.println("开启事务"); &#125; public void rollback()&#123; System.out.println("回滚事务"); &#125; public void commit()&#123; System.out.println("提交事务"); &#125;&#125;测试123456789101112131415161718192021/** * @author LuGuoZheng * @date 2019/5/9 11:01 * @Version 3.0 * @description 测试 * * */public class Test &#123; public static void main(String[] args) &#123; EmployeeServiceImpl employeeService = new EmployeeServiceImpl(); EmployeeProxyImpl employeeProxy = new EmployeeProxyImpl(); MyTransactionManger myTransactionManger = new MyTransactionManger(); employeeProxy.setMyTransactionManger(myTransactionManger); employeeProxy.setTarget(employeeService); employeeProxy.save(" 张三 ","10长期合同~!"); &#125;&#125;测试结果123开启事务我是真实对象,与 张三 签订了10长期合同~!提交事务3. 静态代理优缺点优点业务只需要关注业务逻辑本身,保证了业务类的重要性.把真实对象隐藏起来,保护真实对象缺点代理对象的某个接口只服务于某一种类型的对象,也就是为每个真实类创建一个代理类.若需要代理的方法很多,那么就要为每一种方法都进行代理处理.若接口增加一个方法,除了所有实现类需要实现这个方法,代理类也需要实现此方法.]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之观察者模式]]></title>
    <url>%2F2019%2F05%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。观察者模式的定义在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。MQ的发布订阅模式其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。模式涵盖的角色抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。代码实现被观察者接口12345678910111213141516171819202122232425262728/** * @author LuGuoZheng * @date 2019/5/8 13:42 * @Version 3.0 * @description 被观察者接口 */public interface Observerable &#123; /** * 注册观察者 * * @param observer 观察者 */ void registerObServer(Observer observer); /** * 移除观察 * * @param observer 观察者 */ void removeObServer(Observer observer); /** * 通知观察者 * @param message 消息 */ void notifyObServer(String message);&#125;观察者接口12345678910111213141516/** * @author LuGuoZheng * @date 2019/5/8 13:44 * @Version 3.0 * @description */public interface Observer &#123; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ void update(String message);&#125;被观察者12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * @author LuGuoZheng * @date 2019/5/8 13:51 * @Version 3.0 * @description 公众号 */public class WechatServer implements Observerable &#123; /** * 寄存订阅了该公众号的用户(观察者) */ private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 注册观察者 * * @param observer 观察者 */ @Override public void registerObServer(Observer observer) &#123; observerList.add(observer); System.out.println("[" + ((User) observer).getName() + "]" + "关注了公众号~!"); &#125; /** * 取消观察 * * @param observer 观察者 */ @Override public void removeObServer(Observer observer) &#123; if (observer == null) &#123; return; &#125; boolean remove = observerList.remove(observer); if (remove) &#123; System.out.println("[" + ((User) observer).getName() + "]" + "取消了关注~! (╯‵□′)╯︵┻━┻"); &#125; &#125; /** * 通知观察者 * * @param message 消息 */ @Override public void notifyObServer(String message) &#123; for (Observer observer : observerList) &#123; observer.update(message); &#125; &#125;&#125;观察者123456789101112131415161718192021222324/** * @author LuGuoZheng * @date 2019/5/8 13:56 * @Version 3.0 * @description 观察者 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Observer &#123; private String name; /** * 当被观察者发布消息时,调用观察者的update方法,更新消息 * * @param message 消息 */ @Override public void update(String message) &#123; System.out.println("我是:" + name + "," + message); &#125;&#125;测试1234567891011121314151617181920212223242526272829303132/** * @author LuGuoZheng * @date 2019/5/8 14:24 * @Version 3.0 * @description */public class Test &#123; public static void main(String[] args) &#123; Observer u1 = new User("张三"); Observer u2 = new User("李四"); Observer u3 = new User("王五"); Observerable wecahtService = new WechatServer(); // 观察(订阅)公众号 wecahtService.registerObServer(u1); wecahtService.registerObServer(u2); wecahtService.registerObServer(u3); System.out.println("--------------------------------"); // 发布消息 wecahtService.notifyObServer("第一波福利"); System.out.println("--------------------------------"); // 取消关注 wecahtService.removeObServer(u1); System.out.println("--------------------------------"); // 发布消息 wecahtService.notifyObServer("这是第二波福利"); &#125;&#125;测试结果123456789101112[张三]关注了公众号~![李四]关注了公众号~![王五]关注了公众号~!--------------------------------我是:张三,第一波福利我是:李四,第一波福利我是:王五,第一波福利--------------------------------[张三]取消了关注~! (╯‵□′)╯︵┻━┻--------------------------------我是:李四,这是第二波福利我是:王五,这是第二波福利参考:JAVA设计模式之观察者模式]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux相关命令]]></title>
    <url>%2F2019%2F04%2F26%2FLinux%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[如题记录不常用的Linux命令运行java项目1nohup java -jar -Xms10m -Xmx200m ylcloud-item-service-0.0.1-SNAPSHOT.jar &gt; /pro/test/home/yanfa/nohup_item.out &amp; 2&gt;&amp;1 &amp;nohup: 后台启动项目-Xms10m -Xmx200m: jvm虚拟机参数查看某端口占用的线程的pid1netstat -nlp |grep :4000查看pid占用的端口号1netstat -nap | grep 32716二. 防火墙2.1 查看所有打开的端口1firewall-cmd --zone=public --list-ports2.2 开启端口（–permanent参数为永久生效，不加则重启后失效）1firewall-cmd --zone=public --add-port=端口号/tcp --permanent2.3 更新防火墙规则：1firewall-cmd --reload查看安装目录1which git]]></content>
      <categories>
        <category>服务器系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之策略模式]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。1. 简介思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换.策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。2. 代码实现接口123456789101112131415/** * @author LuGuoZheng * @date 2019/4/26 14:37 * @Version 3.0 * @description */public interface Condition &#123; /** * 条件 * @param num 数据 * @return */ boolean check(int num);&#125;类12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @author LuGuoZheng * @date 2019/4/26 14:36 * @Version 3.0 * @description 策略模式 */public class Strategy &#123; /** * 过滤数据方法 * @param nums 数据源 * @param condition 策略 * @return */ public List&lt;Integer&gt; filteNum(List&lt;Integer&gt; nums,Condition condition)&#123; List&lt;Integer&gt; newNums = new ArrayList&lt;&gt;(); for (Integer num : nums) &#123; if (condition.check(num))&#123; newNums.add(num); &#125; &#125; return newNums; &#125; @Test public void test() &#123; List&lt;Integer&gt; list = List.of(1, 2, 3, 4, 5, 6, 7); // 使用匿名内部类测试 list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num % 2 == 0; &#125; &#125;); System.out.println(list); // [2, 4, 6] list = filteNum(list, new Condition() &#123; @Override public boolean check(int num) &#123; return num &lt; 5; &#125; &#125;); System.out.println(list); // [2, 4] &#125;&#125;]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之模板模式]]></title>
    <url>%2F2019%2F04%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.1. 简介模板模式就是有很多相同的步骤的，在某一些地方可能有一些差别适合于这种模式,不同的地方通过子类覆写方法实现子类的特性.2. 代码实现抽象类1234567891011121314151617181920public abstract class Times &#123; private static final SimpleDateFormat fmt = new SimpleDateFormat("HH:mm:ss.SSS"); abstract void doWord(); public void test(String title) &#123; title = (title == null) ? "" : ("【" + title + "】"); System.out.println(title); System.out.println("开始：" + fmt.format(new Date())); long begin = System.currentTimeMillis(); doWord(); long end = System.currentTimeMillis(); System.out.println("结束：" + fmt.format(new Date())); double delta = (end - begin) / 1000.0; System.out.println("耗时：" + delta + "秒"); System.out.println("-------------------------------------"); &#125;&#125;子类1234567891011121314151617public class MyTemplate extends Times&#123; @Override public void doWord()&#123; int sum = 0; for (int i = 0; i &lt; 1000; i++) &#123; for (int j = 0; j &lt; 1000; j++) &#123; sum += j; &#125; &#125; System.out.println(sum); &#125; public static void main(String[] args) &#123; new MyTemplate().test("doWord"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2019%2F04%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例1. 简介单例模式就是单例对象的类只能运行一个实例存在,并且存在一个公共静态的方法来获取该实例2. 使用场景spring框架就是单例模式的3. 代码实现3.1 懒汉式(双检查保证线程安全)12345678910111213141516171819202122232425public class Singleton &#123; private Integer id; private String namge; private Integer age; private volatile static Singleton INSTANCE; // 私有化构造器 private Singleton ()&#123;&#125; // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; if (INSTANCE == null)&#123; synchronized (Singleton.class)&#123; if (INSTANCE == null)&#123; INSTANCE = new Singleton(); &#125; &#125; &#125; return INSTANCE; &#125;&#125;3.2 饥饿式123456789101112131415161718192021222324/** * * 优点: 直接在类加载时就初始化一个实例,可以避免线程安全问题 * 缺点: 由于是类加载时就初始化了一个实例,如果一直没有使用该实例,会造成内存浪费,而且没能起到懒加载效果 */public class Singleton &#123; private Integer id; private String name; private Integer age; // 私有化构造器 private Singleton()&#123;&#125; // 初始化一个实例 private static final Singleton INSTANCE = new Singleton(); // 提供公共静态方法获取实例 public static Singleton getInstance()&#123; return INSTANCE; &#125;&#125;3.3 枚举1234567891011121314public enum Singleton &#123; INSTANCE; private String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;3.4 枚举反编译(使用XJad反编译)通过反编译可以看出就是一个饥饿式单例模式,所有实现单例模式直接写一个枚举即可.123456789101112131415161718192021222324252627282930313233343536373839404142// 使用final修饰类,并继承了Enum类public final class Singleton extends Enum&#123; public static final Singleton INSTANCE; private String name; private static final Singleton $VALUES[]; public static Singleton[] values() &#123; return (Singleton[])$VALUES.clone(); &#125; public static Singleton valueOf(String name) &#123; return (Singleton)Enum.valueOf(53554F8B6A215F0F/Singleton, name); &#125; private Singleton(String s, int i) &#123; super(s, i); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; // 在静态代码块中直接创建了一个实例 static &#123; INSTANCE = new Singleton("INSTANCE", 0); $VALUES = (new Singleton[] &#123; INSTANCE &#125;); &#125;&#125;]]></content>
      <categories>
        <category>设计模式系列</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四→六月份学习计划(二季度)]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%9B%9B%E2%80%94%E2%80%94%E5%85%AD%E6%9C%88%E4%BB%BD%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[如题spring使用到的设计模式:简单工厂工厂方法（Factory Method）单例（Singleton）适配器（Adapter）包装器（Decorator）代理（Proxy）观察者（Observer）策略（Strategy）模板方法（Template Method）计划安排 四 → 五月份学习数据结构与算法课程 在LeetCode练习算法题 巩固学习一种设计模式并实现进行中计划 数据结构与算法课程 算法练习 设计模式计划进度 (代码) 算法练习 设计模式 单例模式 模板模式 策略模式 观察者模式 静态代理模式 动态代理模式]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法复杂度]]></title>
    <url>%2F2019%2F04%2F19%2F%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度:估算程序指令的执行次数(执行时间)空间复杂度:估算所需占用的存储空间算法网站👇:https://leetcode-cn.com/时间复杂度 百度百科:时间复杂度是同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。 个人理解:估算程序指令的执行次数(执行时间)空间复杂度 百度百科:空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面衡量。 个人理解:估算所需占用的存储空间大O表示法一般用大O表示法来描述复杂度,表示的是数据规模n对应的复杂度123456789忽略常数、系数、低阶9 &gt;&gt;&gt; O(1)2n + 3 &gt;&gt;&gt; O(n)$n^2$ + 2n + 6 &gt;&gt;&gt; O($n^2$)$4n^3$ + $3n^2$ + 22n + 100 &gt;&gt;&gt; O($n^3$)注意:大O表示法仅仅只是一种粗略的分析模型,是一种估算,能帮助我们短时间内了解一个算法的执行效率常见的复杂度对数阶细节对数阶一般省略底数1$log_2 n = log_2 9 * log_9 n$$所以log_2 n、log_9 n统称为log_n$]]></content>
      <categories>
        <category>数据结构与算法系列</category>
      </categories>
      <tags>
        <tag>复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo隐式参数传递]]></title>
    <url>%2F2019%2F04%2F17%2FDobbu%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[记录一个dobbu传递隐式参数demo,调用RPC服务时用于服务消费者向服务提供者传递隐式参数,比如向服务提供者传递token信息.上下文信息RpcContext是一个ThreadLocal的临时状态记录器，当接收到RPC请求，或发起RPC请求时，RpcContext的状态都会变化。比如A调用B，B再调用C，则B机器上，在B调用C之前，RpcContext记录的是A调用B的信息，在B调用C之后，RpcContext记录的是B调用C。服务消费者:controller层12345678910111213141516@Controller@RequestMapping("/test")public class TestController &#123; @Reference private ICarService iCarService; @RequestMapping("/test") @ResponseBody public String test()&#123; // 传递参数 RpcContext.getContext().setAttachment("TOKEN","测试隐士参数传递"); iCarService.test(); return "参数"; &#125;&#125;服务提供者:service层接口123public interface ICarService &#123; void test();&#125;实现类123456789@Service@Transactionalpublic class CarServiceImpl implements ICarService &#123; public void test() &#123; // 获取参数 String token = RpcContext.getContext().getAttachment("TOKEN"); System.out.println(token); &#125;&#125;项目使用场景在项目中使用的是登录后,会生成一个token返回给用户,用户每次登录都要把改token带过来进行登录验证,验证通过后则去调用RPC服务,可以通过隐士参数传递把token传递到服务提供者,这样就可以获取到当前登录用户的token,然后去获取当前登录用户信息.注意如果使用setAttachments会把原来的参数清空,后再保存现在的参数.源码123456789public RpcContext setAttachments(Map&lt;String, String&gt; attachment) &#123; // 清空参数 this.attachments.clear(); if (attachment != null &amp;&amp; attachment.size() &gt; 0) &#123; this.attachments.putAll(attachment); &#125; return this;&#125;]]></content>
      <categories>
        <category>Dubbo系列</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置maven打包方式]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%85%8D%E7%BD%AEmaven%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用maven-jar-plugin和maven-dependency-plugin插件打包使用maven-jar-plugin和maven-dependency-plugin打包的原因及好处现在项目使用的springboot框架搭建的maven项目,由于使用jenkins自动部署项目,而且并没有配置单个模块部署,导致每次部署都要10来分钟,严重浪费时间,现在使用该插件打包后不用每次都使用jenkins部署,直接本地打包好之后替换掉服务器的jar就行,而且打包完可以看到jar是很小的,上传也很快1. 配置pom文件12345678910111213141516171819202122232425262728293031323334&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- springboot启动类 --&gt; &lt;mainClass&gt;cn.lgz.shop.GoodsApp&lt;/mainClass&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt;&lt;/plugin&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy-dependencies&lt;/id&gt; &lt;phase&gt;package&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/lib&lt;/outputDirectory&gt; &lt;overWriteReleases&gt;false&lt;/overWriteReleases&gt; &lt;overWriteSnapshots&gt;false&lt;/overWriteSnapshots&gt; &lt;overWriteIfNewer&gt;true&lt;/overWriteIfNewer&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt;&lt;/plugin&gt;2. 打包效果打包后会把项目代码和依赖分离开来:依赖会打包到lib目录项目代码会打包成一个jar包]]></content>
      <categories>
        <category>java</category>
        <category>工具配置相关</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSL数字证书Nginx配置部署]]></title>
    <url>%2F2019%2F04%2F13%2FSSL%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6Nginx%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[记录Nginx配置SSL数字证书的步骤以及遇到一些的问题 实践成果：为本网站部署SSL证书，实现https访问👇环境以及证书👇:阿里云服务器: CentOS7SSL数字证书: Symantec DV SSL证书（免费版）一. 添加SSL模块1.0 进入nginx解压目录使用执行以下命令添加SSL模块1./configure --with-http_ssl_module如果报错./configure: error: SSL modules require the OpenSSL library.则执行123yum -y install openssl openssl-devel./configure执行make（切记不能make install会覆盖安装目录）将原来nginx备份(可选）:如果自己nginx有什么重要配置可以先备份以防丢失1cp objs/nginx /usr/local/nginx/sbin/nginx将新的nginx覆盖旧安装目录1cp objs/nginx /usr/local/nginx/sbin/nginx二. 配置SSL证书1.0 进入Nginx安装目录conf目录(PS:安装目录和解压目录不是同一个目录）1cd /usr/local/nginx/conf/创建cert目录,并把准备好的SSL数字证书放在该目录下1mkdir cert返回conf文件，编辑nginx.conf配置文件，找到以下内容12345678910111213141516 # HTTPS server #server &#123; #listen 443; #server_name localhost; #ssl_certificate cert.pem; #ssl_certificate_key cert.key; #ssl_session_timeout 5m; #ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP; #ssl_prefer_server_ciphers on; #location / &#123; #root html; #index index.html index.htm; #proxy_pass http://localhost:4000; #&#125;#&#125;把以上内容替换为以下内容，或者注释以上内容重新添加也可以：123456789101112131415161718# 以下属性中以ssl开头的属性代表与证书配置有关，其他属性请根据自己的需要进行配置。 server &#123; listen 443; server_name localhost; # localhost修改为您证书绑定的域名。 ssl on; #设置为on启用SSL功能。 root html; index index.html index.htm; ssl_certificate cert/domain name.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录。 index index.html index.htm; #添加属性。 &#125; &#125;三. 配置阿里云服务器安全组规则⭐ 如果你以上步骤都没有问题，但是还是访问不了，那就要查看下是否有配置443端口的安全组，如果没有加上即可。四. 参考资料https://help.aliyun.com/document_detail/98728.htmlhttps://help.aliyun.com/video_detail/54216.html?spm=5176.2000002.0.0.19057747sUlwcdhttps://blog.csdn.net/weiyangdong/article/details/80008543]]></content>
      <categories>
        <category>服务器系列</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel导入导出]]></title>
    <url>%2F2019%2F04%2F10%2FExcel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[记录一个java基于jxl实现的Excel导入导出功能一. 引入依赖12345&lt;dependency&gt; &lt;groupId&gt;net.sourceforge.jexcelapi&lt;/groupId&gt; &lt;artifactId&gt;jxl&lt;/artifactId&gt; &lt;version&gt;2.6.12&lt;/version&gt;&lt;/dependency&gt;二. 导出2.0 接口编写1234567891011121314151617181920@RequestMapping(value = "/export")public void test(HttpServletResponse response) throws Exception &#123; WritableWorkbook workbook = Workbook.createWorkbook(response.getOutputStream()); // 响应格式 response.setContentType("application/vnd.ms-excel"); response.setHeader("Content-Disposition", "attachment; filename=" + URLEncoder.encode("文件名称.xls", "UTF-8")); // 创建一个工作簿: WritableSheet sheet1 = workbook.createSheet("工作簿名称", 0); Label label1 = new Label(0, 0, "商品id"); sheet1.addCell(label1); Label label2 = new Label(1, 0, "公司编号"); sheet1.addCell(label2); //查询数据写到workbook中 workbook.write(); System.out.println("查询数据写到workbook中"); //关闭资源 workbook.close();&#125;2.1 导出效果如下三. 导入3.0 读取Excel接口12345678910111213141516171819202122232425262728293031@PostMapping(value = "/excel")public void importExcel(MultipartFile file) &#123; Workbook workbook = null; List&lt;ItemDto&gt; items = new ArrayList&lt;&gt;(); HashMap&lt;String, ItemDto&gt; map = new HashMap&lt;&gt;(); try &#123; //获取xls文件Excel workbook = Workbook.getWorkbook(file.getInputStream()); //获取商品工作簿:可通过索引获取不同工作簿 Sheet itemSheet = workbook.getSheet(0); //获取总行数 int rows = itemSheet.getRows(); //格式化导入的日期格式 for (int i = 1; i &lt; rows; i++) &#123; Cell[] row = itemSheet.getRow(i); if (row.length == 0) &#123; continue; &#125; String itemId = itemSheet.getCell(0, i).getContents(); System.out.println(itemId); String scompCode = itemSheet.getCell(1, i).getContents(); System.out.println(scompCode); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //关闭资源 workbook.close(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo之瞎折腾系列]]></title>
    <url>%2F2019%2F03%2F30%2FHexo%E7%9E%8E%E6%8A%98%E8%85%BE%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[该文档记录Theme-AD主题个人博客部署到云服务器以及记录新增的一些小功能~！Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/Let’s Go~!Theme-AD主题具体搭建步骤可以参考：https://godbmw.com/tags/Hexo/一.云服务器部署Hexo参考文档：https://www.jianshu.com/p/b2e47ec9359d1.1 后台运行Hexo部署到云服务器后如果还是在hexo根目录下使用命令启动，会有个问题就是：当你断开服务器连接之后hexo服务就会停止，无法访问。那么可以用pm2启动hexo，这样hexo就在后台运行了，就算断开服务器连接也不会停止1.2 安装pm21npm install -g pm2ps：如果感兴趣也可以了解下Linux的nohup命令1.2 在hexo创建run.js文件12345678910//run.jsconst &#123; exec &#125; = require('child_process')exec('hexo server',(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(`exec error: $&#123;error&#125;`) return &#125; console.log(`stdout: $&#123;stdout&#125;`); console.log(`stderr: $&#123;stderr&#125;`);&#125;)1.3 运行脚本1pm2 start run.js二.为自己的博客添加萌宠参考博客：https://blog.csdn.net/u010820857/article/details/822707362.1 安装模块1npm install --save hexo-helper-live2d2.2 选择想要的萌宠12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z162.3 选择好之后还需要安装例如我选择的是：live2d-widget-model-z161npm install live2d-widget-model-z162.4 最后一步配置Hexo的主配置文件_config.yml1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-z16 // 这里改为自己选择的萌宠 其他参数可以根据自己喜好看着修改 display: position: right width: 150 height: 300 mobile: show: true三. hexo部署到GitHub后绑定域名(未备案域名也可以)3.1 GitHub相关配置在根目录下添加CNAME文件(名称大写),在文件中输入域名CNAME 文件:文件内容就是你的域名:在设置中配置域名:3.2 修改域名解析记录按照下面添加域名解析记录:ps:截图中记录值的ip是通过ping`自己的xxx.github.io得到四. 新增站内搜索功能原本Theme-AD主题是没有站内搜索的,本站点移植的是Ocean主题的站内搜索功能.4.1 修改header.ejs文件把原本主题的搜索框移除,在相对应位置加入搜索按钮和搜索框12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;header class="site-header"&gt; &lt;div class="site-header-brand"&gt; &lt;% if(theme.nav_name) &#123; %&gt; &lt;span class="site-header-brand-title"&gt; &lt;a href="&lt;%- url_for('/') %&gt;"&gt;&lt;%- theme.nav_name %&gt;&lt;/a&gt; &lt;/span&gt; &lt;% &#125; %&gt; &lt;% if(theme.motto) &#123; %&gt; &lt;span class="site-header-brand-motto"&gt; | &lt;%- theme.motto %&gt;&lt;/span&gt; &lt;% &#125; %&gt; &lt;/div&gt; &lt;div class="site-header-right"&gt; &lt;nav class="site-header-navigation"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;a href="&lt;%- url_for(link.path) %&gt;" target="&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;"&gt;&lt;%= link.name%&gt;&lt;/a&gt; &lt;% &#125; %&gt; &lt;/nav&gt; &lt;!-- 搜索按钮 --&gt; &lt;nav class="navbar"&gt; &lt;a href="#" class="nav-item-link nav-item-search" title="&lt;%= __('搜索') %&gt;"&gt; &lt;i class="fe fe-search"&gt;&lt;/i&gt; &lt;%- theme.search_text %&gt; &lt;/a&gt; &lt;/nav&gt; &lt;div class="site-header-btn"&gt; &lt;% if(theme.github) &#123; %&gt; &lt;a href="&lt;%- theme.github %&gt;" target="_blank" id="site-github"&gt; &lt;i class="fa fa-github-alt"&gt;&lt;/i&gt; &lt;/a&gt; &lt;% &#125; %&gt; &lt;/dev&gt;&lt;/div&gt;&lt;!-- 搜索框 --&gt;&lt;div class="search-form-wrap"&gt; &lt;div class="local-search local-search-plugin"&gt; &lt;input type="search" id="local-search-input" class="local-search-input" placeholder="Search..."&gt; &lt;div id="local-search-result" class="local-search-result"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/header&gt;&lt;nav class="table-content" id="site-nav"&gt; &lt;div class="table-content-title"&gt; &lt;span&gt;导航&lt;/span&gt; &lt;/div&gt; &lt;div class="table-content-main"&gt; &lt;ol class="toc"&gt; &lt;% for(let link of theme.nav) &#123; %&gt; &lt;li class="toc-item"&gt; &lt;a href="&lt;%- url_for(link.path) %&gt;" target="&lt;%- link.path.startsWith('http') ? '_blank' : '_self' %&gt;"&gt; &lt;%= link.name %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/ol&gt; &lt;/div&gt;&lt;/nav&gt;&lt;div id="site-process"&gt;&lt;/div&gt;4.2 把Ocean主题中source中css的feathericon移到自己主题的css目录下4.3 在css目录下创建_feathericon.styl文件12345678910111213141516171819202122232425262728293031323334353637@charset "utf-8"//---------------------------------------------------------------------------// feathericon//---------------------------------------------------------------------------//// variablesfeathericon-font-path = 'feathericon/' !default;//// font path@font-face font-family feathericon font-weight normal font-style normal src: url(feathericon-font-path + 'feathericon.eot') src: url(feathericon-font-path + 'feathericon.eot?#iefix') format('embedded-opentype'), url(feathericon-font-path + 'feathericon.woff') format('woff'), url(feathericon-font-path + 'feathericon.ttf') format('truetype'), url(feathericon-font-path + 'feathericon.svg') format('svg');//// feathericon//.fe display inline-block font normal normal normal 16px feathericon font-size inherit text-rendering auto -webkit-font-smoothing antialiased -moz-osx-font-smoothing grayscale.fe-search:before &#123; content: "\f14e"; &#125;.fe-search-minus:before &#123; content: "\f16a"; &#125;.fe-search-plus:before &#123; content: "\f16b"; &#125;4.4 在css目录下创建_mixins.styl文件123456border-radius(n) -webkit-border-radius n -moz-border-radius n border-radius n// Media queries4.5 在css目录下创建_variables.styl文件123456789101112131415161718192021// Configsupport-for-ie = falsevendor-prefixes = webkit moz ms official// Fontsfont-size-browser = 62.5%font-size-base = 1.4remfont-family-base = "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-seriffont-line-height = 1.7// Colorssea = #1e3e3ffroth-light = #f4f4f4white = #ffffffsand-light = #9c8079sand = #9e6a4d// Borderborder-radius = 0.4remborder-width = 0.1remborder-color = froth4.6 在css目录下创建style.styl文件123456789101112131415161718192021222324252627@import &quot;_variables&quot;@import &quot;_feathericon&quot;//@import &quot;_normalize&quot;@import &quot;_mixins&quot;@import &quot;search&quot;*,*::before*::after box-sizing border-boxhtml font-size font-size-browserbody background-color body-background font-family font-family-base font-size font-size-base line-height font-line-height color body-color padding 0 margin 0 overflow-x hidden text-size-adjust: 100% ::selection background sea-lighter color froth4.7 修改header.js文件(替换掉所有内容)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162(function ($) &#123; // Search ------------ var $searchWrap = $('.search-form-wrap'), isSearchAnim = false, searchAnimDuration = 200; var startSearchAnim = function () &#123; isSearchAnim = true; &#125;; var stopSearchAnim = function (callback) &#123; setTimeout(function () &#123; isSearchAnim = false; callback &amp;&amp; callback(); &#125;, searchAnimDuration); &#125;; $('.nav-item-search').on('click', function () &#123; if (isSearchAnim) return; startSearchAnim(); $searchWrap.addClass('on'); stopSearchAnim(function () &#123; $('.local-search-input').focus(); &#125;); &#125;); $(document).mouseup(function (e) &#123; var _con = $('.local-search'); if (!_con.is(e.target) &amp;&amp; _con.has(e.target).length === 0) &#123; $searchWrap.removeClass('on'); &#125; &#125;); // 移动设备侦测 var isMobile = &#123; Android: function () &#123; return navigator.userAgent.match(/Android/i); &#125;, BlackBerry: function () &#123; return navigator.userAgent.match(/BlackBerry/i); &#125;, iOS: function () &#123; return navigator.userAgent.match(/iPhone|iPad|iPod/i); &#125;, Opera: function () &#123; return navigator.userAgent.match(/Opera Mini/i); &#125;, Windows: function () &#123; return navigator.userAgent.match(/IEMobile/i); &#125;, any: function () &#123; return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows()); &#125; &#125;; // 建议在移动端不初始化，其实 /search.xml 文件还挺大的， if ($('.local-search').size() &amp;&amp; !isMobile.any()) &#123; $.getScript('/js/search.js', function () &#123; searchFunc("/search.xml", 'local-search-input', 'local-search-result'); &#125;); &#125; // Share ------------ $('body').on('click', function () &#123; $('.article-share-box.on').removeClass('on'); &#125;).on('click', '.article-share-link', function (e) &#123; e.stopPropagation(); var $this = $(this), url = $this.attr('data-url'), encodedUrl = encodeURIComponent(url), id = 'article-share-box-' + $this.attr('data-id'), offset = $this.offset(); if ($('#' + id).length) &#123; var box = $('#' + id); if (box.hasClass('on')) &#123; box.removeClass('on'); return; &#125; &#125; else &#123; var html = [ '&lt;div id="' + id + '" class="article-share-box"&gt;', '&lt;input class="article-share-input" value="' + url + '"&gt;', '&lt;div class="article-share-links"&gt;', '&lt;a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"&gt;&lt;/a&gt;', '&lt;a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"&gt;&lt;/a&gt;', '&lt;a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"&gt;&lt;/a&gt;', '&lt;a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"&gt;&lt;/a&gt;', '&lt;/div&gt;', '&lt;/div&gt;' ].join(''); var box = $(html); $('body').append(box); &#125; $('.article-share-box.on').hide(); box.css(&#123; top: offset.top + 25, left: offset.left &#125;).addClass('on'); &#125;).on('click', '.article-share-box', function (e) &#123; e.stopPropagation(); &#125;).on('click', '.article-share-box-input', function () &#123; $(this).select(); &#125;).on('click', '.article-share-box-link', function (e) &#123; e.preventDefault(); e.stopPropagation(); window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450'); &#125;); // fancybox if ($.fancybox) &#123; $('[data-fancybox]').fancybox(&#123; protect: true &#125;); &#125; // lazyload //$(".lazy").lazyload(); // $(document).ready(function ($) &#123; $(".anchor").click(function (event) &#123; event.preventDefault(); $('html,body').animate(&#123;scrollTop: $(this.hash).offset().top&#125;, 500); &#125;); &#125;); // Mobile nav var $content = $('.content'), $sidebar = $('.sidebar'), isMobileNavAnim = false, mobileNavAnimDuration = 200; var startMobileNavAnim = function () &#123; isMobileNavAnim = true; &#125;; var stopMobileNavAnim = function () &#123; setTimeout(function () &#123; isMobileNavAnim = false; &#125;, mobileNavAnimDuration); &#125;; $('.navbar-toggle').on('click', function () &#123; if (isMobileNavAnim) return; startMobileNavAnim(); $content.toggleClass('on'); $sidebar.toggleClass('on'); stopMobileNavAnim(); &#125;); $($content).on('click', function () &#123; if (isMobileNavAnim || !$content.hasClass('on')) return; $content.removeClass('on'); $sidebar.removeClass('on'); &#125;);&#125;)(jQuery);4.8 引入jquery-2.0.3.min.js4.9 创建search.js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127// A local search script with the help of [hexo-generator-search](https://github.com/PaicHyperionDev/hexo-generator-search)// Copyright (C) 2015 // Joseph Pan &lt;http://github.com/wzpan&gt;// Shuhao Mao &lt;http://github.com/maoshuhao&gt;// This library is free software; you can redistribute it and/or modify// it under the terms of the GNU Lesser General Public License as// published by the Free Software Foundation; either version 2.1 of the// License, or (at your option) any later version.// // This library is distributed in the hope that it will be useful, but// WITHOUT ANY WARRANTY; without even the implied warranty of// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU// Lesser General Public License for more details.// // You should have received a copy of the GNU Lesser General Public// License along with this library; if not, write to the Free Software// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA// 02110-1301 USA// var searchFunc = function (path, search_id, content_id) &#123; 'use strict'; var BTN = "&lt;button type='button' class='local-search-close' id='local-search-close'&gt;&lt;/button&gt;"; $.ajax(&#123; url: path, dataType: "xml", success: function (xmlResponse) &#123; // get the contents from search data var datas = $("entry", xmlResponse).map(function () &#123; return &#123; title: $("title", this).text(), content: $("content", this).text(), url: $("url", this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener('input', function () &#123; var str = '&lt;ul class="search-result-list"&gt;'; var keywords = this.value.trim().toLowerCase().split(/[\s]+/); $resultContent.innerHTML = ""; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function (data) &#123; var isMatch = true; // var content_index = []; if (!data.title || data.title.trim() === '') &#123; data.title = "Untitled"; &#125; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, "").toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty contents if (data_content !== '') &#123; keywords.forEach(function (keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if (index_title &lt; 0 &amp;&amp; index_content &lt; 0) &#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; // content_index.push(&#123;index_content:index_content, keyword_len:keyword_len&#125;); &#125; &#125;); &#125; else &#123; isMatch = false; &#125; // show search results if (isMatch) &#123; str += "&lt;li&gt;&lt;a href='" + data_url + "' class='search-result-title'&gt;" + data_title + "&lt;/a&gt;"; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, ""); if (first_occur &gt;= 0) &#123; // cut out 100 characters var start = first_occur - 20; var end = first_occur + 80; if (start &lt; 0) &#123; start = 0; &#125; if (start == 0) &#123; end = 100; &#125; if (end &gt; content.length) &#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function (keyword) &#123; var regS = new RegExp(keyword, "gi"); match_content = match_content.replace(regS, "&lt;em class=\"search-keyword\"&gt;" + keyword + "&lt;/em&gt;"); &#125;); str += "&lt;p class=\"search-result\"&gt;" + match_content + "...&lt;/p&gt;" &#125; str += "&lt;/li&gt;"; &#125; &#125;); str += "&lt;/ul&gt;"; if (str.indexOf('&lt;li&gt;') === -1) &#123; return $resultContent.innerHTML = BTN + "&lt;div class=\"search-result-empty\"&gt;&lt;p&gt;&lt;i class=\"fe fe-tired\"&gt;&lt;/i&gt; 没有找到内容，更换下搜索词试试吧~&lt;p&gt;&lt;/div&gt;"; &#125; $resultContent.innerHTML = BTN + str; &#125;); &#125; &#125;); $(document).on('click', '#local-search-close', function () &#123; $('#local-search-input').val(''); $('#local-search-result').html(''); &#125;);&#125;;4.10 最后修改head.ejs文件,引入js和css五. 添加置顶功能5.1 在hexo目录下执行以下命令123npm uninstall hexo-generator-index --savenpm install hexo-generator-index-pin-top --save5.2 在index.ejs加入以下代码1234&lt;% if(psg.top === true) &#123;%&gt; &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt; &lt;font color=7D26CD&gt;置顶&lt;/font&gt; |&lt;% &#125; %&gt;5.3 在需要置顶的博文中添加12top: true---六. 使用hexo-neat压缩页面6.1 安装hexo-neat插件1npm install hexo-neat --save6.2 在站点_config.yml配置文件中添加配置12345678910111213141516171819202122# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css: 这里只是压缩页面的css,如果是在source目录下的css要在exclude移除掉,否则压缩后会直接变成一个空文件 neat_css: enable: true exclude: - &apos;**/*.min.css&apos;# 压缩js:(同css说明)neat_js: enable: true mangle: true output: compress: exclude: - &apos;**/*.min.js&apos; - &apos;**/jquery.fancybox.pack.js&apos; - &apos;**/index.js&apos;]]></content>
      <categories>
        <category>Hexo之瞎折腾系列</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-安装(CentOS7)]]></title>
    <url>%2F2019%2F03%2F27%2FUntitled%2F</url>
    <content type="text"><![CDATA[CentOS7docker安装步骤1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker//有则删除对应的包yum remove docker ......1.安装需要的软件包:yum-util提供yum-config-manager功能1yum install -y yum-utils device-mapper-persistent-data lvm2ps:如果安装过docker,需要重装可以先删除在装:12345// 查看是否有安装dockeryum list installed | grep docker//有则删除对应的包yum remove docker ......2.设置yum源(阿里源)1yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo3.查看yum库中有没有docker-ce1yum list | grep docker-ce4.安装docker1yum install -y docker-ce5.如果需要设置开机自动启动12345 //先启动docker服务端systemctl start docker//启动docker服务开机自启systemctl enable docker6.校验docker是否启动成功1docker version常见问题: 普通用户运行docker 命令会报错:由于docker daemon需要绑定到主机的 Unix socket 而不是普通的TCP端口,而 Unix socket 的宿主为 root 用户,如果其他用户使用 docker 命令只有在命令钱添加 sudo 才能执行成功,如果不想每次使用 docker 命令是还要多敲 sudo ,可以按照下面的方法解决:s1.切换到 root 用户2.把普通用户添加到 docker 组3.再切换到&lt;普通用户&gt;4.验证 docker 命令是否成功]]></content>
      <categories>
        <category>docker容器系列</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
